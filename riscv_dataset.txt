# See LICENSE for license details.

#*****************************************************************************
# fcvt.S
#-----------------------------------------------------------------------------
#
# Test fcvt.h.{wu|w|lu|l}, fcvt.h.d, and fcvt.d.h instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_INT_FP_OP_H( 2,  fcvt.h.w,                   2.0,  2);
  TEST_INT_FP_OP_H( 3,  fcvt.h.w,                  -2.0, -2);

  TEST_INT_FP_OP_H( 4, fcvt.h.wu,                   2.0,  2);
  TEST_INT_FP_OP_H( 5, fcvt.h.wu,               0h:7c00, -2);

#if __riscv_xlen >= 64
  TEST_INT_FP_OP_H( 6,  fcvt.h.l,                   2.0,  2);
  TEST_INT_FP_OP_H( 7,  fcvt.h.l,                  -2.0, -2);

  TEST_INT_FP_OP_H( 8, fcvt.h.lu,                   2.0,  2);
  TEST_INT_FP_OP_H( 9, fcvt.h.lu,               0h:7c00, -2);
#endif
  
  TEST_FCVT_H_S( 10, -1.5, -1.5)

#if __riscv_xlen >= 64
  TEST_FCVT_H_D( 11, -1.5, -1.5)
#endif
  
  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fdiv.S
#-----------------------------------------------------------------------------
#
# Test f{div|sqrt}.h instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP2_H(2,  fdiv.h, 1, 1.1557273520668288, 3.14159265, 2.71828182 );
  TEST_FP_OP2_H(3,  fdiv.h, 1,-0.9991093838555584,      -1234,     1235.1 );
  TEST_FP_OP2_H(4,  fdiv.h, 0,         3.14159265, 3.14159265,        1.0 );

  TEST_FP_OP1_H(5,  fsqrt.h, 1, 1.7724538498928541, 3.14159265 );
  TEST_FP_OP1_H(6,  fsqrt.h, 0,                100,      10000 );

  TEST_FP_OP1_H_DWORD_RESULT(7,  fsqrt.h, 0x10, 0x00007e00, -1.0 );

  TEST_FP_OP1_H(8,  fsqrt.h, 1, 13.076696, 171.0);


  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fmadd.S
#-----------------------------------------------------------------------------
#
# Test f[n]m{add|sub}.h and f[n]m{add|sub}.h instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP3_H( 2,  fmadd.h, 0,                 3.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_H( 3,  fmadd.h, 1,                13.2, -1.0,      -12.1,        1.1 );
  TEST_FP_OP3_H( 4,  fmadd.h, 0,               -12.0,  2.0,       -5.0,       -2.0 );

  TEST_FP_OP3_H( 5, fnmadd.h, 0,                -3.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_H( 6, fnmadd.h, 1,               -13.2, -1.0,      -12.1,        1.1 );
  TEST_FP_OP3_H( 7, fnmadd.h, 0,                12.0,  2.0,       -5.0,       -2.0 );

  TEST_FP_OP3_H( 8,  fmsub.h, 0,                 1.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_H( 9,  fmsub.h, 1,                  11, -1.0,      -12.1,        1.1 );
  TEST_FP_OP3_H(10,  fmsub.h, 0,                -8.0,  2.0,       -5.0,       -2.0 );

  TEST_FP_OP3_H(11, fnmsub.h, 0,                -1.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_H(12, fnmsub.h, 1,                 -11, -1.0,      -12.1,        1.1 );
  TEST_FP_OP3_H(13, fnmsub.h, 0,                 8.0,  2.0,       -5.0,       -2.0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ldst.S
#-----------------------------------------------------------------------------
#
# This test verifies that flw, fld, fsw, and fsd work properly.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  TEST_CASE(2, a0, 0xcafe1000deadbeef, la a1, tdat; flh f1, 4(a1); fsh f1, 20(a1); ld a0, 16(a1))
  TEST_CASE(3, a0, 0x1337d00dabad0001, la a1, tdat; flh f1, 0(a1); fsh f1, 24(a1); ld a0, 24(a1))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
.word 0xbf800001
.word 0x40001000
.word 0x40400000
.word 0xc0800000
.word 0xdeadbeef
.word 0xcafebabe
.word 0xabad1dea
.word 0x1337d00d

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fmin.S
#-----------------------------------------------------------------------------
#
# Test f{min|max}.h instructinos.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP2_H( 2,  fmin.h, 0,        1.0,        2.5,        1.0 );
  TEST_FP_OP2_H( 3,  fmin.h, 0,    -1235.1,    -1235.1,        1.1 );
  TEST_FP_OP2_H( 4,  fmin.h, 0,    -1235.1,        1.1,    -1235.1 );
  TEST_FP_OP2_H( 5,  fmin.h, 0,    -1235.1,        NaN,    -1235.1 );
  TEST_FP_OP2_H( 6,  fmin.h, 0, 0.00000001, 3.14159265, 0.00000001 );
  TEST_FP_OP2_H( 7,  fmin.h, 0,       -2.0,       -1.0,       -2.0 );

  TEST_FP_OP2_H(12,  fmax.h, 0,        2.5,        2.5,        1.0 );
  TEST_FP_OP2_H(13,  fmax.h, 0,        1.1,    -1235.1,        1.1 );
  TEST_FP_OP2_H(14,  fmax.h, 0,        1.1,        1.1,    -1235.1 );
  TEST_FP_OP2_H(15,  fmax.h, 0,    -1235.1,        NaN,    -1235.1 );
  TEST_FP_OP2_H(16,  fmax.h, 0, 3.14159265, 3.14159265, 0.00000001 );
  TEST_FP_OP2_H(17,  fmax.h, 0,       -1.0,       -1.0,       -2.0 );

  # FMIN(sNaN, x) = x
  TEST_FP_OP2_H_HEX(20,  fmax.h, 0x10, 0x3c00, 0x7c01, 0x3c00);
  # FMIN(hNaN, hNaN) = canonical NaN
  TEST_FP_OP2_H_HEX(21,  fmax.h, 0x00, 0x7e00, 0x7fff, 0x7fff);

  # -0.0 < +0.0
  TEST_FP_OP2_H(30,  fmin.h, 0,       -0.0,       -0.0,        0.0 );
  TEST_FP_OP2_H(31,  fmin.h, 0,       -0.0,        0.0,       -0.0 );
  TEST_FP_OP2_H(32,  fmax.h, 0,        0.0,       -0.0,        0.0 );
  TEST_FP_OP2_H(33,  fmax.h, 0,        0.0,        0.0,       -0.0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# recoding.S
#-----------------------------------------------------------------------------
#
# Test corner cases of John Hauser's microarchitectural recoding scheme.
# There are twice as many recoded values as IEEE-754 values; some of these
# extras are redundant (e.g. Inf) and others are illegal (subnormals with
# too many bits set).
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  # Make sure infinities with different mantissas compare as equal.
  flw f0, minf, a0
  flw f1, three, a0
  fmul.s f1, f1, f0
  TEST_CASE( 2, a0, 1, feq.s a0, f0, f1)
  TEST_CASE( 3, a0, 1, fle.s a0, f0, f1)
  TEST_CASE( 4, a0, 0, flt.s a0, f0, f1)

  # Likewise, but for zeroes.
  fcvt.s.w f0, x0
  li a0, 1
  fcvt.s.w f1, a0
  fmul.s f1, f1, f0
  TEST_CASE(5, a0, 1, feq.s a0, f0, f1)
  TEST_CASE(6, a0, 1, fle.s a0, f0, f1)
  TEST_CASE(7, a0, 0, flt.s a0, f0, f1)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

minf: .float -Inf
three: .float 3.0

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fclass.S
#-----------------------------------------------------------------------------
#
# Test fclass.h instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  #define TEST_FCLASS_H(testnum, correct, input) \
    TEST_CASE(testnum, a0, correct, li a0, input; fmv.h.x fa0, a0; \
                                    fclass.h a0, fa0)

  TEST_FCLASS_H( 2, 1 << 0, 0xfc00 )
  TEST_FCLASS_H( 3, 1 << 1, 0xbc00 )
  TEST_FCLASS_H( 4, 1 << 2, 0x83ff )
  TEST_FCLASS_H( 5, 1 << 3, 0x8000 )
  TEST_FCLASS_H( 6, 1 << 4, 0x0000 )
  TEST_FCLASS_H( 7, 1 << 5, 0x03ff )
  TEST_FCLASS_H( 8, 1 << 6, 0x3c00 )
  TEST_FCLASS_H( 9, 1 << 7, 0x7c00 )
  TEST_FCLASS_H(10, 1 << 8, 0x7c01 )
  TEST_FCLASS_H(11, 1 << 9, 0x7e00 )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fcmp.S
#-----------------------------------------------------------------------------
#
# Test f{eq|lt|le}.h instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_CMP_OP_H( 2, feq.h, 0x00, 1, -1.36, -1.36)
  TEST_FP_CMP_OP_H( 3, fle.h, 0x00, 1, -1.36, -1.36)
  TEST_FP_CMP_OP_H( 4, flt.h, 0x00, 0, -1.36, -1.36)

  TEST_FP_CMP_OP_H( 5, feq.h, 0x00, 0, -1.37, -1.36)
  TEST_FP_CMP_OP_H( 6, fle.h, 0x00, 1, -1.37, -1.36)
  TEST_FP_CMP_OP_H( 7, flt.h, 0x00, 1, -1.37, -1.36)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fadd.S
#-----------------------------------------------------------------------------
#
# Test f{add|sub|mul}.h instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP2_H( 2,  fadd.h, 0,                3.5,        2.5,        1.0 );
  TEST_FP_OP2_H( 3,  fadd.h, 1,              -1234,    -1235.1,        1.1 );
  TEST_FP_OP2_H( 4,  fadd.h, 1,                3.14,       3.13,      0.01 );

  TEST_FP_OP2_H( 5,  fsub.h, 0,                1.5,        2.5,        1.0 );
  TEST_FP_OP2_H( 6,  fsub.h, 1,              -1234,    -1235.1,       -1.1 );
  TEST_FP_OP2_H( 7,  fsub.h, 1,              3.14,        3.15,       0.01 );

  TEST_FP_OP2_H( 8,  fmul.h, 0,                2.5,        2.5,        1.0 );
  TEST_FP_OP2_H( 9,  fmul.h, 0,             1235.1,    -1235.1,       -1.0 );
  TEST_FP_OP2_H(10,  fmul.h, 1,                 1.1,      11.0,        0.1 );

  # Is the canonical NaN generated for Inf - Inf?
  TEST_FP_OP2_H_HEX(11,  fsub.h, 0x10, 0x7e00, 0x7c00, 0x7c00);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# move.S
#-----------------------------------------------------------------------------
#
# This test verifies that the fmv.h.x, fmv.x.h, and fsgnj[x|n].d instructions
# and the fcsr work properly.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  TEST_CASE(2, a1, 1, csrwi fcsr, 1; li a0, 0x1234; fssr a1, a0)
  TEST_CASE(3, a0, 0x34, frsr a0)
  TEST_CASE(4, a0, 0x14, frflags a0)
  TEST_CASE(5, a0, 0x01, csrrwi a0, frm, 2)
  TEST_CASE(6, a0, 0x54, frsr a0)
  TEST_CASE(7, a0, 0x14, csrrci a0, fflags, 4)
  TEST_CASE(8, a0, 0x50, frsr a0)

#define TEST_FSGNJS(n, insn, new_sign, rs1_sign, rs2_sign) \
  TEST_CASE(n, a0, 0x1234 | (-(new_sign) << 15), \
    li a1, ((rs1_sign) << 15) | 0x1234; \
    li a2, -(rs2_sign); \
    fmv.h.x f1, a1; \
    fmv.h.x f2, a2; \
    insn f0, f1, f2; \
    fmv.x.h a0, f0)

  TEST_FSGNJS(10, fsgnj.h, 0, 0, 0)
  TEST_FSGNJS(11, fsgnj.h, 1, 0, 1)
  TEST_FSGNJS(12, fsgnj.h, 0, 1, 0)
  TEST_FSGNJS(13, fsgnj.h, 1, 1, 1)

  TEST_FSGNJS(20, fsgnjn.h, 1, 0, 0)
  TEST_FSGNJS(21, fsgnjn.h, 0, 0, 1)
  TEST_FSGNJS(22, fsgnjn.h, 1, 1, 0)
  TEST_FSGNJS(23, fsgnjn.h, 0, 1, 1)

  TEST_FSGNJS(30, fsgnjx.h, 0, 0, 0)
  TEST_FSGNJS(31, fsgnjx.h, 1, 0, 1)
  TEST_FSGNJS(32, fsgnjx.h, 1, 1, 0)
  TEST_FSGNJS(33, fsgnjx.h, 0, 1, 1)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.
#*****************************************************************************
# fcvt_w.S
#-----------------------------------------------------------------------------
#
# Test fcvt{wu|w|lu|l}.h instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_INT_OP_H( 2,  fcvt.w.h, 0x01,         -1,    -1.1, rtz);
  TEST_FP_INT_OP_H( 3,  fcvt.w.h, 0x00,         -1,    -1.0, rtz);
  TEST_FP_INT_OP_H( 4,  fcvt.w.h, 0x01,          0,    -0.9, rtz);
  TEST_FP_INT_OP_H( 5,  fcvt.w.h, 0x01,          0,     0.9, rtz);
  TEST_FP_INT_OP_H( 6,  fcvt.w.h, 0x00,          1,     1.0, rtz);
  TEST_FP_INT_OP_H( 7,  fcvt.w.h, 0x01,          1,     1.1, rtz);
  TEST_FP_INT_OP_H( 8,  fcvt.w.h, 0x00,      -2054, 0h:e803, rtz);
  TEST_FP_INT_OP_H( 9,  fcvt.w.h, 0x00,       2054, 0h:6803, rtz);

  TEST_FP_INT_OP_H(12, fcvt.wu.h, 0x10,          0,    -3.0, rtz);
  TEST_FP_INT_OP_H(13, fcvt.wu.h, 0x10,          0,    -1.0, rtz);
  TEST_FP_INT_OP_H(14, fcvt.wu.h, 0x01,          0,    -0.9, rtz);
  TEST_FP_INT_OP_H(15, fcvt.wu.h, 0x01,          0,     0.9, rtz);
  TEST_FP_INT_OP_H(16, fcvt.wu.h, 0x00,          1,     1.0, rtz);
  TEST_FP_INT_OP_H(17, fcvt.wu.h, 0x01,          1,     1.1, rtz);
  TEST_FP_INT_OP_H(18, fcvt.wu.h, 0x10,          0, 0h:e803, rtz);
  TEST_FP_INT_OP_H(19, fcvt.wu.h, 0x00,       2054, 0h:6803, rtz);

#if __riscv_xlen >= 64
  TEST_FP_INT_OP_H(22,  fcvt.l.h, 0x01,         -1,    -1.1, rtz);
  TEST_FP_INT_OP_H(23,  fcvt.l.h, 0x00,         -1,    -1.0, rtz);
  TEST_FP_INT_OP_H(24,  fcvt.l.h, 0x01,          0,    -0.9, rtz);
  TEST_FP_INT_OP_H(25,  fcvt.l.h, 0x01,          0,     0.9, rtz);
  TEST_FP_INT_OP_H(26,  fcvt.l.h, 0x00,          1,     1.0, rtz);
  TEST_FP_INT_OP_H(27,  fcvt.l.h, 0x01,          1,     1.1, rtz);

  TEST_FP_INT_OP_H(32, fcvt.lu.h, 0x10,          0,    -3.0, rtz);
  TEST_FP_INT_OP_H(33, fcvt.lu.h, 0x10,          0,    -1.0, rtz);
  TEST_FP_INT_OP_H(34, fcvt.lu.h, 0x01,          0,    -0.9, rtz);
  TEST_FP_INT_OP_H(35, fcvt.lu.h, 0x01,          0,     0.9, rtz);
  TEST_FP_INT_OP_H(36, fcvt.lu.h, 0x00,          1,     1.0, rtz);
  TEST_FP_INT_OP_H(37, fcvt.lu.h, 0x01,          1,     1.1, rtz);
  TEST_FP_INT_OP_H(38, fcvt.lu.h, 0x10,          0, 0h:e483, rtz);
#endif

  # test negative NaN, negative infinity conversion
  TEST_CASE( 42, x1, 0x000000007fffffff, la x1, tdat  ; flw f1,  0(x1); fcvt.w.h x1, f1)
  TEST_CASE( 43, x1, 0xffffffff80000000, la x1, tdat  ; flw f1,  8(x1); fcvt.w.h x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE( 44, x1, 0x7fffffffffffffff, la x1, tdat  ; flw f1,  0(x1); fcvt.l.h x1, f1)
  TEST_CASE( 45, x1, 0x8000000000000000, la x1, tdat  ; flw f1,  8(x1); fcvt.l.h x1, f1)
#endif

  # test positive NaN, positive infinity conversion
  TEST_CASE( 52, x1, 0x000000007fffffff, la x1, tdat  ; flw f1,  4(x1); fcvt.w.h x1, f1)
  TEST_CASE( 53, x1, 0x000000007fffffff, la x1, tdat  ; flw f1, 12(x1); fcvt.w.h x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE( 54, x1, 0x7fffffffffffffff, la x1, tdat  ; flw f1,  4(x1); fcvt.l.h x1, f1)
  TEST_CASE( 55, x1, 0x7fffffffffffffff, la x1, tdat  ; flw f1, 12(x1); fcvt.l.h x1, f1)
#endif

  # test NaN, infinity conversions to unsigned integer
  TEST_CASE( 62, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1,  0(x1); fcvt.wu.h x1, f1)
  TEST_CASE( 63, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1,  4(x1); fcvt.wu.h x1, f1)
  TEST_CASE( 64, x1,                  0, la x1, tdat  ; flw f1,  8(x1); fcvt.wu.h x1, f1)
  TEST_CASE( 65, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1, 12(x1); fcvt.wu.h x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE( 66, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1,  0(x1); fcvt.lu.h x1, f1)
  TEST_CASE( 67, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1,  4(x1); fcvt.lu.h x1, f1)
  TEST_CASE( 68, x1,                  0, la x1, tdat  ; flw f1,  8(x1); fcvt.lu.h x1, f1)
  TEST_CASE( 69, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1, 12(x1); fcvt.lu.h x1, f1)
#endif
   
  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

# -NaN, NaN, -inf, +inf
#tdat:
#.word 0xffffffff
#.word 0x7fffffff
#.word 0xff800000
#.word 0x7f800000

tdat:
.word 0xffffffff
.word 0xffff7fff
.word 0xfffffc00
.word 0xffff7c00

RVTEST_DATA_END
#*****************************************************************************
#-----------------------------------------------------------------------------
#
# Test CBO.ZERO instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  la  x1, tdat
  .word 0x0040A00F  # cbo.zero(x1)
  TEST_LD_OP( 1, ld, 0, 0,  tdat )
  TEST_LD_OP( 2, ld, 0, 8,  tdat )
  TEST_LD_OP( 3, ld, 0, 16, tdat )
  TEST_LD_OP( 4, ld, 0, 24, tdat )
  TEST_LD_OP( 5, ld, 0, 32, tdat )
  TEST_LD_OP( 6, ld, 0, 40, tdat )
  TEST_LD_OP( 7, ld, 0, 48, tdat )
  TEST_LD_OP( 8, ld, 0, 56, tdat )

  j pass

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:  .dword 0xdeadbeefdeadbeef

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# csr.S
#-----------------------------------------------------------------------------
#
# Test CSRRx and CSRRxI instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64S
RVTEST_CODE_BEGIN

#ifdef __MACHINE_MODE
  #define sscratch mscratch
  #define sstatus mstatus
  #define scause mcause
  #define sepc mepc
  #define sret mret
  #define stvec_handler mtvec_handler
  #undef SSTATUS_SPP
  #define SSTATUS_SPP MSTATUS_MPP
#endif

  # For RV64, make sure UXL encodes RV64.  (UXL does not exist for RV32.)
#if __riscv_xlen == 64
  # If running in M mode, use mstatus.MPP to check existence of U mode.
  # Otherwise, if in S mode, then U mode must exist and we don't need to check.
#ifdef __MACHINE_MODE
  li t0, MSTATUS_MPP
  csrc mstatus, t0
  csrr t1, mstatus
  and t0, t0, t1
  bnez t0, 1f
#endif
  # If U mode is present, UXL should be 2 (XLEN = 64-bit)
  TEST_CASE(18, a0, SSTATUS_UXL & (SSTATUS_UXL << 1), csrr a0, sstatus; li a1, SSTATUS_UXL; and a0, a0, a1)
#ifdef __MACHINE_MODE
  j 2f
1:
  # If U mode is not present, UXL should be 0
  TEST_CASE(19, a0, 0, csrr a0, sstatus; li a1, SSTATUS_UXL; and a0, a0, a1)
2:
#endif
#endif

  TEST_CASE(20, a0,         0, csrw sscratch, zero; csrr a0, sscratch);
  TEST_CASE(21, a0,         0, csrrwi a0, sscratch, 0; csrrwi a0, sscratch, 0xF);
  TEST_CASE(22, a0,      0x1f, csrrsi x0, sscratch, 0x10; csrr a0, sscratch);

  csrwi sscratch, 3
  TEST_CASE( 2, a0,         3, csrr a0, sscratch);
  TEST_CASE( 3, a1,         3, csrrci a1, sscratch, 1);
  TEST_CASE( 4, a2,         2, csrrsi a2, sscratch, 4);
  TEST_CASE( 5, a3,         6, csrrwi a3, sscratch, 2);
  TEST_CASE( 6, a1,         2, li a0, 0xbad1dea; csrrw a1, sscratch, a0);
  TEST_CASE( 7, a1, 0xbad1dea, li a0, 0x0001dea; csrrc a1, sscratch, a0);
  TEST_CASE( 8, a1, 0xbad0000, li a0, 0x000beef; csrrs a1, sscratch, a0);
  TEST_CASE( 9, a0, 0xbadbeef, li a0, 0xbad1dea; csrrw a0, sscratch, a0);
  TEST_CASE(10, a0, 0xbad1dea, li a0, 0x0001dea; csrrc a0, sscratch, a0);
  TEST_CASE(11, a0, 0xbad0000, li a0, 0x000beef; csrrs a0, sscratch, a0);
  TEST_CASE(12, a0, 0xbadbeef, csrr a0, sscratch);

#ifdef __MACHINE_MODE
  # Is F extension present?
  csrr a0, misa
  andi a0, a0, (1 << ('F' - 'A'))
  beqz a0, 1f
  # If so, make sure FP stores have no effect when mstatus.FS is off.
  li a1, MSTATUS_FS
  csrs mstatus, a1
#ifdef __riscv_flen
  fmv.s.x f0, x0
  csrc mstatus, a1
  la a1, fsw_data
  TEST_CASE(13, a0, 1, fsw f0, (a1); lw a0, (a1));
#else
  # Fail if this test is compiled without F but executed on a core with F.
  TEST_CASE(13, zero, 1)
#endif
1:

  # Figure out if 'U' is set in misa
  csrr a0, misa   # a0 = csr(misa)
  srli a0, a0, 20 # a0 = a0 >> 20
  andi a0, a0, 1  # a0 = a0 & 1
  beqz a0, finish # if no user mode, skip the rest of these checks

  # Enable access to the cycle counter
  csrwi mcounteren, 1

  # Figure out if 'S' is set in misa
  csrr a0, misa   # a0 = csr(misa)
  srli a0, a0, 18 # a0 = a0 >> 20
  andi a0, a0, 1  # a0 = a0 & 1
  beqz a0, 1f

  # Enable access to the cycle counter
  csrwi scounteren, 1
1:
#endif /* __MACHINE_MODE */

  # jump to user land
  li t0, SSTATUS_SPP
  csrc sstatus, t0
  la t0, 1f
  csrw sepc, t0
  sret
  1:

  # Make sure writing the cycle counter causes an exception.
  # Don't run in supervisor, as we don't delegate illegal instruction traps.
#ifdef __MACHINE_MODE
  TEST_CASE(14, a0, 255, li a0, 255; csrrw a0, cycle, x0);
#endif

  # Make sure reading status in user mode causes an exception.
  # Don't run in supervisor, as we don't delegate illegal instruction traps.
#ifdef __MACHINE_MODE
  TEST_CASE(15, a0, 255, li a0, 255; csrr a0, sstatus)
#else
  TEST_CASE(15, x0, 0, nop)
#endif

finish:
  RVTEST_PASS

  # We should only fall through to this if scall failed.
  TEST_PASSFAIL

  .align 2
  .global stvec_handler
stvec_handler:
  # Trapping on tests 13-15 is good news.
  li t0, 13
  bltu TESTNUM, t0, 1f
  li t0, 15
  bleu TESTNUM, t0, privileged
1:

  # catch RVTEST_PASS and kick it up to M-mode
  csrr t0, scause
  li t1, CAUSE_USER_ECALL
  bne t0, t1, fail
  RVTEST_PASS

privileged:
  # Make sure scause indicates a lack of privilege.
  csrr t0, scause
  li t1, CAUSE_ILLEGAL_INSTRUCTION
  bne t0, t1, fail
  # Return to user mode, but skip the trapping instruction.
  csrr t0, sepc
  addi t0, t0, 4
  csrw sepc, t0
  sret

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

fsw_data: .word 1

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# scall.S
#-----------------------------------------------------------------------------
#
# Test syscall trap.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64S
RVTEST_CODE_BEGIN

#ifdef __MACHINE_MODE
  #define sscratch mscratch
  #define sstatus mstatus
  #define scause mcause
  #define stvec mtvec
  #define sepc mepc
  #define sret mret
  #define stvec_handler mtvec_handler
  #undef SSTATUS_SPP
  #define SSTATUS_SPP MSTATUS_MPP
#endif

  li TESTNUM, 2

  # This is the expected trap code.
  li t1, CAUSE_USER_ECALL

#ifdef __MACHINE_MODE
  # If running in M mode, use mstatus.MPP to check existence of U mode.
  # Otherwise, if in S mode, then U mode must exist and we don't need to check.
  li t0, MSTATUS_MPP
  csrc mstatus, t0
  csrr t2, mstatus
  and t0, t0, t2
  beqz t0, 1f

  # If U mode doesn't exist, mcause should indicate ECALL from M mode.
  li t1, CAUSE_MACHINE_ECALL
#endif

1:
  li t0, SSTATUS_SPP
  csrc sstatus, t0
  la t0, 1f
  csrw sepc, t0
  sret
1:

  li TESTNUM, 1
do_scall:
  scall
  j fail

  TEST_PASSFAIL

# Depending on the test environment, the M-mode version of this test might
# not actually invoke the following handler.  Instead, the usual ECALL
# handler in the test environment might detect the CAUSE_USER_ECALL or
# CAUSE_MACHINE_ECALL exception and mark the test as having passed.
# Either way, we'll get the coverage we desire: such a handler must check
# both mcause and TESTNUM, just like the following handler.
  .align 2
  .global stvec_handler
stvec_handler:
  csrr t0, scause
  # Check if CLIC mode
  csrr t2, stvec
  andi t2, t2, 2
  # Skip masking if non-CLIC mode
  beqz t2, skip_mask 
  andi t0, t0, 255
skip_mask:
  bne t0, t1, fail
  la t2, do_scall
  csrr t0, sepc
  bne t0, t2, fail
  j pass

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# scall.S
#-----------------------------------------------------------------------------
#
# Test syscall trap.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64S
RVTEST_CODE_BEGIN

#ifdef __MACHINE_MODE
  #define sscratch mscratch
  #define sstatus mstatus
  #define scause mcause
  #define stvec mtvec
  #define sepc mepc
  #define sret mret
  #define stvec_handler mtvec_handler
#endif

  li TESTNUM, 2

do_break:
  sbreak
  j fail

  TEST_PASSFAIL

  .align 2
  .global stvec_handler
stvec_handler:
  li t1, CAUSE_BREAKPOINT
  csrr t0, scause
  # Check if CLIC mode
  csrr t2, stvec
  andi t2, t2, 2
  # Skip masking if non-CLIC mode
  beqz t2, skip_mask 
  andi t0, t0, 255
skip_mask:
  bne t0, t1, fail
  la t1, do_break
  csrr t0, sepc
  bne t0, t1, fail
  j pass

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# icache-alias.S
#-----------------------------------------------------------------------------
#
# Test that instruction memory appears to be physically addressed, i.e.,
# that disagreements in the low-order VPN and PPN bits don't cause the
# wrong instruction to be fetched.  It also tests that changing a page
# mapping takes effect without executing FENCE.I.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  li TESTNUM, 2

  # Set up intermediate page tables

  la t0, page_table_3
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V
  sd t0, page_table_2, t1

  la t0, page_table_2
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V
  sd t0, page_table_1, t1

  # Set up leaf mappings where va[12] != pa[12]

  la t0, code_page_1
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V | PTE_X | PTE_A
  sd t0, page_table_3 + 8, t1

  la t0, code_page_2
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V | PTE_X | PTE_A
  sd t0, page_table_3 + 0, t1

  # Turn on VM

  li a0, (SATP_MODE & ~(SATP_MODE<<1)) * SATP_MODE_SV39
  la a1, page_table_1
  srl a1, a1, RISCV_PGSHIFT
  or a1, a1, a0
  csrw satp, a1
  sfence.vma

  # Enter supervisor mode and make sure correct page is accessed

  la a2, 1f
  csrwi mepc, 0
  li a1, ((MSTATUS_MPP & ~(MSTATUS_MPP<<1)) * PRV_S)
  csrs mstatus, a1
  mret

1:
  li TESTNUM, 2
  addi a0, a0, -321
  bnez a0, fail

  li TESTNUM, 3
  la a2, 1f
  li t0, RISCV_PGSIZE
  csrw mepc, t0
  mret

1:
  addi a0, a0, -123
  bnez a0, fail

  li TESTNUM, 4
  la a2, 1f
  csrwi mepc, 0
  mret

  .align 2
1:
  addi a0, a0, -321
  bnez a0, fail

  li TESTNUM, 5

  # Change mapping and try again

  la t0, code_page_1
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V | PTE_X | PTE_A
  sd t0, page_table_3 + 0, t1
  sfence.vma

  la a2, 1f
  csrwi mepc, 0
  mret

  .align 2
1:
  addi a0, a0, -123
  bnez a0, fail
  
  RVTEST_PASS

  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  csrr t0, mcause
  add t0, t0, -CAUSE_STORE_PAGE_FAULT
  bnez t0, fail

  jr a2

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

.align 12
page_table_1: .dword 0
.align 12
page_table_2: .dword 0
.align 12
page_table_3: .dword 0
.align 13
code_page_1:
  li a0, 123
  sw x0, (x0)
.align 12
code_page_2:
  li a0, 321
  sw x0, (x0)

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ma_fetch.S
#-----------------------------------------------------------------------------
#
# Test misaligned fetch trap.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64S
RVTEST_CODE_BEGIN

#ifdef __MACHINE_MODE
  #define sscratch mscratch
  #define sstatus mstatus
  #define scause mcause
  #define stval mtval
  #define sepc mepc
  #define sret mret
  #define stvec_handler mtvec_handler
#endif

  .align 2
  .option norvc

  # Without RVC, the jalr should trap, and the handler will skip ahead.
  # With RVC, the jalr should not trap, and "j fail" should get skipped.
  li TESTNUM, 2
  li t1, 0
  la t0, 1f
  jalr t1, t0, 2
1:
  .option rvc
  c.j 1f
  c.j 2f
  .option norvc
1:
  j fail
2:

  // This test should pass, since JALR ignores the target LSB
  li TESTNUM, 3
  la t0, 1f
  jalr t1, t0, 1
1:
  j 1f
  j fail
1:

  li TESTNUM, 4
  li t1, 0
  la t0, 1f
  jalr t1, t0, 3
1:
  .option rvc
  c.j 1f
  c.j 2f
  .option norvc
1:
  j fail
2:

  # Like test 2, but with jal instead of jalr.
  li TESTNUM, 5
  li t1, 0
  la t0, 1f
  jal t1, 2f
1:
  .option rvc
  c.j 1f
2:
  c.j 2f
  .option norvc
1:
  j fail
2:

  # Like test 2, but with a taken branch instead of jalr.
  li TESTNUM, 6
  li t1, 0
  la t0, 1f
  beqz x0, 2f
1:
  .option rvc
  c.j 1f
2:
  c.j 2f
  .option norvc
1:
  j fail
2:

  # Not-taken branches should not trap, even without RVC.
  li TESTNUM, 7
  bnez x0, 1f
  j 2f
  .option rvc
  c.j 1f
1:
  c.j 1f
  .option norvc
1:
  j fail
2:

#ifdef __MACHINE_MODE
  # Skip if C cannot be enabled
  csrsi misa, 1 << ('c' - 'a')
  csrr t2, misa
  andi t2, t2, 1 << ('c' - 'a')
  beqz t2, pass

  # Skip if C cannot be disabled
  csrci misa, 1 << ('c' - 'a')
  csrr t2, misa
  andi t2, t2, 1 << ('c' - 'a')
  bnez t2, pass

  # Skip if clearing misa.C does not set IALIGN=32
  csrr t0, mtvec
  la t1, 1f
  addi t1, t1, 2
  csrw mtvec, t1
  j 1f

  .option rvc
  c.nop
1:
  j pass
  .option norvc
2:
  csrw mtvec, t0
  csrsi misa, 1 << ('c' - 'a')

  # IALIGN=32 cannot be set if doing so would cause a misaligned instruction
  # exception on the next instruction fetch. (This test assumes no other
  # extensions that support misalignment are present.)
  li TESTNUM, 8
  csrr t2, misa
  andi t2, t2, 1 << ('c' - 'a')
  beqz t2, pass

  .option rvc
  c.nop
  csrci misa, 1 << ('c' - 'a')
1:
  c.nop
  .option norvc

  csrr t2, misa
  andi t2, t2, 1 << ('c' - 'a')
  beqz t2, fail

  # IALIGN=32, mret to a misaligned mepc should succeed,
  # masking off mepc[1].
  la t0, 1f
  addi t0, t0, -2
  csrw mepc, t0

  csrci misa, 1 << ('c' - 'a')
  li t2, MSTATUS_MPP
  csrs mstatus, t2
  mret

  # mret should transfer control to this branch.  Otherwise, it will
  # transfer control two bytes into the branch, which happens to be the
  # illegal instruction c.unimp.
  beqz x0, 1f
1:
  csrsi misa, 1 << ('c' - 'a')
#endif

  j pass

  TEST_PASSFAIL

  .align 2
  .global stvec_handler
stvec_handler:
  # tests 2, 4, 5, 6, and 8 should trap
  li a0, 2
  beq TESTNUM, a0, 1f
  li a0, 4
  beq TESTNUM, a0, 1f
  li a0, 5
  beq TESTNUM, a0, 1f
  li a0, 6
  beq TESTNUM, a0, 1f
  j fail
1:

  # verify that return address was not written
  bnez t1, fail

  # verify trap cause
  li a1, CAUSE_MISALIGNED_FETCH
  csrr a0, scause
  bne a0, a1, fail

  # verify that epc == &jalr (== t0 - 4)
  csrr a1, sepc
  addi a1, a1, 4
  bne t0, a1, fail

  # verify that tval == 0 or tval == t0+2.
  csrr a0, stval
  beqz a0, 1f
  addi a0, a0, -2
  bne a0, t0, fail
1:

  addi a1, a1, 8
  csrw sepc, a1
  sret

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# dirty.S
#-----------------------------------------------------------------------------
#
# Test VM referenced and dirty bits.
#

#include "riscv_test.h"
#include "test_macros.h"

#if (DRAM_BASE >> 30 << 30) != DRAM_BASE
# error This test requires DRAM_BASE be SV39 superpage-aligned
#endif 

RVTEST_RV64M
RVTEST_CODE_BEGIN

  # Turn on VM
  li a0, (SATP_MODE & ~(SATP_MODE<<1)) * SATP_MODE_SV39
  la a1, page_table_1
  srl a1, a1, RISCV_PGSHIFT
  or a1, a1, a0
  csrw satp, a1
  sfence.vma

  # Set up MPRV with MPP=S, so loads and stores use S-mode
  li a1, ((MSTATUS_MPP & ~(MSTATUS_MPP<<1)) * PRV_S) | MSTATUS_MPRV
  csrs mstatus, a1

  # Try a faulting store to make sure dirty bit is not set
  li TESTNUM, 2
  li t2, 1
  sw t2, dummy - DRAM_BASE, a0

  # Set SUM=1 so user memory access is permitted
  li TESTNUM, 3
  li a1, ((MSTATUS_MPP & ~(MSTATUS_MPP<<1)) * PRV_S) | MSTATUS_SUM
  csrs mstatus, a1

  # Make sure SUM=1 works
  lw t0, dummy - DRAM_BASE
  bnez t0, die

  # Try a non-faulting store to make sure dirty bit is set
  sw t2, dummy - DRAM_BASE, a0

  # Make sure it succeeded
  lw t0, dummy - DRAM_BASE
  bne t0, t2, die

  # Leave MPRV
  li t0, MSTATUS_MPRV
  csrc mstatus, t0

  # Make sure D bit is set
  lw t0, page_table_1
  li a0, PTE_A | PTE_D
  and t0, t0, a0
  bne t0, a0, die

  # Enter MPRV again
  li t0, MSTATUS_MPRV
  csrs mstatus, t0

  # Make sure that superpage entries trap when PPN LSBs are set.
  li TESTNUM, 4
  lw a0, page_table_1 - DRAM_BASE
  or a0, a0, 1 << PTE_PPN_SHIFT
  sw a0, page_table_1 - DRAM_BASE, t0
  sfence.vma
  sw a0, page_table_1 - DRAM_BASE, t0
  j die
  
  RVTEST_PASS

  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  csrr t0, mcause
  add t0, t0, -CAUSE_STORE_PAGE_FAULT
  bnez t0, die

  li t1, 2
  bne TESTNUM, t1, 1f
  # Make sure D bit is clear
  lw t0, page_table_1
  and t1, t0, PTE_D
  bnez t1, die
skip:
  csrr t0, mepc
  add t0, t0, 4
  csrw mepc, t0
  mret

1:
  li t1, 3
  bne TESTNUM, t1, 1f
  # The implementation doesn't appear to set D bits in HW.
  # Make sure the D bit really is clear.
  lw t0, page_table_1
  and t1, t0, PTE_D
  bnez t1, die
  # Set the D bit.
  or t0, t0, PTE_D
  sw t0, page_table_1, t1
  sfence.vma
  mret

1:
  li t1, 4
  bne TESTNUM, t1, 1f
  j pass

1:
die:
  RVTEST_FAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

.align 12
page_table_1: .dword (DRAM_BASE/RISCV_PGSIZE << PTE_PPN_SHIFT) | PTE_V | PTE_U | PTE_R | PTE_W | PTE_X | PTE_A
dummy: .dword 0

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# wfi.S
#-----------------------------------------------------------------------------
#
# Test wait-for-interrupt instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64S
RVTEST_CODE_BEGIN

  # Make sure wfi doesn't halt the hart, even if interrupts are disabled
  csrc sstatus, SSTATUS_SIE
  csrs sie, SIP_SSIP
  csrs sip, SIP_SSIP
  wfi

  RVTEST_PASS

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fcvt.S
#-----------------------------------------------------------------------------
#
# Test fcvt.d.{wu|w|lu|l}, fcvt.s.d, and fcvt.d.s instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

#if __riscv_xlen == 32
    # Replace the function with the 32-bit variant defined in test_macros.h
    #undef TEST_INT_FP_OP_D
    #define TEST_INT_FP_OP_D TEST_INT_FP_OP_D32

    #undef TEST_FCVT_S_D
    #define TEST_FCVT_S_D TEST_FCVT_S_D32
#endif

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_INT_FP_OP_D(2,  fcvt.d.w,                   2.0,  2);
  TEST_INT_FP_OP_D(3,  fcvt.d.w,                  -2.0, -2);

  TEST_INT_FP_OP_D(4, fcvt.d.wu,                   2.0,  2);
  TEST_INT_FP_OP_D(5, fcvt.d.wu,            4294967294, -2);

#if __riscv_xlen >= 64
  TEST_INT_FP_OP_D(6,  fcvt.d.l,                   2.0,  2);
  TEST_INT_FP_OP_D(7,  fcvt.d.l,                  -2.0, -2);

  TEST_INT_FP_OP_D(8, fcvt.d.lu,                   2.0,  2);
  TEST_INT_FP_OP_D(9, fcvt.d.lu, 1.8446744073709552e19, -2);
#endif

  TEST_FCVT_S_D(10, -1.5, -1.5)
  TEST_FCVT_D_S(11, -1.5, -1.5)

#if __riscv_xlen >= 64
  TEST_CASE(12, a0, 0x7ff8000000000000,
    la a1, test_data_22;
    ld a2, 0(a1);
    fmv.d.x f2, a2;
    fcvt.s.d f2, f2;
    fcvt.d.s f2, f2;
    fmv.x.d a0, f2;
  )
#else
  TEST_CASE_D32(12, a0, a1, 0x7ff8000000000000,
    la a1, test_data_22;
    fld f2, 0(a1);
    fcvt.s.d f2, f2;
    fcvt.d.s f2, f2;
    fsd f2, 0(a1);
    lw a0, 0(a1);
    lw a1, 4(a1)
  )
#endif

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

test_data_22:
  .dword 0x7ffcffffffff8004

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fdiv.S
#-----------------------------------------------------------------------------
#
# Test f{div|sqrt}.d instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

#if __riscv_xlen == 32
    # Replace the functions with the 32-bit variants defined in test_macros.h
    #undef TEST_FP_OP2_D
    #define TEST_FP_OP2_D TEST_FP_OP2_D32

    #undef TEST_FP_OP1_D
    #define TEST_FP_OP1_D TEST_FP_OP1_D32

    #undef TEST_FP_OP1_D_DWORD_RESULT
    #define TEST_FP_OP1_D_DWORD_RESULT TEST_FP_OP1_D32_DWORD_RESULT
#endif

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP2_D( 2,  fdiv.d, 1, 1.1557273520668288, 3.14159265, 2.71828182 );
  TEST_FP_OP2_D( 3,  fdiv.d, 1,-0.9991093838555584,      -1234,     1235.1 );
  TEST_FP_OP2_D( 4,  fdiv.d, 0,         3.14159265, 3.14159265,        1.0 );

  TEST_FP_OP1_D( 5,  fsqrt.d, 1, 1.7724538498928541, 3.14159265 );
  TEST_FP_OP1_D( 6,  fsqrt.d, 0,                100,      10000 );

  TEST_FP_OP1_D_DWORD_RESULT(16,  fsqrt.d, 0x10,      0x7FF8000000000000,      -1.0 );

  TEST_FP_OP1_D( 7,  fsqrt.d, 1, 13.076696830622021, 171.0);

  TEST_FP_OP1_D( 8,  fsqrt.d, 1,0.00040099251863345283320230749702, 1.60795e-7);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fmadd.S
#-----------------------------------------------------------------------------
#
# Test f[n]m{add|sub}.s and f[n]m{add|sub}.d instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

#if __riscv_xlen == 32
    # Replace the function with the 32-bit variant defined in test_macros.h
    #undef TEST_FP_OP3_D
    #define TEST_FP_OP3_D TEST_FP_OP3_D32
#endif

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP3_D( 2,  fmadd.d, 0,                 3.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_D( 3,  fmadd.d, 1,  1236.1999999999999, -1.0,    -1235.1,        1.1 );
  TEST_FP_OP3_D( 4,  fmadd.d, 0,               -12.0,  2.0,       -5.0,       -2.0 );

  TEST_FP_OP3_D( 5, fnmadd.d, 0,                -3.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_D( 6, fnmadd.d, 1, -1236.1999999999999, -1.0,    -1235.1,        1.1 );
  TEST_FP_OP3_D( 7, fnmadd.d, 0,                12.0,  2.0,       -5.0,       -2.0 );

  TEST_FP_OP3_D( 8,  fmsub.d, 0,                 1.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_D( 9,  fmsub.d, 1,                1234, -1.0,    -1235.1,        1.1 );
  TEST_FP_OP3_D(10,  fmsub.d, 0,                -8.0,  2.0,       -5.0,       -2.0 );

  TEST_FP_OP3_D(11, fnmsub.d, 0,                -1.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_D(12, fnmsub.d, 1,               -1234, -1.0,    -1235.1,        1.1 );
  TEST_FP_OP3_D(13, fnmsub.d, 0,                 8.0,  2.0,       -5.0,       -2.0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ldst.S
#-----------------------------------------------------------------------------
#
# This test verifies that flw, fld, fsw, and fsd work properly.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  la s0, tdat
  TEST_CASE(2, a0, 0x40000000bf800000, fld f2, 0(s0); fsd f2, 16(s0); ld a0, 16(s0))
  TEST_CASE(3, a0, 0x40000000bf800000, fld f2, 0(s0); fsw f2, 16(s0); ld a0, 16(s0))
  TEST_CASE(4, a0, 0x40000000bf800000, flw f2, 0(s0); fsw f2, 16(s0); ld a0, 16(s0))
  TEST_CASE(5, a0, 0xc080000040400000, fld f2, 8(s0); fsd f2, 16(s0); ld a0, 16(s0))
  TEST_CASE(6, a0, 0xffffffff40400000, flw f2, 8(s0); fsd f2, 16(s0); ld a0, 16(s0))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
.word 0xbf800000
.word 0x40000000
.word 0x40400000
.word 0xc0800000
.word 0xdeadbeef
.word 0xcafebabe
.word 0xabad1dea
.word 0x1337d00d

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fmin.S
#-----------------------------------------------------------------------------
#
# Test f{min|max}.d instructinos.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

#if __riscv_xlen == 32
    # Replace the function with the 32-bit variant defined in test_macros.h
    #undef TEST_FP_OP2_D
    #define TEST_FP_OP2_D TEST_FP_OP2_D32
    #undef TEST_FP_OP2_D_HEX
    #define TEST_FP_OP2_D_HEX TEST_FP_OP2_D32_HEX
#endif

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP2_D( 2,  fmin.d, 0,        1.0,        2.5,        1.0 );
  TEST_FP_OP2_D( 3,  fmin.d, 0,    -1235.1,    -1235.1,        1.1 );
  TEST_FP_OP2_D( 4,  fmin.d, 0,    -1235.1,        1.1,    -1235.1 );
  TEST_FP_OP2_D( 5,  fmin.d, 0,    -1235.1,        NaN,    -1235.1 );
  TEST_FP_OP2_D( 6,  fmin.d, 0, 0.00000001, 3.14159265, 0.00000001 );
  TEST_FP_OP2_D( 7,  fmin.d, 0,       -2.0,       -1.0,       -2.0 );

  TEST_FP_OP2_D(12,  fmax.d, 0,        2.5,        2.5,        1.0 );
  TEST_FP_OP2_D(13,  fmax.d, 0,        1.1,    -1235.1,        1.1 );
  TEST_FP_OP2_D(14,  fmax.d, 0,        1.1,        1.1,    -1235.1 );
  TEST_FP_OP2_D(15,  fmax.d, 0,    -1235.1,        NaN,    -1235.1 );
  TEST_FP_OP2_D(16,  fmax.d, 0, 3.14159265, 3.14159265, 0.00000001 );
  TEST_FP_OP2_D(17,  fmax.d, 0,       -1.0,       -1.0,       -2.0 );

  # FMAX(sNaN, x) = x
  TEST_FP_OP2_D_HEX(20,  fmax.d, 0x10, 0x3ff0000000000000, 0x7ff0000000000001, 0x3ff0000000000000);
  # FMAX(qNaN, qNaN) = canonical NaN
  TEST_FP_OP2_D_HEX(21,  fmax.d, 0x00, 0x7ff8000000000000, 0x7fffffffffffffff, 0x7fffffffffffffff);

  # -0.0 < +0.0
  TEST_FP_OP2_D(30,  fmin.d, 0,       -0.0,       -0.0,        0.0 );
  TEST_FP_OP2_D(31,  fmin.d, 0,       -0.0,        0.0,       -0.0 );
  TEST_FP_OP2_D(32,  fmax.d, 0,        0.0,       -0.0,        0.0 );
  TEST_FP_OP2_D(33,  fmax.d, 0,        0.0,        0.0,       -0.0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# recoding.S
#-----------------------------------------------------------------------------
#
# Test corner cases of John Hauser's microarchitectural recoding scheme.
# There are twice as many recoded values as IEEE-754 values; some of these
# extras are redundant (e.g. Inf) and others are illegal (subnormals with
# too many bits set).
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  # Make sure infinities with different mantissas compare as equal.
  fld f0, minf, a0
  fld f1, three, a0
  fmul.d f1, f1, f0
  TEST_CASE( 2, a0, 1, feq.d a0, f0, f1)
  TEST_CASE( 3, a0, 1, fle.d a0, f0, f1)
  TEST_CASE( 4, a0, 0, flt.d a0, f0, f1)

  # Likewise, but for zeroes.
  fcvt.d.w f0, x0
  li a0, 1
  fcvt.d.w f1, a0
  fmul.d f1, f1, f0
  TEST_CASE(5, a0, 1, feq.d a0, f0, f1)
  TEST_CASE(6, a0, 1, fle.d a0, f0, f1)
  TEST_CASE(7, a0, 0, flt.d a0, f0, f1)

  # When converting small doubles to single-precision subnormals,
  # ensure that the extra precision is discarded.
  flw f0, big, a0
  fld f1, tiny, a0
  fcvt.s.d f1, f1
  fmul.s f0, f0, f1
  fmv.x.s a0, f0
  lw a1, small
  TEST_CASE(10, a0, 0, sub a0, a0, a1)

  # Make sure FSD+FLD correctly saves and restores a single-precision value.
  flw f0, three, a0
  fadd.s f1, f0, f0
  fadd.s f0, f0, f0
  fsd f0, tiny, a0
  fld f0, tiny, a0
  TEST_CASE(20, a0, 1, feq.s a0, f0, f1)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

minf: .double -Inf
three: .double 3.0
big: .float 1221
small: .float 2.9133121e-37
tiny: .double 2.3860049081905093e-40

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# structural.S
#-----------------------------------------------------------------------------
#
# This test verifies that the FPU correctly obviates structural hazards on its
# writeback port (e.g. fadd followed by fsgnj)
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

li x12, 1

li x2, 0x3FF0000000000000
li x1, 0x3F800000

#define TEST(testnum, nops)     \
test_ ## testnum: \
  li  TESTNUM, testnum; \
  fmv.d.x  f4, x0    ;\
  fmv.s.x  f3, x0    ;\
  fmv.d.x  f2, x2    ;\
  fmv.s.x  f1, x1    ;\
  j 1f ;\
  .align 5        ;\
1:fmul.d  f4, f2, f2  ;\
  nops          ;\
  fsgnj.s f3, f1, f1 ;\
  fmv.x.d  x4, f4    ;\
  fmv.x.s  x5, f3    ;\
  beq     x1, x5, 2f  ;\
  j fail;\
2:beq     x2, x4, 2f  ;\
  j fail; \
2:fmv.d.x  f2, zero    ;\
  fmv.s.x  f1, zero    ;\

TEST(1,;)
TEST(2,nop)
TEST(3,nop;nop)
TEST(4,nop;nop;nop)
TEST(5,nop;nop;nop;nop)
TEST(6,nop;nop;nop;nop;nop)
TEST(7,nop;nop;nop;nop;nop;nop)

TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fclass.S
#-----------------------------------------------------------------------------
#
# Test fclass.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

#if __riscv_xlen == 32
    # Replace the function with the 32-bit variant defined in test_macros.h
    #undef TEST_FCLASS_D
    #define TEST_FCLASS_D TEST_FCLASS_D32
#endif

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FCLASS_D( 2, 1 << 0, 0xfff0000000000000 )
  TEST_FCLASS_D( 3, 1 << 1, 0xbff0000000000000 )
  TEST_FCLASS_D( 4, 1 << 2, 0x800fffffffffffff )
  TEST_FCLASS_D( 5, 1 << 3, 0x8000000000000000 )
  TEST_FCLASS_D( 6, 1 << 4, 0x0000000000000000 )
  TEST_FCLASS_D( 7, 1 << 5, 0x000fffffffffffff )
  TEST_FCLASS_D( 8, 1 << 6, 0x3ff0000000000000 )
  TEST_FCLASS_D( 9, 1 << 7, 0x7ff0000000000000 )
  TEST_FCLASS_D(10, 1 << 8, 0x7ff0000000000001 )
  TEST_FCLASS_D(11, 1 << 9, 0x7ff8000000000000 )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fcmp.S
#-----------------------------------------------------------------------------
#
# Test f{eq|lt|le}.d instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

#if __riscv_xlen == 32
    # Replace the function with the 32-bit variant defined in test_macros.h
    #undef TEST_FP_CMP_OP_D
    #define TEST_FP_CMP_OP_D TEST_FP_CMP_OP_D32
    #undef TEST_FP_CMP_OP_D_HEX
    #define TEST_FP_CMP_OP_D_HEX TEST_FP_CMP_OP_D32_HEX
#endif

  TEST_FP_CMP_OP_D( 2, feq.d, 0x00, 1, -1.36, -1.36)
  TEST_FP_CMP_OP_D( 3, fle.d, 0x00, 1, -1.36, -1.36)
  TEST_FP_CMP_OP_D( 4, flt.d, 0x00, 0, -1.36, -1.36)

  TEST_FP_CMP_OP_D( 5, feq.d, 0x00, 0, -1.37, -1.36)
  TEST_FP_CMP_OP_D( 6, fle.d, 0x00, 1, -1.37, -1.36)
  TEST_FP_CMP_OP_D( 7, flt.d, 0x00, 1, -1.37, -1.36)

  # Only sNaN should signal invalid for feq.
  TEST_FP_CMP_OP_D( 8, feq.d, 0x00, 0, NaN, 0)
  TEST_FP_CMP_OP_D( 9, feq.d, 0x00, 0, NaN, NaN)
  TEST_FP_CMP_OP_D_HEX(10, feq.d, 0x10, 0, 0x7ff0000000000001, 0)

  # qNaN should signal invalid for fle/flt.
  TEST_FP_CMP_OP_D(11, flt.d, 0x10, 0, NaN, 0)
  TEST_FP_CMP_OP_D(12, flt.d, 0x10, 0, NaN, NaN)
  TEST_FP_CMP_OP_D_HEX(13, flt.d, 0x10, 0, 0x7ff0000000000001, 0)
  TEST_FP_CMP_OP_D(14, fle.d, 0x10, 0, NaN, 0)
  TEST_FP_CMP_OP_D(15, fle.d, 0x10, 0, NaN, NaN)
  TEST_FP_CMP_OP_D_HEX(16, fle.d, 0x10, 0, 0x7ff0000000000001, 0)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fadd.S
#-----------------------------------------------------------------------------
#
# Test f{add|sub|mul}.d instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

#if __riscv_xlen == 32
    # Replace the function with the 32-bit variant defined in test_macros.h
    #undef TEST_FP_OP2_D
    #define TEST_FP_OP2_D TEST_FP_OP2_D32
    #undef TEST_FP_OP2_D_HEX
    #define TEST_FP_OP2_D_HEX TEST_FP_OP2_D32_HEX
#endif

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP2_D( 2,  fadd.d, 0,                3.5,        2.5,        1.0 );
  TEST_FP_OP2_D( 3,  fadd.d, 1,              -1234,    -1235.1,        1.1 );
  TEST_FP_OP2_D( 4,  fadd.d, 1,         3.14159266, 3.14159265, 0.00000001 );

  TEST_FP_OP2_D( 5,  fsub.d, 0,                1.5,        2.5,        1.0 );
  TEST_FP_OP2_D( 6,  fsub.d, 1,              -1234,    -1235.1,       -1.1 );
  TEST_FP_OP2_D( 7,  fsub.d, 1, 3.1415926400000001, 3.14159265, 0.00000001 );

  TEST_FP_OP2_D( 8,  fmul.d, 0,                2.5,        2.5,        1.0 );
  TEST_FP_OP2_D( 9,  fmul.d, 1,            1358.61,    -1235.1,       -1.1 );
  TEST_FP_OP2_D(10,  fmul.d, 1,      3.14159265e-8, 3.14159265, 0.00000001 );

  # Is the canonical NaN generated for Inf - Inf?
  TEST_FP_OP2_D_HEX(11,  fsub.d, 0x10, 0x7ff8000000000000, 0x7ff0000000000000, 0x7ff0000000000000);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# move.S
#-----------------------------------------------------------------------------
#
# This test verifies that fmv.d.x, fmv.x.d, and fsgnj[x|n].d work properly.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

#TODO: make 32-bit compatible version
#define TEST_FSGNJD(n, insn, new_sign, rs1_sign, rs2_sign) \
  TEST_CASE(n, a0, 0x123456789abcdef0 | (-(new_sign) << 63), \
    li a1, ((rs1_sign) << 63) | 0x123456789abcdef0; \
    li a2, -(rs2_sign); \
    fmv.d.x f1, a1; \
    fmv.d.x f2, a2; \
    insn f0, f1, f2; \
    fmv.x.d a0, f0)

  TEST_FSGNJD(10, fsgnj.d, 0, 0, 0)
  TEST_FSGNJD(11, fsgnj.d, 1, 0, 1)
  TEST_FSGNJD(12, fsgnj.d, 0, 1, 0)
  TEST_FSGNJD(13, fsgnj.d, 1, 1, 1)

  TEST_FSGNJD(20, fsgnjn.d, 1, 0, 0)
  TEST_FSGNJD(21, fsgnjn.d, 0, 0, 1)
  TEST_FSGNJD(22, fsgnjn.d, 1, 1, 0)
  TEST_FSGNJD(23, fsgnjn.d, 0, 1, 1)

  TEST_FSGNJD(30, fsgnjx.d, 0, 0, 0)
  TEST_FSGNJD(31, fsgnjx.d, 1, 0, 1)
  TEST_FSGNJD(32, fsgnjx.d, 1, 1, 0)
  TEST_FSGNJD(33, fsgnjx.d, 0, 1, 1)

// Test fsgnj.s in conjunction with double-precision moves
#define TEST_FSGNJS(n, rd, rs1, rs2) \
  TEST_CASE(n, a0, (rd) | (-((rd) >> 31) << 32), \
    li a1, rs1; \
    li a2, rs2; \
    fmv.d.x f1, a1; \
    fmv.d.x f2, a2; \
    fsgnj.s f0, f1, f2; \
    fmv.x.s a0, f0); \
  TEST_CASE(1##n, a0, (rd) | 0xffffffff00000000, \
    li a1, rs1; \
    li a2, rs2; \
    fmv.d.x f1, a1; \
    fmv.d.x f2, a2; \
    fsgnj.s f0, f1, f2; \
    fmv.x.d a0, f0)

  TEST_FSGNJS(40, 0x7fc00000, 0x7ffffffe12345678, 0)
  TEST_FSGNJS(41, 0x7fc00000, 0xfffffffe12345678, 0)
  TEST_FSGNJS(42, 0x7fc00000, 0x7fffffff12345678, 0)
  TEST_FSGNJS(43, 0x12345678, 0xffffffff12345678, 0)

  TEST_FSGNJS(50, 0x7fc00000, 0x7ffffffe12345678, 0x80000000)
  TEST_FSGNJS(51, 0x7fc00000, 0xfffffffe12345678, 0x80000000)
  TEST_FSGNJS(52, 0x7fc00000, 0x7fffffff12345678, 0x80000000)
  TEST_FSGNJS(53, 0x12345678, 0xffffffff12345678, 0x80000000)

  TEST_FSGNJS(60, 0xffc00000, 0x7ffffffe12345678, 0xffffffff80000000)
  TEST_FSGNJS(61, 0xffc00000, 0xfffffffe12345678, 0xffffffff80000000)
  TEST_FSGNJS(62, 0x92345678, 0xffffffff12345678, 0xffffffff80000000)
  TEST_FSGNJS(63, 0x12345678, 0xffffffff12345678, 0x7fffffff80000000)

// Test fsgnj.d in conjunction with single-precision moves
#define TEST_FSGNJD_SP(n, isnan, rd, rs1, rs2) \
  TEST_CASE(n, a0, ((rd) & 0xffffffff) | (-(((rd) >> 31) & 1) << 32), \
    li a1, rs1; \
    li a2, rs2; \
    fmv.d.x f1, a1; \
    fmv.d.x f2, a2; \
    fsgnj.d f0, f1, f2; \
    feq.s a0, f0, f0; \
    addi a0, a0, -!(isnan); \
    bnez a0, 1f; \
    fmv.x.s a0, f0; \
    1:); \
  TEST_CASE(1##n, a0, rd, \
    li a1, rs1; \
    li a2, rs2; \
    fmv.d.x f1, a1; \
    fmv.d.x f2, a2; \
    fsgnj.d f0, f1, f2; \
    fmv.x.d a0, f0; \
    1:)

  TEST_FSGNJD_SP(70, 0, 0xffffffff11111111, 0xffffffff11111111, 0xffffffff11111111)
  TEST_FSGNJD_SP(71, 1, 0x7fffffff11111111, 0xffffffff11111111, 0x7fffffff11111111)
  TEST_FSGNJD_SP(72, 0, 0xffffffff11111111, 0xffffffff11111111, 0xffffffff91111111)
  TEST_FSGNJD_SP(73, 0, 0xffffffff11111111, 0xffffffff11111111, 0x8000000000000000)
  TEST_FSGNJD_SP(74, 0, 0xffffffff11111111, 0x7fffffff11111111, 0xffffffff11111111)
  TEST_FSGNJD_SP(75, 1, 0x7fffffff11111111, 0x7fffffff11111111, 0x7fffffff11111111)
  TEST_FSGNJD_SP(76, 0, 0xffffffff11111111, 0x7fffffff11111111, 0xffffffff91111111)
  TEST_FSGNJD_SP(77, 0, 0xffffffff11111111, 0x7fffffff11111111, 0x8000000000000000)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fcvt_w.S
#-----------------------------------------------------------------------------
#
# Test fcvt{wu|w|lu|l}.d instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_INT_OP_D( 2,  fcvt.w.d, 0x01,         -1, -1.1, rtz);
  TEST_FP_INT_OP_D( 3,  fcvt.w.d, 0x00,         -1, -1.0, rtz);
  TEST_FP_INT_OP_D( 4,  fcvt.w.d, 0x01,          0, -0.9, rtz);
  TEST_FP_INT_OP_D( 5,  fcvt.w.d, 0x01,          0,  0.9, rtz);
  TEST_FP_INT_OP_D( 6,  fcvt.w.d, 0x00,          1,  1.0, rtz);
  TEST_FP_INT_OP_D( 7,  fcvt.w.d, 0x01,          1,  1.1, rtz);
  TEST_FP_INT_OP_D( 8,  fcvt.w.d, 0x10,     -1<<31, -3e9, rtz);
  TEST_FP_INT_OP_D( 9,  fcvt.w.d, 0x10,  (1<<31)-1,  3e9, rtz);

  TEST_FP_INT_OP_D(12, fcvt.wu.d, 0x10,          0, -3.0, rtz);
  TEST_FP_INT_OP_D(13, fcvt.wu.d, 0x10,          0, -1.0, rtz);
  TEST_FP_INT_OP_D(14, fcvt.wu.d, 0x01,          0, -0.9, rtz);
  TEST_FP_INT_OP_D(15, fcvt.wu.d, 0x01,          0,  0.9, rtz);
  TEST_FP_INT_OP_D(16, fcvt.wu.d, 0x00,          1,  1.0, rtz);
  TEST_FP_INT_OP_D(17, fcvt.wu.d, 0x01,          1,  1.1, rtz);
  TEST_FP_INT_OP_D(18, fcvt.wu.d, 0x10,          0, -3e9, rtz);
  TEST_FP_INT_OP_D(19, fcvt.wu.d, 0x00, 0xffffffffb2d05e00, 3e9, rtz);

#if __riscv_xlen >= 64
  TEST_FP_INT_OP_D(22,  fcvt.l.d, 0x01,         -1, -1.1, rtz);
  TEST_FP_INT_OP_D(23,  fcvt.l.d, 0x00,         -1, -1.0, rtz);
  TEST_FP_INT_OP_D(24,  fcvt.l.d, 0x01,          0, -0.9, rtz);
  TEST_FP_INT_OP_D(25,  fcvt.l.d, 0x01,          0,  0.9, rtz);
  TEST_FP_INT_OP_D(26,  fcvt.l.d, 0x00,          1,  1.0, rtz);
  TEST_FP_INT_OP_D(27,  fcvt.l.d, 0x01,          1,  1.1, rtz);
  TEST_FP_INT_OP_D(28,  fcvt.l.d, 0x00,-3000000000, -3e9, rtz);
  TEST_FP_INT_OP_D(29,  fcvt.l.d, 0x00, 3000000000,  3e9, rtz);
  TEST_FP_INT_OP_D(20,  fcvt.l.d, 0x10,     -1<<63,-3e19, rtz);
  TEST_FP_INT_OP_D(21,  fcvt.l.d, 0x10,  (1<<63)-1, 3e19, rtz);

  TEST_FP_INT_OP_D(32, fcvt.lu.d, 0x10,          0, -3.0, rtz);
  TEST_FP_INT_OP_D(33, fcvt.lu.d, 0x10,          0, -1.0, rtz);
  TEST_FP_INT_OP_D(34, fcvt.lu.d, 0x01,          0, -0.9, rtz);
  TEST_FP_INT_OP_D(35, fcvt.lu.d, 0x01,          0,  0.9, rtz);
  TEST_FP_INT_OP_D(36, fcvt.lu.d, 0x00,          1,  1.0, rtz);
  TEST_FP_INT_OP_D(37, fcvt.lu.d, 0x01,          1,  1.1, rtz);
  TEST_FP_INT_OP_D(38, fcvt.lu.d, 0x10,          0, -3e9, rtz);
  TEST_FP_INT_OP_D(39, fcvt.lu.d, 0x00, 3000000000,  3e9, rtz);
#endif

  # test negative NaN, negative infinity conversion
  TEST_CASE(42, x1, 0x000000007fffffff, la x1, tdat_d; fld f1,  0(x1); fcvt.w.d x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE(43, x1, 0x7fffffffffffffff, la x1, tdat_d; fld f1,  0(x1); fcvt.l.d x1, f1)
#endif
  TEST_CASE(44, x1, 0xffffffff80000000, la x1, tdat_d; fld f1, 16(x1); fcvt.w.d x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE(45, x1, 0x8000000000000000, la x1, tdat_d; fld f1, 16(x1); fcvt.l.d x1, f1)
#endif

  # test positive NaN, positive infinity conversion
  TEST_CASE(52, x1, 0x000000007fffffff, la x1, tdat_d; fld f1,  8(x1); fcvt.w.d x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE(53, x1, 0x7fffffffffffffff, la x1, tdat_d; fld f1,  8(x1); fcvt.l.d x1, f1)
#endif
  TEST_CASE(54, x1, 0x000000007fffffff, la x1, tdat_d; fld f1, 24(x1); fcvt.w.d x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE(55, x1, 0x7fffffffffffffff, la x1, tdat_d; fld f1, 24(x1); fcvt.l.d x1, f1)
#endif

  # test NaN, infinity conversions to unsigned integer
  TEST_CASE(62, x1, 0xffffffffffffffff, la x1, tdat_d; fld f1,  0(x1); fcvt.wu.d x1, f1)
  TEST_CASE(63, x1, 0xffffffffffffffff, la x1, tdat_d; fld f1,  8(x1); fcvt.wu.d x1, f1)
  TEST_CASE(64, x1,                  0, la x1, tdat_d; fld f1, 16(x1); fcvt.wu.d x1, f1)
  TEST_CASE(65, x1, 0xffffffffffffffff, la x1, tdat_d; fld f1, 24(x1); fcvt.wu.d x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE(66, x1, 0xffffffffffffffff, la x1, tdat_d; fld f1,  0(x1); fcvt.lu.d x1, f1)
  TEST_CASE(67, x1, 0xffffffffffffffff, la x1, tdat_d; fld f1,  8(x1); fcvt.lu.d x1, f1)
  TEST_CASE(68, x1,                  0, la x1, tdat_d; fld f1, 16(x1); fcvt.lu.d x1, f1)
  TEST_CASE(69, x1, 0xffffffffffffffff, la x1, tdat_d; fld f1, 24(x1); fcvt.lu.d x1, f1)
#endif

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

# -NaN, NaN, -inf, +inf
tdat:
.word 0xffffffff
.word 0x7fffffff
.word 0xff800000
.word 0x7f800000

tdat_d:
.dword 0xffffffffffffffff
.dword 0x7fffffffffffffff
.dword 0xfff0000000000000
.dword 0x7ff0000000000000

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rvc.S
#-----------------------------------------------------------------------------
#
# Test RVC corner cases.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  .align 2
  .option push
  .option norvc

  #define RVC_TEST_CASE(n, r, v, code...) \
    TEST_CASE (n, r, v, .option push; .option rvc; code; .align 2; .option pop)

  // Make sure fetching a 4-byte instruction across a page boundary works.
  li TESTNUM, 2
  li a1, 666
  TEST_CASE (2, a1, 667, \
        j 1f; \
        .align 3; \
        data: \
          .dword 0xfedcba9876543210; \
          .dword 0xfedcba9876543210; \
        .align 12; \
        .skip 4094; \
      1: addi a1, a1, 1)

  li sp, 0x1234
  RVC_TEST_CASE (3, a0, 0x1234 + 1020, c.addi4spn a0, sp, 1020)
  RVC_TEST_CASE (4, sp, 0x1234 + 496, c.addi16sp sp, 496)
  RVC_TEST_CASE (5, sp, 0x1234 + 496 - 512, c.addi16sp sp, -512)

  la a1, data
  RVC_TEST_CASE (6, a2, 0xfffffffffedcba99, c.lw a0, 4(a1); addi a0, a0, 1; c.sw a0, 4(a1); c.lw a2, 4(a1))
#if __riscv_xlen == 64
  RVC_TEST_CASE (7, a2, 0xfedcba9976543211, c.ld a0, 0(a1); addi a0, a0, 1; c.sd a0, 0(a1); c.ld a2, 0(a1))
#endif

  RVC_TEST_CASE (8, a0, -15, ori a0, x0, 1; c.addi a0, -16)
  RVC_TEST_CASE (9, a5, -16, ori a5, x0, 1; c.li a5, -16)
#if __riscv_xlen == 64
  RVC_TEST_CASE (10, a0, 0x76543210, ld a0, (a1); c.addiw a0, -1)
#endif

  RVC_TEST_CASE (11, s0, 0xffffffffffffffe1, c.lui s0, 0xfffe1; c.srai s0, 12)
#if __riscv_xlen == 64
  RVC_TEST_CASE (12, s0, 0x000fffffffffffe1, c.lui s0, 0xfffe1; c.srli s0, 12)
#else
  RVC_TEST_CASE (12, s0, 0x000fffe1, c.lui s0, 0xfffe1; c.srli s0, 12)
#endif
  RVC_TEST_CASE (14, s0, ~0x11, c.li s0, -2; c.andi s0, ~0x10)
  RVC_TEST_CASE (15, s1, 14, li s1, 20; li a0, 6; c.sub s1, a0)
  RVC_TEST_CASE (16, s1, 18, li s1, 20; li a0, 6; c.xor s1, a0)
  RVC_TEST_CASE (17, s1, 22, li s1, 20; li a0, 6; c.or s1, a0)
  RVC_TEST_CASE (18, s1,  4, li s1, 20; li a0, 6; c.and s1, a0)
#if __riscv_xlen == 64
  RVC_TEST_CASE (19, s1, 0xffffffff80000000, li s1, 0x7fffffff; li a0, -1; c.subw s1, a0)
  RVC_TEST_CASE (20, s1, 0xffffffff80000000, li s1, 0x7fffffff; li a0, 1; c.addw s1, a0)
#endif
  RVC_TEST_CASE (21, s0, 0x12340, li s0, 0x1234; c.slli s0, 4)

  RVC_TEST_CASE (30, ra, 0, \
        li ra, 0; \
        c.j 1f; \
        c.j 2f; \
      1:c.j 1f; \
      2:j fail; \
      1:)

  RVC_TEST_CASE (31, x0, 0, \
        li a0, 0; \
        c.beqz a0, 1f; \
        c.j 2f; \
      1:c.j 1f; \
      2:j fail; \
      1:)

  RVC_TEST_CASE (32, x0, 0, \
        li a0, 1; \
        c.bnez a0, 1f; \
        c.j 2f; \
      1:c.j 1f; \
      2:j fail; \
      1:)

  RVC_TEST_CASE (33, x0, 0, \
        li a0, 1; \
        c.beqz a0, 1f; \
        c.j 2f; \
      1:c.j fail; \
      2:)

  RVC_TEST_CASE (34, x0, 0, \
        li a0, 0; \
        c.bnez a0, 1f; \
        c.j 2f; \
      1:c.j fail; \
      2:)

  RVC_TEST_CASE (35, ra, 0, \
        la t0, 1f; \
        li ra, 0; \
        c.jr t0; \
        c.j 2f; \
      1:c.j 1f; \
      2:j fail; \
      1:)

  RVC_TEST_CASE (36, ra, -2, \
        la t0, 1f; \
        li ra, 0; \
        c.jalr t0; \
        c.j 2f; \
      1:c.j 1f; \
      2:j fail; \
      1:sub ra, ra, t0)

#if __riscv_xlen == 32
  RVC_TEST_CASE (37, ra, -2, \
        la t0, 1f; \
        li ra, 0; \
        c.jal 1f; \
        c.j 2f; \
      1:c.j 1f; \
      2:j fail; \
      1:sub ra, ra, t0)
#endif

  la sp, data
  RVC_TEST_CASE (40, a2, 0xfffffffffedcba99, c.lwsp a0, 12(sp); addi a0, a0, 1; c.swsp a0, 12(sp); c.lwsp a2, 12(sp))
#if __riscv_xlen == 64
  RVC_TEST_CASE (41, a2, 0xfedcba9976543211, c.ldsp a0, 8(sp); addi a0, a0, 1; c.sdsp a0, 8(sp); c.ldsp a2, 8(sp))
#endif

  RVC_TEST_CASE (42, t0, 0x246, li a0, 0x123; c.mv t0, a0; c.add t0, a0)

  .option pop

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# remu.S
#-----------------------------------------------------------------------------
#
# Test remu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, remu,   2,  20,   6 );
  TEST_RR_OP( 3, remu,   2, -20,   6 );
  TEST_RR_OP( 4, remu,  20,  20,  -6 );
  TEST_RR_OP( 5, remu, -20, -20,  -6 );

  TEST_RR_OP( 6, remu,      0, -1<<63,  1 );
  TEST_RR_OP( 7, remu, -1<<63, -1<<63, -1 );

  TEST_RR_OP( 8, remu, -1<<63, -1<<63, 0 );
  TEST_RR_OP( 9, remu,      1,      1, 0 );
  TEST_RR_OP(10, remu,      0,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rem.S
#-----------------------------------------------------------------------------
#
# Test rem instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, rem,  2,  20,   6 );
  TEST_RR_OP( 3, rem, -2, -20,   6 );
  TEST_RR_OP( 4, rem,  2,  20,  -6 );
  TEST_RR_OP( 5, rem, -2, -20,  -6 );

  TEST_RR_OP( 6, rem,  0, -1<<63,  1 );
  TEST_RR_OP( 7, rem,  0, -1<<63, -1 );

  TEST_RR_OP( 8, rem, -1<<63, -1<<63, 0 );
  TEST_RR_OP( 9, rem,      1,      1, 0 );
  TEST_RR_OP(10, rem,      0,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# divw.S
#-----------------------------------------------------------------------------
#
# Test divw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, divw,  3,  20,   6 );
  TEST_RR_OP( 3, divw, -3, -20,   6 );
  TEST_RR_OP( 4, divw, -3,  20,  -6 );
  TEST_RR_OP( 5, divw,  3, -20,  -6 );

  TEST_RR_OP( 6, divw, -1<<31, -1<<31,  1 );
  TEST_RR_OP( 7, divw, -1<<31, -1<<31, -1 );

  TEST_RR_OP( 8, divw, -1, -1<<31, 0 );
  TEST_RR_OP( 9, divw, -1,      1, 0 );
  TEST_RR_OP(10, divw, -1,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# remw.S
#-----------------------------------------------------------------------------
#
# Test remw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, remw,  2,  20,   6 );
  TEST_RR_OP( 3, remw, -2, -20,   6 );
  TEST_RR_OP( 4, remw,  2,  20,  -6 );
  TEST_RR_OP( 5, remw, -2, -20,  -6 );

  TEST_RR_OP( 6, remw,  0, -1<<31,  1 );
  TEST_RR_OP( 7, remw,  0, -1<<31, -1 );

  TEST_RR_OP( 8, remw, -1<<31, -1<<31, 0 );
  TEST_RR_OP( 9, remw,      1,      1, 0 );
  TEST_RR_OP(10, remw,      0,      0, 0 );
  TEST_RR_OP(11, remw, 0xfffffffffffff897,0xfffffffffffff897, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mul.S
#-----------------------------------------------------------------------------
#
# Test mul instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP(32,  mul, 0x0000000000001200, 0x0000000000007e00, 0x6db6db6db6db6db7 );
  TEST_RR_OP(33,  mul, 0x0000000000001240, 0x0000000000007fc0, 0x6db6db6db6db6db7 );

  TEST_RR_OP( 2,  mul, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  mul, 0x00000001, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  mul, 0x00000015, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  mul, 0x0000000000000000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  mul, 0x0000000000000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  mul, 0x0000400000000000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP(30,  mul, 0x000000000000ff7f, 0xaaaaaaaaaaaaaaab, 0x000000000002fe7d );
  TEST_RR_OP(31,  mul, 0x000000000000ff7f, 0x000000000002fe7d, 0xaaaaaaaaaaaaaaab );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, mul, 143, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 9, mul, 154, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 10, mul, 169, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, mul, 143, 13, 11 );
  TEST_RR_DEST_BYPASS( 12, 1, mul, 154, 14, 11 );
  TEST_RR_DEST_BYPASS( 13, 2, mul, 165, 15, 11 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, mul, 143, 13, 11 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, mul, 154, 14, 11 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, mul, 165, 15, 11 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, mul, 143, 13, 11 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, mul, 154, 14, 11 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, mul, 165, 15, 11 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, mul, 143, 13, 11 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, mul, 154, 14, 11 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, mul, 165, 15, 11 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, mul, 143, 13, 11 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, mul, 154, 14, 11 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, mul, 165, 15, 11 );

  TEST_RR_ZEROSRC1( 26, mul, 0, 31 );
  TEST_RR_ZEROSRC2( 27, mul, 0, 32 );
  TEST_RR_ZEROSRC12( 28, mul, 0 );
  TEST_RR_ZERODEST( 29, mul, 33, 34 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mulhsu.S
#-----------------------------------------------------------------------------
#
# Test mulhsu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  mulhsu, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  mulhsu, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  mulhsu, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  mulhsu, 0x0000000000000000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  mulhsu, 0x0000000000000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  mulhsu, 0xffffffff80000000, 0xffffffff80000000, 0xffffffffffff8000 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, mulhsu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC2_EQ_DEST( 9, mulhsu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC12_EQ_DEST( 10, mulhsu, 169, 13<<32 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, mulhsu, 143, 13<<32, 11<<32 );
  TEST_RR_DEST_BYPASS( 12, 1, mulhsu, 154, 14<<32, 11<<32 );
  TEST_RR_DEST_BYPASS( 13, 2, mulhsu, 165, 15<<32, 11<<32 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, mulhsu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, mulhsu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, mulhsu, 165, 15<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, mulhsu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, mulhsu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, mulhsu, 165, 15<<32, 11<<32 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, mulhsu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, mulhsu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, mulhsu, 165, 15<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, mulhsu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, mulhsu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, mulhsu, 165, 15<<32, 11<<32 );

  TEST_RR_ZEROSRC1( 26, mulhsu, 0, 31<<32 );
  TEST_RR_ZEROSRC2( 27, mulhsu, 0, 32<<32 );
  TEST_RR_ZEROSRC12( 28, mulhsu, 0 );
  TEST_RR_ZERODEST( 29, mulhsu, 33<<32, 34<<32 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mulh.S
#-----------------------------------------------------------------------------
#
# Test mulh instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  mulh, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  mulh, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  mulh, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  mulh, 0x0000000000000000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  mulh, 0x0000000000000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  mulh, 0x0000000000000000, 0xffffffff80000000, 0xffffffffffff8000 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, mulh, 143, 13<<32, 11<<32 );
  TEST_RR_SRC2_EQ_DEST( 9, mulh, 154, 14<<32, 11<<32 );
  TEST_RR_SRC12_EQ_DEST( 10, mulh, 169, 13<<32 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, mulh, 143, 13<<32, 11<<32 );
  TEST_RR_DEST_BYPASS( 12, 1, mulh, 154, 14<<32, 11<<32 );
  TEST_RR_DEST_BYPASS( 13, 2, mulh, 165, 15<<32, 11<<32 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, mulh, 143, 13<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, mulh, 154, 14<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, mulh, 165, 15<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, mulh, 143, 13<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, mulh, 154, 14<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, mulh, 165, 15<<32, 11<<32 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, mulh, 143, 13<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, mulh, 154, 14<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, mulh, 165, 15<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, mulh, 143, 13<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, mulh, 154, 14<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, mulh, 165, 15<<32, 11<<32 );

  TEST_RR_ZEROSRC1( 26, mulh, 0, 31<<32 );
  TEST_RR_ZEROSRC2( 27, mulh, 0, 32<<32 );
  TEST_RR_ZEROSRC12( 28, mulh, 0 );
  TEST_RR_ZERODEST( 29, mulh, 33<<32, 34<<32 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# divuw.S
#-----------------------------------------------------------------------------
#
# Test divuw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, divuw,         3,  20,   6 );
  TEST_RR_OP( 3, divuw, 715827879, -20 << 32 >> 32,   6 );
  TEST_RR_OP( 4, divuw,         0,  20,  -6 );
  TEST_RR_OP( 5, divuw,         0, -20,  -6 );

  TEST_RR_OP( 6, divuw, -1<<31, -1<<31,  1 );
  TEST_RR_OP( 7, divuw, 0,      -1<<31, -1 );

  TEST_RR_OP( 8, divuw, -1, -1<<31, 0 );
  TEST_RR_OP( 9, divuw, -1,      1, 0 );
  TEST_RR_OP(10, divuw, -1,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mulhu.S
#-----------------------------------------------------------------------------
#
# Test mulhu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  mulhu, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  mulhu, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  mulhu, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  mulhu, 0x0000000000000000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  mulhu, 0x0000000000000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  mulhu, 0xffffffff7fff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP(30,  mulhu, 0x000000000001fefe, 0xaaaaaaaaaaaaaaab, 0x000000000002fe7d );
  TEST_RR_OP(31,  mulhu, 0x000000000001fefe, 0x000000000002fe7d, 0xaaaaaaaaaaaaaaab );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, mulhu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC2_EQ_DEST( 9, mulhu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC12_EQ_DEST( 10, mulhu, 169, 13<<32 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, mulhu, 143, 13<<32, 11<<32 );
  TEST_RR_DEST_BYPASS( 12, 1, mulhu, 154, 14<<32, 11<<32 );
  TEST_RR_DEST_BYPASS( 13, 2, mulhu, 165, 15<<32, 11<<32 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, mulhu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, mulhu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, mulhu, 165, 15<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, mulhu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, mulhu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, mulhu, 165, 15<<32, 11<<32 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, mulhu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, mulhu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, mulhu, 165, 15<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, mulhu, 143, 13<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, mulhu, 154, 14<<32, 11<<32 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, mulhu, 165, 15<<32, 11<<32 );

  TEST_RR_ZEROSRC1( 26, mulhu, 0, 31<<32 );
  TEST_RR_ZEROSRC2( 27, mulhu, 0, 32<<32 );
  TEST_RR_ZEROSRC12( 28, mulhu, 0 );
  TEST_RR_ZERODEST( 29, mulhu, 33<<32, 34<<32 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mulw.S
#-----------------------------------------------------------------------------
#
# Test mulw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  mulw, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  mulw, 0x00000001, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  mulw, 0x00000015, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  mulw, 0x0000000000000000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  mulw, 0x0000000000000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  mulw, 0x0000000000000000, 0xffffffff80000000, 0xffffffffffff8000 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, mulw, 143, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 9, mulw, 154, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 10, mulw, 169, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, mulw, 143, 13, 11 );
  TEST_RR_DEST_BYPASS( 12, 1, mulw, 154, 14, 11 );
  TEST_RR_DEST_BYPASS( 13, 2, mulw, 165, 15, 11 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, mulw, 143, 13, 11 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, mulw, 154, 14, 11 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, mulw, 165, 15, 11 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, mulw, 143, 13, 11 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, mulw, 154, 14, 11 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, mulw, 165, 15, 11 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, mulw, 143, 13, 11 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, mulw, 154, 14, 11 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, mulw, 165, 15, 11 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, mulw, 143, 13, 11 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, mulw, 154, 14, 11 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, mulw, 165, 15, 11 );

  TEST_RR_ZEROSRC1( 26, mulw, 0, 31 );
  TEST_RR_ZEROSRC2( 27, mulw, 0, 32 );
  TEST_RR_ZEROSRC12( 28, mulw, 0 );
  TEST_RR_ZERODEST( 29, mulw, 33, 34 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# divu.S
#-----------------------------------------------------------------------------
#
# Test divu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, divu,                   3,  20,   6 );
  TEST_RR_OP( 3, divu, 3074457345618258599, -20,   6 );
  TEST_RR_OP( 4, divu,                   0,  20,  -6 );
  TEST_RR_OP( 5, divu,                   0, -20,  -6 );

  TEST_RR_OP( 6, divu, -1<<63, -1<<63,  1 );
  TEST_RR_OP( 7, divu,     0,  -1<<63, -1 );

  TEST_RR_OP( 8, divu, -1, -1<<63, 0 );
  TEST_RR_OP( 9, divu, -1,      1, 0 );
  TEST_RR_OP(10, divu, -1,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# div.S
#-----------------------------------------------------------------------------
#
# Test div instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, div,  3,  20,   6 );
  TEST_RR_OP( 3, div, -3, -20,   6 );
  TEST_RR_OP( 4, div, -3,  20,  -6 );
  TEST_RR_OP( 5, div,  3, -20,  -6 );

  TEST_RR_OP( 6, div, -1<<63, -1<<63,  1 );
  TEST_RR_OP( 7, div, -1<<63, -1<<63, -1 );

  TEST_RR_OP( 8, div, -1, -1<<63, 0 );
  TEST_RR_OP( 9, div, -1,      1, 0 );
  TEST_RR_OP(10, div, -1,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# remuw.S
#-----------------------------------------------------------------------------
#
# Test remuw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, remuw,   2,  20,   6 );
  TEST_RR_OP( 3, remuw,   2, -20,   6 );
  TEST_RR_OP( 4, remuw,  20,  20,  -6 );
  TEST_RR_OP( 5, remuw, -20, -20,  -6 );

  TEST_RR_OP( 6, remuw,      0, -1<<31,  1 );
  TEST_RR_OP( 7, remuw, -1<<31, -1<<31, -1 );

  TEST_RR_OP( 8, remuw, -1<<31, -1<<31, 0 );
  TEST_RR_OP( 9, remuw,      1,      1, 0 );
  TEST_RR_OP(10, remuw,      0,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64mi/lh-misaligned.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64si/csr.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64mi/lw-misaligned.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64mi/pmpaddr.S"
# See LICENSE for license details.

#*****************************************************************************
# shamt.S
#-----------------------------------------------------------------------------
#
# Test illegal shamt[5] of shift instruction in 32-bit ISA.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32M
RVTEST_CODE_BEGIN

  # Make sure slli with shamt[4] set is legal.
  TEST_CASE( 2, a0, 65536, li a0, 1; slli a0, a0, 16);

  # Make sure slli with shamt[5] set is not legal.
  TEST_CASE( 3, x0, 1, .word 0x02051513); # slli a0, a0, 32

  TEST_PASSFAIL

.align 2
.global mtvec_handler
mtvec_handler:
  # Trapping on test 3 is good.
  li t0, 3
  bne TESTNUM, t0, fail

  # Make sure CAUSE indicates an illegal instructino.
  csrr t0, mcause
  li t1, CAUSE_ILLEGAL_INSTRUCTION
  bne t0, t1, fail
  j pass

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M

#include "../rv64mi/illegal.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64mi/zicntr.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64mi/breakpoint.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64si/scall.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64si/sbreak.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64mi/sh-misaligned.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64si/ma_fetch.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64mi/sw-misaligned.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M

#include "../rv64mi/ma_addr.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M
#define __MACHINE_MODE

#include "../rv64mi/instret_overflow.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M

#include "../rv64mi/mcsr.S"
# See LICENSE for license details.

#*****************************************************************************
# binvi.S
#-----------------------------------------------------------------------------
#
# Test binvi instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  binvi, 0x0000000000000000, 0x0000000000000001, 0  );
  TEST_IMM_OP( 3,  binvi, 0x0000000000000003, 0x0000000000000001, 1  );
  TEST_IMM_OP( 4,  binvi, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_IMM_OP( 5,  binvi, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_IMM_OP( 6,  binvi, 0x0000000080000001, 0x0000000000000001, 31 );

  TEST_IMM_OP( 7,  binvi, 0xfffffffffffffffe, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  binvi, 0xfffffffffffffffd, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  binvi, 0xffffffffffffff7f, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, binvi, 0xffffffffffffbfff, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, binvi, 0xffffffff7fffffff, 0xffffffffffffffff, 31 );

  TEST_IMM_OP( 12, binvi, 0x0000000021212120, 0x0000000021212121, 0  );
  TEST_IMM_OP( 13, binvi, 0x0000000021212123, 0x0000000021212121, 1  );
  TEST_IMM_OP( 14, binvi, 0x00000000212121a1, 0x0000000021212121, 7  );
  TEST_IMM_OP( 15, binvi, 0x0000000021216121, 0x0000000021212121, 14 );
  TEST_IMM_OP( 16, binvi, 0x00000000a1212121, 0x0000000021212121, 31 );

#if __riscv_xlen == 64
  TEST_IMM_OP( 50, binvi, 0x8000000000000001, 0x0000000000000001, 63 );
  TEST_IMM_OP( 51, binvi, 0xffffff7fffffffff, 0xffffffffffffffff, 39 );
  TEST_IMM_OP( 52, binvi, 0x0000080021212121, 0x0000000021212121, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, binvi, 0x00000081, 0x00000001, 7  );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, binvi, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, binvi, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, binvi, 0x0000000080000001, 0x0000000000000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, binvi, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_IMM_SRC1_BYPASS( 22, 1, binvi, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, binvi, 0x0000000080000001, 0x0000000000000001, 31 );


  TEST_IMM_ZEROSRC1( 24, binvi, 0x00008000, 15 );
  TEST_IMM_ZERODEST( 25, binvi, 1024, 10 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bclri.S
#-----------------------------------------------------------------------------
#
# Test bclri instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  bclri, 0xff00ff00, 0xff00ff00, 0  );
  TEST_IMM_OP( 3,  bclri, 0x00ff00fd, 0x00ff00ff, 1  );
  TEST_IMM_OP( 4,  bclri, 0xff00fe00, 0xff00ff00, 8  );
  TEST_IMM_OP( 5,  bclri, 0x0ff00ff0, 0x0ff00ff0, 14 );
  TEST_IMM_OP( 6,  bclri, 0x07f00ff0, 0x0ff00ff0, 27 );

  TEST_IMM_OP( 7,  bclri, 0xfffffffffffffffe, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  bclri, 0xfffffffffffffffd, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  bclri, 0xffffffffffffff7f, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, bclri, 0xffffffffffffbfff, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, bclri, 0xfffffffff7ffffff, 0xffffffffffffffff, 27 );

  TEST_IMM_OP( 12, bclri, 0x21212120, 0x21212121, 0  );
  TEST_IMM_OP( 13, bclri, 0x21212121, 0x21212121, 1  );
  TEST_IMM_OP( 14, bclri, 0x21212121, 0x21212121, 7  );
  TEST_IMM_OP( 15, bclri, 0x21210121, 0x21212121, 13 );
  TEST_IMM_OP( 16, bclri, 0x04848484, 0x84848484, 31 );

#if __riscv_xlen == 64
  TEST_IMM_OP( 50, bclri, 0x0000000000000001, 0x0000000000000001, 63 );
  TEST_IMM_OP( 51, bclri, 0xffffff7fffffffff, 0xffffffffffffffff, 39 );
  TEST_IMM_OP( 52, bclri, 0xfffff7ff00000000, 0xffffffff00000000, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, bclri, 0x00000001, 0x00000001, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, bclri, 0xff00fe00, 0xff00ff00, 8  );
  TEST_IMM_DEST_BYPASS( 19, 1, bclri, 0x0ff00ff0, 0x0ff00ff0, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, bclri, 0x07f00ff0, 0x0ff00ff0, 27 );

  TEST_IMM_SRC1_BYPASS( 21, 0, bclri, 0xff00fe00, 0xff00ff00, 8  );
  TEST_IMM_SRC1_BYPASS( 22, 1, bclri, 0x0ff00ff0, 0x0ff00ff0, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, bclri, 0x07f00ff0, 0x0ff00ff0, 27 );

  TEST_IMM_ZEROSRC1( 24, bclri, 0, 31 );
  TEST_IMM_ZERODEST( 25, bclri, 33, 20 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bset.S
#-----------------------------------------------------------------------------
#
# Test bset instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  bset, 0xff00ff01, 0xff00ff00, 0  );
  TEST_IMM_OP( 3,  bset, 0x00ff00ff, 0x00ff00ff, 1  );
  TEST_IMM_OP( 4,  bset, 0xff00ff00, 0xff00ff00, 8  );
  TEST_IMM_OP( 5,  bset, 0x0ff04ff0, 0x0ff00ff0, 14 );
  TEST_IMM_OP( 6,  bset, 0x0ff00ff0, 0x0ff00ff0, 27 );

  TEST_IMM_OP( 7,  bset, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_IMM_OP( 8,  bset, 0x0000000000000003, 0x0000000000000001, 1  );
  TEST_IMM_OP( 9,  bset, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_IMM_OP( 10,  bset, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_IMM_OP( 11,  bset, 0x0000000080000001, 0x0000000000000001, 31 );

  TEST_IMM_OP( 12, bset, 0x21212121, 0x21212121, 0  );
  TEST_IMM_OP( 13, bset, 0x21212123, 0x21212121, 1  );
  TEST_IMM_OP( 14, bset, 0x212121a1, 0x21212121, 7  );
  TEST_IMM_OP( 15, bset, 0x21212121, 0x21212121, 13 );
  TEST_IMM_OP( 16, bset, 0x84848484, 0x84848484, 31 );

#if __riscv_xlen == 64
  TEST_IMM_OP( 50, bset, 0x8000000000000001, 0x0000000000000001, 63 );
  TEST_IMM_OP( 51, bset, 0xffffffffffffffff, 0xffffffffffffffff, 39 );
  TEST_IMM_OP( 52, bset, 0xffffffff00000000, 0xffffffff00000000, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, bset, 0x00000081, 0x00000001, 7  );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, bset, 0xff00ff01, 0xff00ff00, 0  );
  TEST_IMM_DEST_BYPASS( 19, 1, bset, 0x00ff00ff, 0x00ff00ff, 1  );
  TEST_IMM_DEST_BYPASS( 20, 2, bset, 0xff00ff00, 0xff00ff00, 8  );

  TEST_IMM_SRC1_BYPASS( 21, 0, bset, 0xff00ff00, 0xff00ff00, 8  );
  TEST_IMM_SRC1_BYPASS( 22, 1, bset, 0x0ff04ff0, 0x0ff00ff0, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, bset, 0x0ff00ff0, 0x0ff00ff0, 27 );

  TEST_IMM_ZEROSRC1( 24, bset, 0x00008000, 15 );
  TEST_IMM_ZERODEST( 25, bset, 1024, 10 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bext.S
#-----------------------------------------------------------------------------
#
# Test bext instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  bext, 0, 0xff00ff00, 0  );
  TEST_RR_OP( 3,  bext, 1, 0x00ff00ff, 1  );
  TEST_RR_OP( 4,  bext, 1, 0xff00ff00, 8  );
  TEST_RR_OP( 5,  bext, 0, 0x0ff00ff0, 14 );
  TEST_RR_OP( 6,  bext, 1, 0x0ff00ff0, 27 );

  TEST_RR_OP( 7,  bext, 1, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  bext, 1, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  bext, 1, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, bext, 1, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, bext, 1, 0xffffffffffffffff, 27 );

  TEST_RR_OP( 12, bext, 1, 0x21212121, 0  );
  TEST_RR_OP( 13, bext, 0, 0x21212121, 1  );
  TEST_RR_OP( 14, bext, 0, 0x21212121, 7  );
  TEST_RR_OP( 15, bext, 1, 0x21212121, 13 );
  TEST_RR_OP( 16, bext, 1, 0x84848484, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, bext, 1, 0x21212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, bext, 0, 0x21212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, bext, 0, 0x21212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, bext, 0, 0x84848484, 0xffffffffffffffce );

#if __riscv_xlen == 64
  TEST_RR_OP( 21, bext, 1, 0xc484848421212121, 0xffffffffffffffff );
  TEST_RR_OP( 50, bext, 0, 0x0000000000000001, 63 );
  TEST_RR_OP( 51, bext, 1, 0xffffffffffffffff, 39 );
  TEST_RR_OP( 52, bext, 1, 0xffffffff00000000, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, bext, 0, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, bext, 1, 0x00005551, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, bext, 0, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, bext, 0, 0xff00ff00, 0  );
  TEST_RR_DEST_BYPASS( 26, 1, bext, 1, 0x00ff00ff, 1  );
  TEST_RR_DEST_BYPASS( 27, 2, bext, 1, 0xff00ff00, 8  );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, bext, 0, 0xff00ff00, 0  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, bext, 1, 0x00ff00ff, 1  );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, bext, 1, 0xff00ff00, 8  );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, bext, 0, 0xff00ff00, 0  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, bext, 1, 0x00ff00ff, 1  );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, bext, 1, 0xff00ff00, 8  );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, bext, 1, 0xff00ff00, 8  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, bext, 0, 0x0ff00ff0, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, bext, 1, 0x0ff00ff0, 27 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, bext, 1, 0xff00ff00, 8  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, bext, 0, 0x0ff00ff0, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, bext, 1, 0x0ff00ff0, 27 );

  TEST_RR_ZEROSRC1( 40, bext, 0, 15 );
  TEST_RR_ZEROSRC2( 41, bext, 0, 32 );
  TEST_RR_ZEROSRC12( 42, bext, 0 );
  TEST_RR_ZERODEST( 43, bext, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bexti.S
#-----------------------------------------------------------------------------
#
# Test bexti instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  bexti, 0, 0xff00ff00, 0  );
  TEST_IMM_OP( 3,  bexti, 1, 0x00ff00ff, 1  );
  TEST_IMM_OP( 4,  bexti, 1, 0xff00ff00, 8  );
  TEST_IMM_OP( 5,  bexti, 0, 0x0ff00ff0, 14 );
  TEST_IMM_OP( 6,  bexti, 1, 0x0ff00ff0, 27 );

  TEST_IMM_OP( 7,  bexti, 1, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  bexti, 1, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  bexti, 1, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, bexti, 1, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, bexti, 1, 0xffffffffffffffff, 27 );

  TEST_IMM_OP( 12, bexti, 1, 0x21212121, 0  );
  TEST_IMM_OP( 13, bexti, 0, 0x21212121, 1  );
  TEST_IMM_OP( 14, bexti, 0, 0x21212121, 7  );
  TEST_IMM_OP( 15, bexti, 1, 0x21212121, 13 );
  TEST_IMM_OP( 16, bexti, 1, 0x84848484, 31 );

#if __riscv_xlen == 64
  TEST_IMM_OP( 50, bexti, 0, 0x0000000000000001, 63 );
  TEST_IMM_OP( 51, bexti, 1, 0xffffffffffffffff, 39 );
  TEST_IMM_OP( 52, bexti, 1, 0xffffffff00000000, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, bexti, 0, 0x00000001, 7  );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, bexti, 1, 0xff00ff00, 8  );
  TEST_IMM_DEST_BYPASS( 19, 1, bexti, 0, 0x0ff00ff0, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, bexti, 1, 0x0ff00ff0, 27 );

  TEST_IMM_SRC1_BYPASS( 21, 0, bexti, 1, 0xff00ff00, 8  );
  TEST_IMM_SRC1_BYPASS( 22, 1, bexti, 0, 0x0ff00ff0, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, bexti, 1, 0x0ff00ff0, 27 );

  TEST_IMM_ZEROSRC1( 24, bexti, 0, 31 );
  TEST_IMM_ZERODEST( 25, bexti, 33, 20 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bclr.S
#-----------------------------------------------------------------------------
#
# Test bclr instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  bclr, 0xff00ff00, 0xff00ff00, 0  );
  TEST_RR_OP( 3,  bclr, 0x00ff00fd, 0x00ff00ff, 1  );
  TEST_RR_OP( 4,  bclr, 0xff00fe00, 0xff00ff00, 8  );
  TEST_RR_OP( 5,  bclr, 0x0ff00ff0, 0x0ff00ff0, 14 );
  TEST_RR_OP( 6,  bclr, 0x07f00ff0, 0x0ff00ff0, 27 );

  TEST_RR_OP( 7,  bclr, 0xfffffffffffffffe, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  bclr, 0xfffffffffffffffd, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  bclr, 0xffffffffffffff7f, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, bclr, 0xffffffffffffbfff, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, bclr, 0xfffffffff7ffffff, 0xffffffffffffffff, 27 );

  TEST_RR_OP( 12, bclr, 0x21212120, 0x21212121, 0  );
  TEST_RR_OP( 13, bclr, 0x21212121, 0x21212121, 1  );
  TEST_RR_OP( 14, bclr, 0x21212121, 0x21212121, 7  );
  TEST_RR_OP( 15, bclr, 0x21210121, 0x21212121, 13 );
  TEST_RR_OP( 16, bclr, 0x04848484, 0x84848484, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, bclr, 0x21212120, 0x21212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, bclr, 0x21212121, 0x21212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, bclr, 0x21212121, 0x21212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, bclr, 0x84848484, 0x84848484, 0xffffffffffffffce );

#if __riscv_xlen == 64
  TEST_RR_OP( 21, bclr, 0x4484848421212121, 0xc484848421212121, 0xffffffffffffffff );
  TEST_RR_OP( 50, bclr, 0x0000000000000001, 0x0000000000000001, 63 );
  TEST_RR_OP( 51, bclr, 0xffffff7fffffffff, 0xffffffffffffffff, 39 );
  TEST_RR_OP( 52, bclr, 0xfffff7ff00000000, 0xffffffff00000000, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, bclr, 0x00000001, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, bclr, 0x00001551, 0x00005551, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, bclr, 3, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, bclr, 0xff00ff00, 0xff00ff00, 0  );
  TEST_RR_DEST_BYPASS( 26, 1, bclr, 0x00ff00fd, 0x00ff00ff, 1  );
  TEST_RR_DEST_BYPASS( 27, 2, bclr, 0xff00fe00, 0xff00ff00, 8  );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, bclr, 0xff00ff00, 0xff00ff00, 0  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, bclr, 0x00ff00fd, 0x00ff00ff, 1  );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, bclr, 0xff00fe00, 0xff00ff00, 8  );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, bclr, 0xff00ff00, 0xff00ff00, 0  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, bclr, 0x00ff00fd, 0x00ff00ff, 1  );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, bclr, 0xff00fe00, 0xff00ff00, 8  );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, bclr, 0xff00fe00, 0xff00ff00, 8  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, bclr, 0x0ff00ff0, 0x0ff00ff0, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, bclr, 0x07f00ff0, 0x0ff00ff0, 27 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, bclr, 0xff00fe00, 0xff00ff00, 8  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, bclr, 0x0ff00ff0, 0x0ff00ff0, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, bclr, 0x07f00ff0, 0x0ff00ff0, 27 );

  TEST_RR_ZEROSRC1( 40, bclr, 0, 15 );
  TEST_RR_ZEROSRC2( 41, bclr, 32, 32 );
  TEST_RR_ZEROSRC12( 42, bclr, 0 );
  TEST_RR_ZERODEST( 43, bclr, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# binv.S
#-----------------------------------------------------------------------------
#
# Test binv instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  binv, 0x0000000000000000, 0x0000000000000001, 0  );
  TEST_RR_OP( 3,  binv, 0x0000000000000003, 0x0000000000000001, 1  );
  TEST_RR_OP( 4,  binv, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_RR_OP( 5,  binv, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_RR_OP( 6,  binv, 0x0000000080000001, 0x0000000000000001, 31 );

  TEST_RR_OP( 7,  binv, 0xfffffffffffffffe, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  binv, 0xfffffffffffffffd, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  binv, 0xffffffffffffff7f, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, binv, 0xffffffffffffbfff, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, binv, 0xffffffff7fffffff, 0xffffffffffffffff, 31 );

  TEST_RR_OP( 12, binv, 0x0000000021212120, 0x0000000021212121, 0  );
  TEST_RR_OP( 13, binv, 0x0000000021212123, 0x0000000021212121, 1  );
  TEST_RR_OP( 14, binv, 0x00000000212121a1, 0x0000000021212121, 7  );
  TEST_RR_OP( 15, binv, 0x0000000021216121, 0x0000000021212121, 14 );
  TEST_RR_OP( 16, binv, 0x00000000a1212121, 0x0000000021212121, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, binv, 0x0000000021212120, 0x0000000021212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, binv, 0x0000000021212123, 0x0000000021212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, binv, 0x00000000212121a1, 0x0000000021212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, binv, 0x0000000021216121, 0x0000000021212121, 0xffffffffffffffce );

#if __riscv_xlen == 64
  TEST_RR_OP( 21, binv, 0x8000000021212121, 0x0000000021212121, 0xffffffffffffffff );
  TEST_RR_OP( 50, binv, 0x8000000000000001, 0x0000000000000001, 63 );
  TEST_RR_OP( 51, binv, 0xffffff7fffffffff, 0xffffffffffffffff, 39 );
  TEST_RR_OP( 52, binv, 0x0000080021212121, 0x0000000021212121, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, binv, 0x00000081, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, binv, 0x00004001, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, binv, 11, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, binv, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, binv, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, binv, 0x0000000080000001, 0x0000000000000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, binv, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, binv, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, binv, 0x0000000080000001, 0x0000000000000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, binv, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, binv, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, binv, 0x0000000080000001, 0x0000000000000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, binv, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, binv, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, binv, 0x0000000080000001, 0x0000000000000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, binv, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, binv, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, binv, 0x0000000080000001, 0x0000000000000001, 31 );

  TEST_RR_ZEROSRC1( 40, binv, 0x00008000, 15 );
  TEST_RR_ZEROSRC2( 41, binv, 33, 32 );
  TEST_RR_ZEROSRC12( 42, binv, 1 );
  TEST_RR_ZERODEST( 43, binv, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bset.S
#-----------------------------------------------------------------------------
#
# Test bset instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  bset, 0xff00ff01, 0xff00ff00, 0  );
  TEST_RR_OP( 3,  bset, 0x00ff00ff, 0x00ff00ff, 1  );
  TEST_RR_OP( 4,  bset, 0xff00ff00, 0xff00ff00, 8  );
  TEST_RR_OP( 5,  bset, 0x0ff04ff0, 0x0ff00ff0, 14 );
  TEST_RR_OP( 6,  bset, 0x0ff00ff0, 0x0ff00ff0, 27 );

  TEST_RR_OP( 7,  bset, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_RR_OP( 8,  bset, 0x0000000000000003, 0x0000000000000001, 1  );
  TEST_RR_OP( 9,  bset, 0x0000000000000081, 0x0000000000000001, 7  );
  TEST_RR_OP( 10,  bset, 0x0000000000004001, 0x0000000000000001, 14 );
  TEST_RR_OP( 11,  bset, 0x0000000080000001, 0x0000000000000001, 31 );

  TEST_RR_OP( 12, bset, 0x21212121, 0x21212121, 0  );
  TEST_RR_OP( 13, bset, 0x21212123, 0x21212121, 1  );
  TEST_RR_OP( 14, bset, 0x212121a1, 0x21212121, 7  );
  TEST_RR_OP( 15, bset, 0x21212121, 0x21212121, 13 );
  TEST_RR_OP( 16, bset, 0x84848484, 0x84848484, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, bset, 0x21212121, 0x21212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, bset, 0x21212123, 0x21212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, bset, 0x212121a1, 0x21212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, bset, 0x8484c484, 0x84848484, 0xffffffffffffffce );

#if __riscv_xlen == 64
  TEST_RR_OP( 21, bset, 0xc484848421212121, 0xc484848421212121, 0xffffffffffffffff );
  TEST_RR_OP( 50, bset, 0x8000000000000001, 0x0000000000000001, 63 );
  TEST_RR_OP( 51, bset, 0xffffffffffffffff, 0xffffffffffffffff, 39 );
  TEST_RR_OP( 52, bset, 0xffffffff00000000, 0xffffffff00000000, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, bset, 0x00000081, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, bset, 0x00005551, 0x00005551, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, bset, 11, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, bset, 0xff00ff01, 0xff00ff00, 0  );
  TEST_RR_DEST_BYPASS( 26, 1, bset, 0x00ff00ff, 0x00ff00ff, 1  );
  TEST_RR_DEST_BYPASS( 27, 2, bset, 0xff00ff00, 0xff00ff00, 8  );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, bset, 0xff00ff01, 0xff00ff00, 0  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, bset, 0x00ff00ff, 0x00ff00ff, 1  );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, bset, 0xff00ff00, 0xff00ff00, 8  );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, bset, 0xff00ff01, 0xff00ff00, 0  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, bset, 0x00ff00ff, 0x00ff00ff, 1  );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, bset, 0xff00ff00, 0xff00ff00, 8  );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, bset, 0xff00ff00, 0xff00ff00, 8  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, bset, 0x0ff04ff0, 0x0ff00ff0, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, bset, 0x0ff00ff0, 0x0ff00ff0, 27 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, bset, 0xff00ff00, 0xff00ff00, 8  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, bset, 0x0ff04ff0, 0x0ff00ff0, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, bset, 0x0ff00ff0, 0x0ff00ff0, 27 );

  TEST_RR_ZEROSRC1( 40, bset, 0x00008000, 15 );
  TEST_RR_ZEROSRC2( 41, bset, 33, 32 );
  TEST_RR_ZEROSRC12( 42, bset, 1 );
  TEST_RR_ZERODEST( 43, bset, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/zext_h.S"
# See LICENSE for license details.

#*****************************************************************************
# rori.S
#-----------------------------------------------------------------------------
#
# Test rori instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  rori, 0x00000001, 0x00000001, 0  );
  TEST_IMM_OP( 3,  rori, 0x80000000, 0x00000001, 1  );
  TEST_IMM_OP( 4,  rori, 0x02000000, 0x00000001, 7  );
  TEST_IMM_OP( 5,  rori, 0x00040000, 0x00000001, 14 );
  TEST_IMM_OP( 6,  rori, 0x00000002, 0x00000001, 31 );

  TEST_IMM_OP( 7,  rori, 0xffffffff, 0xffffffff, 0  );
  TEST_IMM_OP( 8,  rori, 0xffffffff, 0xffffffff, 1  );
  TEST_IMM_OP( 9,  rori, 0xffffffff, 0xffffffff, 7  );
  TEST_IMM_OP( 10, rori, 0xffffffff, 0xffffffff, 14 );
  TEST_IMM_OP( 11, rori, 0xffffffff, 0xffffffff, 31 );

  TEST_IMM_OP( 12, rori, 0x21212121, 0x21212121, 0  );
  TEST_IMM_OP( 13, rori, 0x90909090, 0x21212121, 1  );
  TEST_IMM_OP( 14, rori, 0x42424242, 0x21212121, 7  );
  TEST_IMM_OP( 15, rori, 0x84848484, 0x21212121, 14 );
  TEST_IMM_OP( 16, rori, 0x42424242, 0x21212121, 31 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 20, rori, 0x02000000, 0x00000001, 7  );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 21, 0, rori, 0x02000000, 0x00000001, 7  );
  TEST_IMM_DEST_BYPASS( 22, 1, rori, 0x00040000, 0x00000001, 14 );
  TEST_IMM_DEST_BYPASS( 23, 2, rori, 0x00000002, 0x00000001, 31 );

  TEST_IMM_SRC1_BYPASS( 24, 0, rori, 0x02000000, 0x00000001, 7  );
  TEST_IMM_SRC1_BYPASS( 25, 1, rori, 0x00040000, 0x00000001, 14 );
  TEST_IMM_SRC1_BYPASS( 26, 2, rori, 0x00000002, 0x00000001, 31 );

  TEST_IMM_ZEROSRC1( 27, rori, 0, 31 );
  TEST_IMM_ZERODEST( 28, rori, 33, 20 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/xnor.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/min.S"
# See LICENSE for license details.

#*****************************************************************************
# ror.S
#-----------------------------------------------------------------------------
#
# Test ror instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  ror, 0x00000001, 0x00000001, 0  );
  TEST_RR_OP( 3,  ror, 0x80000000, 0x00000001, 1  );
  TEST_RR_OP( 4,  ror, 0x02000000, 0x00000001, 7  );
  TEST_RR_OP( 5,  ror, 0x00040000, 0x00000001, 14 );
  TEST_RR_OP( 6,  ror, 0x00000002, 0x00000001, 31 );

  TEST_RR_OP( 7,  ror, 0xffffffff, 0xffffffff, 0  );
  TEST_RR_OP( 8,  ror, 0xffffffff, 0xffffffff, 1  );
  TEST_RR_OP( 9,  ror, 0xffffffff, 0xffffffff, 7  );
  TEST_RR_OP( 10, ror, 0xffffffff, 0xffffffff, 14 );
  TEST_RR_OP( 11, ror, 0xffffffff, 0xffffffff, 31 );

  TEST_RR_OP( 12, ror, 0x21212121, 0x21212121, 0  );
  TEST_RR_OP( 13, ror, 0x90909090, 0x21212121, 1  );
  TEST_RR_OP( 14, ror, 0x42424242, 0x21212121, 7  );
  TEST_RR_OP( 15, ror, 0x84848484, 0x21212121, 14 );
  TEST_RR_OP( 16, ror, 0x42424242, 0x21212121, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, ror, 0x21212121, 0x21212121, 0xffffffc0 );
  TEST_RR_OP( 18, ror, 0x90909090, 0x21212121, 0xffffffc1 );
  TEST_RR_OP( 19, ror, 0x42424242, 0x21212121, 0xffffffc7 );
  TEST_RR_OP( 20, ror, 0x84848484, 0x21212121, 0xffffffce );

  TEST_RR_OP( 21, ror, 0x42424242, 0x21212121, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, ror, 0x02000000, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, ror, 0x00040000, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, ror, 0x60000000, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, ror, 0x02000000, 0x00000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, ror, 0x00040000, 0x00000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, ror, 0x00000002, 0x00000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, ror, 0x02000000, 0x00000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, ror, 0x00040000, 0x00000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, ror, 0x00000002, 0x00000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, ror, 0x02000000, 0x00000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, ror, 0x00040000, 0x00000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, ror, 0x00000002, 0x00000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, ror, 0x02000000, 0x00000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, ror, 0x00040000, 0x00000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, ror, 0x00000002, 0x00000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, ror, 0x02000000, 0x00000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, ror, 0x00040000, 0x00000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, ror, 0x00000002, 0x00000001, 31 );

  TEST_RR_ZEROSRC1( 40, ror, 0, 15 );
  TEST_RR_ZEROSRC2( 41, ror, 32, 32 );
  TEST_RR_ZEROSRC12( 42, ror, 0 );
  TEST_RR_ZERODEST( 43, ror, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rev8.S
#-----------------------------------------------------------------------------
#
# Test rev8 instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  rev8, 0x00000000, 0x00000000);
  TEST_R_OP( 3,  rev8, 0x01000000, 0x00000001);
  TEST_R_OP( 4,  rev8, 0x03000000, 0x00000003);

  TEST_R_OP( 5,  rev8, 0x0080ffff, 0xffff8000 );
  TEST_R_OP( 6,  rev8, 0x00008000, 0x00800000 );
  TEST_R_OP( 7,  rev8, 0x0080ffff, 0xffff8000 );

  TEST_R_OP( 8,  rev8, 0xff7f0000, 0x00007fff);
  TEST_R_OP( 9,  rev8, 0xffffff7f, 0x7fffffff);
  TEST_R_OP( 10, rev8, 0xffff0700, 0x0007ffff );

  TEST_R_OP( 11, rev8, 0x00000080, 0x80000000);
  TEST_R_OP( 12, rev8, 0x00501f12, 0x121f5000);

  TEST_R_OP( 13, rev8, 0x00000000, 0x00000000);
  TEST_R_OP( 14, rev8, 0x0e000000, 0x0000000e);
  TEST_R_OP( 15, rev8, 0x41134020, 0x20401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, rev8, 0x0d000000, 13);
  TEST_R_SRC1_EQ_DEST( 17, rev8, 0x0b000000, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, rev8, 0x0d000000, 13);
  TEST_R_DEST_BYPASS( 29, 1, rev8, 0x13000000, 19);
  TEST_R_DEST_BYPASS( 20, 2, rev8, 0x22000000, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  rev8, 0x00807f00, 0x007f8000 );
  TEST_R_OP( 22,  rev8, 0x00808000, 0x00808000 );
  TEST_R_OP( 23,  rev8, 0x00808001, 0x01808000 );

  TEST_R_OP( 24,  rev8, 0xff7f0000, 0x00007fff);
  TEST_R_OP( 25,  rev8, 0xffffff7f, 0x7fffffff);
  TEST_R_OP( 26,  rev8, 0xffff0700, 0x0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/andn.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/minu.S"
# See LICENSE for license details.

#*****************************************************************************
# clz.S
#-----------------------------------------------------------------------------
#
# Test clz instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  clz, 32, 0x00000000);
  TEST_R_OP( 3,  clz, 31, 0x00000001);
  TEST_R_OP( 4,  clz, 30, 0x00000003);

  TEST_R_OP( 5,  clz, 0, 0xffff8000 );
  TEST_R_OP( 6,  clz, 8, 0x00800000 );
  TEST_R_OP( 7,  clz, 0, 0xffff8000 );

  TEST_R_OP( 8,  clz, 17, 0x00007fff);
  TEST_R_OP( 9,  clz, 1, 0x7fffffff);
  TEST_R_OP( 10, clz, 13, 0x0007ffff );

  TEST_R_OP( 11, clz, 0, 0x80000000);
  TEST_R_OP( 12, clz, 3, 0x121f5000);

  TEST_R_OP( 13, clz, 5, 0x04000000);
  TEST_R_OP( 14, clz, 28, 0x0000000e);
  TEST_R_OP( 15, clz, 2, 0x20401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, clz, 28, 13);
  TEST_R_SRC1_EQ_DEST( 17, clz, 28, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, clz, 28, 13);
  TEST_R_DEST_BYPASS( 29, 1, clz, 27, 19);
  TEST_R_DEST_BYPASS( 20, 2, clz, 26, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------


  TEST_R_OP( 21, clz, 5, 0x070f8000 );
  TEST_R_OP( 22, clz, 4, 0x08008000 );
  TEST_R_OP( 23, clz, 3, 0x18008000 );

  TEST_R_OP( 24, clz, 17, 0x00007fff);
  TEST_R_OP( 25, clz, 1, 0x7fffffff);
  TEST_R_OP( 26, clz, 13, 0x0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ctz.S
#-----------------------------------------------------------------------------
#
# Test ctz instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  ctz, 32, 0x00000000);
  TEST_R_OP( 3,  ctz, 0, 0x00000001);
  TEST_R_OP( 4,  ctz, 0, 0x00000003);

  TEST_R_OP( 5,  ctz, 15, 0xffff8000 );
  TEST_R_OP( 6,  ctz, 23, 0x00800000 );
  TEST_R_OP( 7,  ctz, 15, 0xffff8000 );

  TEST_R_OP( 8,  ctz, 0, 0x00007fff);
  TEST_R_OP( 9,  ctz, 0, 0x7fffffff);
  TEST_R_OP( 10, ctz, 0, 0x0007ffff );

  TEST_R_OP( 11, ctz, 31, 0x80000000);
  TEST_R_OP( 12, ctz, 12, 0x121f5000);

  TEST_R_OP( 13, ctz, 30, 0xc0000000);
  TEST_R_OP( 14, ctz, 1, 0x0000000e);
  TEST_R_OP( 15, ctz, 0, 0x20401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, ctz, 0, 13);
  TEST_R_SRC1_EQ_DEST( 17, ctz, 0, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, ctz, 0, 13);
  TEST_R_DEST_BYPASS( 29, 1, ctz, 0, 19);
  TEST_R_DEST_BYPASS( 20, 2, ctz, 1, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  ctz, 15, 0x007f8000 );
  TEST_R_OP( 22,  ctz, 15, 0x00808000 );
  TEST_R_OP( 23,  ctz, 12, 0x01809000 );

  TEST_R_OP( 24,  ctz, 0, 0x00007fff);
  TEST_R_OP( 25,  ctz, 0, 0x7fffffff);
  TEST_R_OP( 26,  ctz, 0, 0x0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# cpop.S
#-----------------------------------------------------------------------------
#
# Test cpop instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  cpop, 0, 0x00000000);
  TEST_R_OP( 3,  cpop, 1, 0x00000001);
  TEST_R_OP( 4,  cpop, 2, 0x00000003);

  TEST_R_OP( 5,  cpop, 17, 0xffff8000 );
  TEST_R_OP( 6,  cpop, 1, 0x00800000 );
  TEST_R_OP( 7,  cpop, 18, 0xffff6000 );

  TEST_R_OP( 8,  cpop, 15, 0x00007fff);
  TEST_R_OP( 9,  cpop, 31, 0x7fffffff);
  TEST_R_OP( 10, cpop, 19, 0x0007ffff );

  TEST_R_OP( 11, cpop, 1, 0x80000000);
  TEST_R_OP( 12, cpop, 9, 0x121f5000);

  TEST_R_OP( 13, cpop, 0, 0x00000000);
  TEST_R_OP( 14, cpop, 3, 0x0000000e);
  TEST_R_OP( 15, cpop, 7, 0x20401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, cpop, 3, 13);
  TEST_R_SRC1_EQ_DEST( 17, cpop, 3, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, cpop, 3, 13);
  TEST_R_DEST_BYPASS( 29, 1, cpop, 3, 19);
  TEST_R_DEST_BYPASS( 20, 2, cpop, 2, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  cpop, 8, 0x007f8000 );
  TEST_R_OP( 22,  cpop, 2, 0x00808000 );
  TEST_R_OP( 23,  cpop, 3, 0x01808000 );

  TEST_R_OP( 24,  cpop, 17, 0x30007fff);
  TEST_R_OP( 25,  cpop, 30, 0x77ffffff);
  TEST_R_OP( 26,  cpop, 19, 0x0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rol.S
#-----------------------------------------------------------------------------
#
# Test rol instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  rol, 0x00000001, 0x00000001, 0  );
  TEST_RR_OP( 3,  rol, 0x00000002, 0x00000001, 1  );
  TEST_RR_OP( 4,  rol, 0x00000080, 0x00000001, 7  );
  TEST_RR_OP( 5,  rol, 0x00004000, 0x00000001, 14 );
  TEST_RR_OP( 6,  rol, 0x80000000, 0x00000001, 31 );

  TEST_RR_OP( 7,  rol, 0xffffffff, 0xffffffff, 0  );
  TEST_RR_OP( 8,  rol, 0xffffffff, 0xffffffff, 1  );
  TEST_RR_OP( 9,  rol, 0xffffffff, 0xffffffff, 7  );
  TEST_RR_OP( 10, rol, 0xffffffff, 0xffffffff, 14 );
  TEST_RR_OP( 11, rol, 0xffffffff, 0xffffffff, 31 );

  TEST_RR_OP( 12, rol, 0x21212121, 0x21212121, 0  );
  TEST_RR_OP( 13, rol, 0x42424242, 0x21212121, 1  );
  TEST_RR_OP( 14, rol, 0x90909090, 0x21212121, 7  );
  TEST_RR_OP( 15, rol, 0x48484848, 0x21212121, 14 );
  TEST_RR_OP( 16, rol, 0x90909090, 0x21212121, 31 );

  # Verify that rotates only use bottom five bits

  TEST_RR_OP( 17, rol, 0x21212121, 0x21212121, 0xffffffe0 );
  TEST_RR_OP( 18, rol, 0x42424242, 0x21212121, 0xffffffe1 );
  TEST_RR_OP( 19, rol, 0x90909090, 0x21212121, 0xffffffe7 );
  TEST_RR_OP( 20, rol, 0x48484848, 0x21212121, 0xffffffee );
  TEST_RR_OP( 21, rol, 0x90909090, 0x21212121, 0xffffffff );

  # Verify that rotates ignore top 32 (using true 64-bit values)

  TEST_RR_OP( 44, rol, 0x12345678, 0x12345678, 0 );
  TEST_RR_OP( 45, rol, 0x23456781, 0x12345678, 4 );
  TEST_RR_OP( 46, rol, 0x92345678, 0x92345678, 0 );
  TEST_RR_OP( 47, rol, 0x93456789, 0x99345678, 4 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, rol, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, rol, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, rol, 24, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, rol, 0x00000080, 0x00000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, rol, 0x00004000, 0x00000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, rol, 0x80000000, 0x00000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, rol, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, rol, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, rol, 0x80000000, 0x00000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, rol, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, rol, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, rol, 0x80000000, 0x00000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, rol, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, rol, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, rol, 0x80000000, 0x00000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, rol, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, rol, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, rol, 0x80000000, 0x00000001, 31 );

  TEST_RR_ZEROSRC1( 40, rol, 0, 15 );
  TEST_RR_ZEROSRC2( 41, rol, 32, 32 );
  TEST_RR_ZEROSRC12( 42, rol, 0 );
  TEST_RR_ZERODEST( 43, rol, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/max.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/maxu.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/orn.S"
# See LICENSE for license details.

#*****************************************************************************
# orc.b.S
#-----------------------------------------------------------------------------
#
# Test orc.b instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  orc.b, 0x00000000, 0x00000000);
  TEST_R_OP( 3,  orc.b, 0x000000ff, 0x00000001);
  TEST_R_OP( 4,  orc.b, 0x000000ff, 0x00000003);

  TEST_R_OP( 5,  orc.b, 0xffffff00, 0xffff8000 );
  TEST_R_OP( 6,  orc.b, 0x00ff0000, 0x00800000 );
  TEST_R_OP( 7,  orc.b, 0xffffff00, 0xffff8000 );

  TEST_R_OP( 8,  orc.b, 0x0000ffff, 0x00007fff);
  TEST_R_OP( 9,  orc.b, 0xffffffff, 0x7fffffff);
  TEST_R_OP( 10, orc.b, 0x00ffffff, 0x0007ffff );

  TEST_R_OP( 11, orc.b, 0xff000000, 0x80000000);
  TEST_R_OP( 12, orc.b, 0xffffff00, 0x121f5000);

  TEST_R_OP( 13, orc.b, 0x00000000, 0x00000000);
  TEST_R_OP( 14, orc.b, 0x000000ff, 0x0000000e);
  TEST_R_OP( 15, orc.b, 0xffffffff, 0x20401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, orc.b, 0xff, 13);
  TEST_R_SRC1_EQ_DEST( 17, orc.b, 0xff, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, orc.b, 0xff, 13);
  TEST_R_DEST_BYPASS( 29, 1, orc.b, 0xff, 19);
  TEST_R_DEST_BYPASS( 20, 2, orc.b, 0xff, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  orc.b, 0x00ffff00, 0x007f8000 );
  TEST_R_OP( 22,  orc.b, 0x00ffff00, 0x00808000 );
  TEST_R_OP( 23,  orc.b, 0xffffff00, 0x01808000 );

  TEST_R_OP( 24,  orc.b, 0x0000ffff, 0x00007fff);
  TEST_R_OP( 25,  orc.b, 0xffffffff, 0x7fffffff);
  TEST_R_OP( 26,  orc.b, 0x00ffffff, 0x0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/sext_h.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbb/sext_b.S"
# See LICENSE for license details.

#*****************************************************************************
# sh1add.S
#-----------------------------------------------------------------------------
#
# Test sh1add instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sh1add, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sh1add, 0x00000003, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sh1add, 0x0000000d, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  sh1add, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  sh1add, 0xffffffff00000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  sh1add, 0xfffffffeffff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  sh1add, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  sh1add, 0x00000000fffffffe, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, sh1add, 0x0000000100007ffd, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, sh1add, 0xffffffff00007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, sh1add, 0x00000000ffff7ffe, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, sh1add, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, sh1add, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, sh1add, 0xfffffffffffffffd, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, sh1add, 0x0000000080000001, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sh1add, 37, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, sh1add, 39, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, sh1add, 39, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sh1add, 37, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, sh1add, 39, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, sh1add, 41, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sh1add, 37, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sh1add, 39, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sh1add, 41, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sh1add, 37, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sh1add, 39, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sh1add, 41, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sh1add, 37, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sh1add, 39, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sh1add, 41, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sh1add, 37, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sh1add, 39, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sh1add, 41, 15, 11 );

  TEST_RR_ZEROSRC1( 35, sh1add, 15, 15 );
  TEST_RR_ZEROSRC2( 36, sh1add, 64, 32 );
  TEST_RR_ZEROSRC12( 37, sh1add, 0 );
  TEST_RR_ZERODEST( 38, sh1add, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sh1add.uw.S
#-----------------------------------------------------------------------------
#
# Test sh1add.uw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sh1add.uw, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sh1add.uw, 0x00000003, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sh1add.uw, 0x0000000d, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  sh1add.uw, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  sh1add.uw, 0x0000000100000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  sh1add.uw, 0x00000000ffff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  sh1add.uw, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  sh1add.uw, 0x00000000fffffffe, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, sh1add.uw, 0x0000000100007ffd, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, sh1add.uw, 0x0000000100007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, sh1add.uw, 0x00000000ffff7ffe, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, sh1add.uw, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, sh1add.uw, 0x00000001ffffffff, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, sh1add.uw, 0x00000001fffffffd, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, sh1add.uw, 0x0000000080000001, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sh1add.uw, 37, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, sh1add.uw, 39, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, sh1add.uw, 39, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sh1add.uw, 37, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, sh1add.uw, 39, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, sh1add.uw, 41, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sh1add.uw, 37, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sh1add.uw, 39, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sh1add.uw, 41, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sh1add.uw, 37, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sh1add.uw, 39, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sh1add.uw, 41, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sh1add.uw, 37, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sh1add.uw, 39, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sh1add.uw, 41, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sh1add.uw, 37, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sh1add.uw, 39, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sh1add.uw, 41, 15, 11 );

  TEST_RR_ZEROSRC1( 35, sh1add.uw, 15, 15 );
  TEST_RR_ZEROSRC2( 36, sh1add.uw, 64, 32 );
  TEST_RR_ZEROSRC12( 37, sh1add.uw, 0 );
  TEST_RR_ZERODEST( 38, sh1add.uw, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sh2add.S
#-----------------------------------------------------------------------------
#
# Test sh2add instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sh2add, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sh2add, 0x00000005, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sh2add, 0x00000013, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  sh2add, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  sh2add, 0xfffffffe00000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  sh2add, 0xfffffffdffff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  sh2add, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  sh2add, 0x00000001fffffffc, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, sh2add, 0x0000000200007ffb, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, sh2add, 0xfffffffe00007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, sh2add, 0x00000001ffff7ffc, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, sh2add, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, sh2add, 0xfffffffffffffffd, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, sh2add, 0xfffffffffffffffb, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, sh2add, 0x0000000080000003, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sh2add, 63, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, sh2add, 67, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, sh2add, 65, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sh2add, 63, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, sh2add, 67, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, sh2add, 71, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sh2add, 63, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sh2add, 67, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sh2add, 71, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sh2add, 63, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sh2add, 67, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sh2add, 71, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sh2add, 63, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sh2add, 67, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sh2add, 71, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sh2add, 63, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sh2add, 67, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sh2add, 71, 15, 11 );

  TEST_RR_ZEROSRC1( 35, sh2add, 15, 15 );
  TEST_RR_ZEROSRC2( 36, sh2add, 128, 32 );
  TEST_RR_ZEROSRC12( 37, sh2add, 0 );
  TEST_RR_ZERODEST( 38, sh2add, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sh3add.S
#-----------------------------------------------------------------------------
#
# Test sh3add instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sh3add, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sh3add, 0x00000009, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sh3add, 0x0000001f, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  sh3add, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  sh3add, 0xfffffffc00000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  sh3add, 0xfffffffbffff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  sh3add, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  sh3add, 0x00000003fffffff8, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, sh3add, 0x0000000400007ff7, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, sh3add, 0xfffffffc00007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, sh3add, 0x00000003ffff7ff8, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, sh3add, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, sh3add, 0xfffffffffffffff9, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, sh3add, 0xfffffffffffffff7, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, sh3add, 0x0000000080000007, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sh3add, 115, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, sh3add, 123, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, sh3add, 117, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sh3add, 115, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, sh3add, 123, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, sh3add, 131, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sh3add, 115, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sh3add, 123, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sh3add, 131, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sh3add, 115, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sh3add, 123, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sh3add, 131, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sh3add, 115, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sh3add, 123, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sh3add, 131, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sh3add, 115, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sh3add, 123, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sh3add, 131, 15, 11 );

  TEST_RR_ZEROSRC1( 35, sh3add, 15, 15 );
  TEST_RR_ZEROSRC2( 36, sh3add, 256, 32 );
  TEST_RR_ZEROSRC12( 37, sh3add, 0 );
  TEST_RR_ZERODEST( 38, sh3add, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sh2add.uw.S
#-----------------------------------------------------------------------------
#
# Test sh2add.uw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sh2add.uw, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sh2add.uw, 0x00000005, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sh2add.uw, 0x00000013, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  sh2add.uw, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  sh2add.uw, 0x0000000200000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  sh2add.uw, 0x00000001ffff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  sh2add.uw, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  sh2add.uw, 0x00000001fffffffc, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, sh2add.uw, 0x0000000200007ffb, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, sh2add.uw, 0x0000000200007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, sh2add.uw, 0x00000001ffff7ffc, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, sh2add.uw, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, sh2add.uw, 0x00000003fffffffd, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, sh2add.uw, 0x00000003fffffffb, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, sh2add.uw, 0x0000000080000003, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sh2add.uw, 63, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, sh2add.uw, 67, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, sh2add.uw, 65, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sh2add.uw, 63, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, sh2add.uw, 67, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, sh2add.uw, 71, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sh2add.uw, 63, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sh2add.uw, 67, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sh2add.uw, 71, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sh2add.uw, 63, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sh2add.uw, 67, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sh2add.uw, 71, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sh2add.uw, 63, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sh2add.uw, 67, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sh2add.uw, 71, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sh2add.uw, 63, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sh2add.uw, 67, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sh2add.uw, 71, 15, 11 );

  TEST_RR_ZEROSRC1( 35, sh2add.uw, 15, 15 );
  TEST_RR_ZEROSRC2( 36, sh2add.uw, 128, 32 );
  TEST_RR_ZEROSRC12( 37, sh2add.uw, 0 );
  TEST_RR_ZERODEST( 38, sh2add.uw, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# slli_uw.S
#-----------------------------------------------------------------------------
#
# Test slli.uw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  slli.uw, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_IMM_OP( 3,  slli.uw, 0x0000000000000002, 0x0000000000000001, 1  );
  TEST_IMM_OP( 4,  slli.uw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_OP( 5,  slli.uw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_OP( 6,  slli.uw, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_IMM_OP( 7,  slli.uw, 0x00000000ffffffff, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  slli.uw, 0x00000001fffffffe, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  slli.uw, 0x0000007fffffff80, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, slli.uw, 0x00003fffffffc000, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, slli.uw, 0x7fffffff80000000, 0xffffffffffffffff, 31 );

  TEST_IMM_OP( 12, slli.uw, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_IMM_OP( 13, slli.uw, 0x0000000042424242, 0x0000000021212121, 1  );
  TEST_IMM_OP( 14, slli.uw, 0x0000001090909080, 0x0000000021212121, 7  );
  TEST_IMM_OP( 15, slli.uw, 0x0000084848484000, 0x0000000021212121, 14 );
  TEST_IMM_OP( 16, slli.uw, 0x1090909080000000, 0x0000000021212121, 31 );

  TEST_IMM_OP( 50, slli.uw, 0x8000000000000000, 0x0000000000000001, 63 );
  TEST_IMM_OP( 51, slli.uw, 0xffffff8000000000, 0xffffffffffffffff, 39 );
  TEST_IMM_OP( 52, slli.uw, 0x0909080000000000, 0x0000000021212121, 43 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, slli.uw, 0x00000080, 0x00000001, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, slli.uw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, slli.uw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, slli.uw, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, slli.uw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_SRC1_BYPASS( 22, 1, slli.uw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, slli.uw, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_IMM_ZEROSRC1( 24, slli.uw, 0, 31 );
  TEST_IMM_ZERODEST( 25, slli.uw, 33, 20 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# add_uw.S
#-----------------------------------------------------------------------------
#
# Test add.uw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  add.uw, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  add.uw, 0x00000002, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  add.uw, 0x0000000a, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  add.uw, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  add.uw, 0x0000000080000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  add.uw, 0x000000007fff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  add.uw, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  add.uw, 0x000000007fffffff, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, add.uw, 0x0000000080007ffe, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, add.uw, 0x0000000080007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, add.uw, 0x000000007fff7fff, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, add.uw, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, add.uw, 0x0000000100000000, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, add.uw, 0x00000000fffffffe, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, add.uw, 0x0000000080000000, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, add.uw, 24, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, add.uw, 25, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, add.uw, 26, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, add.uw, 24, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, add.uw, 25, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, add.uw, 26, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, add.uw, 24, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, add.uw, 25, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, add.uw, 26, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, add.uw, 24, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, add.uw, 25, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, add.uw, 26, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, add.uw, 24, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, add.uw, 25, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, add.uw, 26, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, add.uw, 24, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, add.uw, 25, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, add.uw, 26, 15, 11 );

  TEST_RR_ZEROSRC1( 35, add.uw, 15, 15 );
  TEST_RR_ZEROSRC2( 36, add.uw, 32, 32 );
  TEST_RR_ZEROSRC12( 37, add.uw, 0 );
  TEST_RR_ZERODEST( 38, add.uw, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sh3add_uw.S
#-----------------------------------------------------------------------------
#
# Test sh3add.uw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sh3add.uw, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sh3add.uw, 0x00000009, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sh3add.uw, 0x0000001f, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  sh3add.uw, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  sh3add.uw, 0x0000000400000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  sh3add.uw, 0x00000003ffff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  sh3add.uw, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  sh3add.uw, 0x00000003fffffff8, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, sh3add.uw, 0x0000000400007ff7, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, sh3add.uw, 0x0000000400007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, sh3add.uw, 0x00000003ffff7ff8, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, sh3add.uw, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, sh3add.uw, 0x00000007fffffff9, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, sh3add.uw, 0x00000007fffffff7, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, sh3add.uw, 0x0000000080000007, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sh3add.uw, 115, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, sh3add.uw, 123, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, sh3add.uw, 117, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sh3add.uw, 115, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, sh3add.uw, 123, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, sh3add.uw, 131, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sh3add.uw, 115, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sh3add.uw, 123, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sh3add.uw, 131, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sh3add.uw, 115, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sh3add.uw, 123, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sh3add.uw, 131, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sh3add.uw, 115, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sh3add.uw, 123, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sh3add.uw, 131, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sh3add.uw, 115, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sh3add.uw, 123, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sh3add.uw, 131, 15, 11 );

  TEST_RR_ZEROSRC1( 35, sh3add.uw, 15, 15 );
  TEST_RR_ZEROSRC2( 36, sh3add.uw, 256, 32 );
  TEST_RR_ZEROSRC12( 37, sh3add.uw, 0 );
  TEST_RR_ZERODEST( 38, sh3add.uw, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/fence_i.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/beq.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/lbu.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/and.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/andi.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/jal.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/sh.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/sb.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/bgeu.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/simple.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/srli.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/auipc.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/ma_data.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/ld_st.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/lhu.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/xori.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/lui.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/slt.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/add.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/sw.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/sub.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/bltu.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/bge.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/sltiu.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/blt.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/jalr.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/sll.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/st_ld.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/srai.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/or.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/lw.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/ori.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/srl.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/bne.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/addi.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/sltu.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/lb.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/lh.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/sra.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/slli.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/xor.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ui/slti.S"
# See LICENSE for license details.

#*****************************************************************************
# clmulh.S
#-----------------------------------------------------------------------------
#
# Test clmulh instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP(32,  clmulh, 0x00003600, 0x00007e00, 0xb6db6db7 );
  TEST_RR_OP(33,  clmulh, 0x000036c0, 0x00007fc0, 0xb6db6db7 );

  TEST_RR_OP( 2,  clmulh, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  clmulh, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  clmulh, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  clmulh, 0x00000000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  clmulh, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  clmulh, 0x7fffc000, 0x80000000, 0xffff8000 );

  TEST_RR_OP(30,  clmulh, 0x000133cd, 0xaaaaaaab, 0x0002fe7d );
  TEST_RR_OP(31,  clmulh, 0x000133cd, 0x0002fe7d, 0xaaaaaaab );

  TEST_RR_OP(34,  clmulh, 0x55550000, 0xff000000, 0xff000000 );

  TEST_RR_OP(35,  clmulh, 0x55555555, 0xffffffff, 0xffffffff );
  TEST_RR_OP(36,  clmulh, 0x00000000, 0xffffffff, 0x00000001 );
  TEST_RR_OP(37,  clmulh, 0x00000000, 0x00000001, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, clmulh, 0, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 9, clmulh, 0, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 10, clmulh, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, clmulh, 0, 13, 11 );
  TEST_RR_DEST_BYPASS( 12, 1, clmulh, 0, 14, 11 );
  TEST_RR_DEST_BYPASS( 13, 2, clmulh, 0, 15, 11 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, clmulh, 0, 13, 11 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, clmulh, 0, 14, 11 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, clmulh, 0, 15, 11 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, clmulh, 0, 13, 11 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, clmulh, 0, 14, 11 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, clmulh, 0, 15, 11 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, clmulh, 0, 13, 11 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, clmulh, 0, 14, 11 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, clmulh, 0, 15, 11 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, clmulh, 0, 13, 11 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, clmulh, 0, 14, 11 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, clmulh, 0, 15, 11 );

  TEST_RR_ZEROSRC1( 26, clmulh, 0, 31 );
  TEST_RR_ZEROSRC2( 27, clmulh, 0, 32 );
  TEST_RR_ZEROSRC12( 28, clmulh, 0 );
  TEST_RR_ZERODEST( 29, clmulh, 33, 34 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# clmulr.S
#-----------------------------------------------------------------------------
#
# Test clmulr instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP(32,  clmulr, 0x00006c00, 0x00007e00, 0xb6db6db7 );
  TEST_RR_OP(33,  clmulr, 0x00006d80, 0x00007fc0, 0xb6db6db7 );

  TEST_RR_OP( 2,  clmulr, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  clmulr, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  clmulr, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  clmulr, 0x00000000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  clmulr, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  clmulr, 0xffff8000, 0x80000000, 0xffff8000 );

  TEST_RR_OP(30,  clmulr, 0x0002679b, 0xaaaaaaab, 0x0002fe7d );
  TEST_RR_OP(31,  clmulr, 0x0002679b, 0x0002fe7d, 0xaaaaaaab );

  TEST_RR_OP(34,  clmulr, 0xaaaa0000, 0xff000000, 0xff000000 );

  TEST_RR_OP(35,  clmulr, 0xaaaaaaaa, 0xffffffff, 0xffffffff );
  TEST_RR_OP(36,  clmulr, 0x00000001, 0xffffffff, 0x00000001 );
  TEST_RR_OP(37,  clmulr, 0x00000001, 0x00000001, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, clmulr, 0, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 9, clmulr, 0, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 10, clmulr, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, clmulr, 0, 13, 11 );
  TEST_RR_DEST_BYPASS( 12, 1, clmulr, 0, 14, 11 );
  TEST_RR_DEST_BYPASS( 13, 2, clmulr, 0, 15, 11 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, clmulr, 0, 13, 11 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, clmulr, 0, 14, 11 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, clmulr, 0, 15, 11 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, clmulr, 0, 13, 11 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, clmulr, 0, 14, 11 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, clmulr, 0, 15, 11 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, clmulr, 0, 13, 11 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, clmulr, 0, 14, 11 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, clmulr, 0, 15, 11 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, clmulr, 0, 13, 11 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, clmulr, 0, 14, 11 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, clmulr, 0, 15, 11 );

  TEST_RR_ZEROSRC1( 26, clmulr, 0, 31 );
  TEST_RR_ZEROSRC2( 27, clmulr, 0, 32 );
  TEST_RR_ZEROSRC12( 28, clmulr, 0 );
  TEST_RR_ZERODEST( 29, clmulr, 33, 34 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# clmul.S
#-----------------------------------------------------------------------------
#
# Test clmul instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP(32,  clmul, 0x00005a00, 0x00007e00, 0xb6db6db7 );
  TEST_RR_OP(33,  clmul, 0x00005b40, 0x00007fc0, 0xb6db6db7 );

  TEST_RR_OP( 2,  clmul, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  clmul, 0x00000001, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  clmul, 0x00000009, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  clmul, 0x00000000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  clmul, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  clmul, 0x00000000, 0x80000000, 0xffff8000 );

  TEST_RR_OP(30,  clmul, 0xfffc324f, 0xaaaaaaab, 0x0002fe7d );
  TEST_RR_OP(31,  clmul, 0xfffc324f, 0x0002fe7d, 0xaaaaaaab );

  TEST_RR_OP(34,  clmul, 0x00000000, 0xff000000, 0xff000000 );

  TEST_RR_OP(35,  clmul, 0x55555555, 0xffffffff, 0xffffffff );
  TEST_RR_OP(36,  clmul, 0xffffffff, 0xffffffff, 0x00000001 );
  TEST_RR_OP(37,  clmul, 0xffffffff, 0x00000001, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 9, clmul, 0x62, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 10, clmul, 0x51, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_DEST_BYPASS( 12, 1, clmul, 0x62, 14, 11 );
  TEST_RR_DEST_BYPASS( 13, 2, clmul, 0x69, 15, 11 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, clmul, 0x62, 14, 11 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, clmul, 0x69, 15, 11 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, clmul, 0x62, 14, 11 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, clmul, 0x69, 15, 11 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, clmul, 0x62, 14, 11 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, clmul, 0x69, 15, 11 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, clmul, 0x62, 14, 11 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, clmul, 0x69, 15, 11 );

  TEST_RR_ZEROSRC1( 26, clmul, 0, 31 );
  TEST_RR_ZEROSRC2( 27, clmul, 0, 32 );
  TEST_RR_ZEROSRC12( 28, clmul, 0 );
  TEST_RR_ZERODEST( 29, clmul, 33, 34 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/fcvt.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/fdiv.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/fmadd.S"
# See LICENSE for license details.

#*****************************************************************************
# ldst.S
#-----------------------------------------------------------------------------
#
# This test verifies that flw, fld, fsw, and fsd work properly.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32UF
RVTEST_CODE_BEGIN

  TEST_CASE(2, a0, 0x40000000, la a1, tdat; flw f1, 4(a1); fsw f1, 20(a1); lw a0, 20(a1))
  TEST_CASE(3, a0, 0xbf800000, la a1, tdat; flw f1, 0(a1); fsw f1, 24(a1); lw a0, 24(a1))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
.word 0xbf800000
.word 0x40000000
.word 0x40400000
.word 0xc0800000
.word 0xdeadbeef
.word 0xcafebabe
.word 0xabad1dea
.word 0x1337d00d

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/fmin.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/recoding.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/fclass.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/fcmp.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/fadd.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/move.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uf/fcvt_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/amoor_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/amomax_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/amoswap_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/lrsc.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/amomaxu_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/amoand_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/amoxor_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/amominu_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/amoadd_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64ua/amomin_w.S"
# See LICENSE for license details.

#*****************************************************************************
# napot.S
#-----------------------------------------------------------------------------
#
# Test Svnapot
#

#include "riscv_test.h"
#include "test_macros.h"

#if (DRAM_BASE >> 30 << 30) != DRAM_BASE
# error This test requires DRAM_BASE be SV39 superpage-aligned
#endif

#if __riscv_xlen != 64
# error This test requires RV64
#endif

RVTEST_RV64M
RVTEST_CODE_BEGIN

  # Construct the page table

#define MY_VA 0x40201010
  # VPN 2 == VPN 1 == VPN 0 == 0x1
  # Page offset == 0x10

  ####

  # Level 0 PTE contents

  # PPN
  la a0, my_data
  srl a0, a0, 12

  # adjust the PPN to be in NAPOT form
  li a1, ~0xF
  and a0, a0, a1
  ori a0, a0, 0x8

  # attributes
  sll a0, a0, PTE_PPN_SHIFT
  li a1, PTE_V | PTE_U | PTE_R | PTE_W | PTE_X | PTE_A | PTE_D | PTE_N
  or a0, a0, a1

  # Level 0 PTE address
  la a1, page_table
  addi a1, a1, ((MY_VA >> 12) & 0x1FF) * 8

  # Level 0 PTE store
  sd a0, (a1)

  ####

  # Level 1 PTE contents
  la a0, page_table
  srl a0, a0, 12
  sll a0, a0, PTE_PPN_SHIFT
  li a1, PTE_V
  or a0, a0, a1

  # Level 1 PTE address
  la a1, page_table
  addi a1, a1, ((MY_VA >> 21) & 0x1FF) * 8
  li a2, 1 << 12
  add a1, a1, a2

  # Level 1 PTE store
  sd a0, (a1)

  ####

  # Level 2 PTE contents
  la a0, page_table
  li a1, 1 << 12
  add a0, a0, a1
  srl a0, a0, 12
  sll a0, a0, PTE_PPN_SHIFT
  li a1, PTE_V
  or a0, a0, a1

  # Level 2 PTE address
  la a1, page_table
  addi a1, a1, ((MY_VA >> 30) & 0x1FF) * 8
  li a2, 2 << 12
  add a1, a1, a2

  # Level 2 PTE store
  sd a0, (a1)

  ####

  # Do a load from the PA that would be written if the PTE were misinterpreted as non-NAPOT
  la a0, my_data
  li a1, ~0xFFFF
  and a0, a0, a1
  li a1, 0x8000 | (MY_VA & 0xFFF)
  or a3, a0, a1
  li a1, 0
  sw a1, (a3)

  ####
  li TESTNUM, 1

  ## Turn on VM
  la a1, page_table
  li a2, 2 << 12
  add a1, a1, a2
  srl a1, a1, 12
  li a0, (SATP_MODE & ~(SATP_MODE<<1)) * SATP_MODE_SV39
  or a0, a0, a1
  csrw satp, a0
  sfence.vma

  # Set up MPRV with MPP=S and SUM=1, so loads and stores use S-mode and S can access U pages
  li a1, ((MSTATUS_MPP & ~(MSTATUS_MPP<<1)) * PRV_S) | MSTATUS_MPRV | MSTATUS_SUM
  csrs mstatus, a1

  # Do a store to MY_VA
  li a0, MY_VA
  li a1, 42
napot_store:
  sw a1, (a0)

  # Clear MPRV
  li a1, MSTATUS_MPRV
  csrc mstatus, a1

  # Do a load from the PA that would be written if the PTE were misinterpreted as non-NAPOT
  lw a1, (a3)

  # Check the result
  li a0, 42
  beq a1, a0, die

  # Do a load from the PA for MY_VA
  la a0, my_data
  li a1, MY_VA & 0xFFFF
  add a0, a0, a1
  lw a1, (a0)
  li a2, 42

  # Check the result
  bne a1, a2, die

  ####

  RVTEST_PASS

  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  # Skip if Svnapot is not implemented.
  csrr t5, mcause
  li t6, CAUSE_STORE_PAGE_FAULT
  bne t5, t6, die
  csrr t5, mepc
  la t6, napot_store
  bne t5, t6, die
  csrr t5, mtval
  li t6, MY_VA
  beq t5, t6, pass
die:
  RVTEST_FAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

.align 20
page_table: .dword 0

.align 20
my_data: .dword 0

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uzfh/fcvt.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UH
#define RVTEST_RV64UH RVTEST_RV32UH

#include "../rv64uzfh/fdiv.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UH
#define RVTEST_RV64UH RVTEST_RV32UH

#include "../rv64uzfh/fmadd.S"
# See LICENSE for license details.

#*****************************************************************************
# ldst.S
#-----------------------------------------------------------------------------
#
# This test verifies that flw, fld, fsw, and fsd work properly.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32UF
RVTEST_CODE_BEGIN

  TEST_CASE(2, a0, 0xcafe4000, la a1, tdat; flh f1, 4(a1); fsh f1, 20(a1); lw a0, 20(a1))
  TEST_CASE(3, a0, 0xabadbf80, la a1, tdat; flh f1, 0(a1); fsh f1, 24(a1); lw a0, 24(a1))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
.word 0xbf80bf80
.word 0x40004000
.word 0x40404040
.word 0xc080c080
.word 0xdeadbeef
.word 0xcafebabe
.word 0xabad1dea
.word 0x1337d00d

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UH
#define RVTEST_RV64UH RVTEST_RV32UH

#include "../rv64uzfh/fmin.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UH
#define RVTEST_RV64UH RVTEST_RV32UH

#include "../rv64uzfh/recoding.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UH
#define RVTEST_RV64UH RVTEST_RV32UH

#include "../rv64uzfh/fclass.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UH
#define RVTEST_RV64UH RVTEST_RV32UH

#include "../rv64uzfh/fcmp.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UH
#define RVTEST_RV64UH RVTEST_RV32UH

#include "../rv64uzfh/fadd.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UH
#define RVTEST_RV64UH RVTEST_RV32UH

#include "../rv64uzfh/move.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64uzfh/fcvt_w.S"
# See LICENSE for license details.

#*****************************************************************************
# fcvt.S
#-----------------------------------------------------------------------------
#
# Test fcvt.s.{wu|w|lu|l}, fcvt.s.d, and fcvt.d.s instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_INT_FP_OP_S( 2,  fcvt.s.w,                   2.0,  2);
  TEST_INT_FP_OP_S( 3,  fcvt.s.w,                  -2.0, -2);

  TEST_INT_FP_OP_S( 4, fcvt.s.wu,                   2.0,  2);
  TEST_INT_FP_OP_S( 5, fcvt.s.wu,           4.2949673e9, -2);

#if __riscv_xlen >= 64
  TEST_INT_FP_OP_S( 6,  fcvt.s.l,                   2.0,  2);
  TEST_INT_FP_OP_S( 7,  fcvt.s.l,                  -2.0, -2);

  TEST_INT_FP_OP_S( 8, fcvt.s.lu,                   2.0,  2);
  TEST_INT_FP_OP_S( 9, fcvt.s.lu,          1.8446744e19, -2);
#endif

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fdiv.S
#-----------------------------------------------------------------------------
#
# Test f{div|sqrt}.s instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP2_S(2,  fdiv.s, 1, 1.1557273520668288, 3.14159265, 2.71828182 );
  TEST_FP_OP2_S(3,  fdiv.s, 1,-0.9991093838555584,      -1234,     1235.1 );
  TEST_FP_OP2_S(4,  fdiv.s, 0,         3.14159265, 3.14159265,        1.0 );

  TEST_FP_OP1_S(5,  fsqrt.s, 1, 1.7724538498928541, 3.14159265 );
  TEST_FP_OP1_S(6,  fsqrt.s, 0,                100,      10000 );

  TEST_FP_OP1_S_DWORD_RESULT(7,  fsqrt.s, 0x10, 0x7FC00000, -1.0 );

  TEST_FP_OP1_S(8,  fsqrt.s, 1, 13.076696, 171.0);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fmadd.S
#-----------------------------------------------------------------------------
#
# Test f[n]m{add|sub}.s and f[n]m{add|sub}.d instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP3_S( 2,  fmadd.s, 0,                 3.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_S( 3,  fmadd.s, 1,              1236.2, -1.0,    -1235.1,        1.1 );
  TEST_FP_OP3_S( 4,  fmadd.s, 0,               -12.0,  2.0,       -5.0,       -2.0 );

  TEST_FP_OP3_S( 5, fnmadd.s, 0,                -3.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_S( 6, fnmadd.s, 1,             -1236.2, -1.0,    -1235.1,        1.1 );
  TEST_FP_OP3_S( 7, fnmadd.s, 0,                12.0,  2.0,       -5.0,       -2.0 );

  TEST_FP_OP3_S( 8,  fmsub.s, 0,                 1.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_S( 9,  fmsub.s, 1,                1234, -1.0,    -1235.1,        1.1 );
  TEST_FP_OP3_S(10,  fmsub.s, 0,                -8.0,  2.0,       -5.0,       -2.0 );

  TEST_FP_OP3_S(11, fnmsub.s, 0,                -1.5,  1.0,        2.5,        1.0 );
  TEST_FP_OP3_S(12, fnmsub.s, 1,               -1234, -1.0,    -1235.1,        1.1 );
  TEST_FP_OP3_S(13, fnmsub.s, 0,                 8.0,  2.0,       -5.0,       -2.0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ldst.S
#-----------------------------------------------------------------------------
#
# This test verifies that flw, fld, fsw, and fsd work properly.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  TEST_CASE(2, a0, 0x40000000deadbeef, la a1, tdat; flw f1, 4(a1); fsw f1, 20(a1); ld a0, 16(a1))
  TEST_CASE(3, a0, 0x1337d00dbf800000, la a1, tdat; flw f1, 0(a1); fsw f1, 24(a1); ld a0, 24(a1))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
.word 0xbf800000
.word 0x40000000
.word 0x40400000
.word 0xc0800000
.word 0xdeadbeef
.word 0xcafebabe
.word 0xabad1dea
.word 0x1337d00d

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fmin.S
#-----------------------------------------------------------------------------
#
# Test f{min|max}.s instructinos.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP2_S( 2,  fmin.s, 0,        1.0,        2.5,        1.0 );
  TEST_FP_OP2_S( 3,  fmin.s, 0,    -1235.1,    -1235.1,        1.1 );
  TEST_FP_OP2_S( 4,  fmin.s, 0,    -1235.1,        1.1,    -1235.1 );
  TEST_FP_OP2_S( 5,  fmin.s, 0,    -1235.1,        NaN,    -1235.1 );
  TEST_FP_OP2_S( 6,  fmin.s, 0, 0.00000001, 3.14159265, 0.00000001 );
  TEST_FP_OP2_S( 7,  fmin.s, 0,       -2.0,       -1.0,       -2.0 );

  TEST_FP_OP2_S(12,  fmax.s, 0,        2.5,        2.5,        1.0 );
  TEST_FP_OP2_S(13,  fmax.s, 0,        1.1,    -1235.1,        1.1 );
  TEST_FP_OP2_S(14,  fmax.s, 0,        1.1,        1.1,    -1235.1 );
  TEST_FP_OP2_S(15,  fmax.s, 0,    -1235.1,        NaN,    -1235.1 );
  TEST_FP_OP2_S(16,  fmax.s, 0, 3.14159265, 3.14159265, 0.00000001 );
  TEST_FP_OP2_S(17,  fmax.s, 0,       -1.0,       -1.0,       -2.0 );

  # FMAX(sNaN, x) = x
  TEST_FP_OP2_S_HEX(20,  fmax.s, 0x10, 0x3f800000, 0x7f800001, 0x3f800000);
  # FMAX(qNaN, qNaN) = canonical NaN
  TEST_FP_OP2_S_HEX(21,  fmax.s, 0x00, 0x7fc00000, 0x7fffffff, 0x7fffffff);

  # -0.0 < +0.0
  TEST_FP_OP2_S(30,  fmin.s, 0,       -0.0,       -0.0,        0.0 );
  TEST_FP_OP2_S(31,  fmin.s, 0,       -0.0,        0.0,       -0.0 );
  TEST_FP_OP2_S(32,  fmax.s, 0,        0.0,       -0.0,        0.0 );
  TEST_FP_OP2_S(33,  fmax.s, 0,        0.0,        0.0,       -0.0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# recoding.S
#-----------------------------------------------------------------------------
#
# Test corner cases of John Hauser's microarchitectural recoding scheme.
# There are twice as many recoded values as IEEE-754 values; some of these
# extras are redundant (e.g. Inf) and others are illegal (subnormals with
# too many bits set).
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  # Make sure infinities with different mantissas compare as equal.
  flw f0, minf, a0
  flw f1, three, a0
  fmul.s f1, f1, f0
  TEST_CASE( 2, a0, 1, feq.s a0, f0, f1)
  TEST_CASE( 3, a0, 1, fle.s a0, f0, f1)
  TEST_CASE( 4, a0, 0, flt.s a0, f0, f1)

  # Likewise, but for zeroes.
  fcvt.s.w f0, x0
  li a0, 1
  fcvt.s.w f1, a0
  fmul.s f1, f1, f0
  TEST_CASE(5, a0, 1, feq.s a0, f0, f1)
  TEST_CASE(6, a0, 1, fle.s a0, f0, f1)
  TEST_CASE(7, a0, 0, flt.s a0, f0, f1)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

minf: .float -Inf
three: .float 3.0

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fclass.S
#-----------------------------------------------------------------------------
#
# Test fclass.s instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FCLASS_S( 2, 1 << 0, 0xff800000 )
  TEST_FCLASS_S( 3, 1 << 1, 0xbf800000 )
  TEST_FCLASS_S( 4, 1 << 2, 0x807fffff )
  TEST_FCLASS_S( 5, 1 << 3, 0x80000000 )
  TEST_FCLASS_S( 6, 1 << 4, 0x00000000 )
  TEST_FCLASS_S( 7, 1 << 5, 0x007fffff )
  TEST_FCLASS_S( 8, 1 << 6, 0x3f800000 )
  TEST_FCLASS_S( 9, 1 << 7, 0x7f800000 )
  TEST_FCLASS_S(10, 1 << 8, 0x7f800001 )
  TEST_FCLASS_S(11, 1 << 9, 0x7fc00000 )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fcmp.S
#-----------------------------------------------------------------------------
#
# Test f{eq|lt|le}.s instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_CMP_OP_S( 2, feq.s, 0x00, 1, -1.36, -1.36)
  TEST_FP_CMP_OP_S( 3, fle.s, 0x00, 1, -1.36, -1.36)
  TEST_FP_CMP_OP_S( 4, flt.s, 0x00, 0, -1.36, -1.36)

  TEST_FP_CMP_OP_S( 5, feq.s, 0x00, 0, -1.37, -1.36)
  TEST_FP_CMP_OP_S( 6, fle.s, 0x00, 1, -1.37, -1.36)
  TEST_FP_CMP_OP_S( 7, flt.s, 0x00, 1, -1.37, -1.36)

  # Only sNaN should signal invalid for feq.
  TEST_FP_CMP_OP_S( 8, feq.s, 0x00, 0, NaN, 0)
  TEST_FP_CMP_OP_S( 9, feq.s, 0x00, 0, NaN, NaN)
  TEST_FP_CMP_OP_S_HEX(10, feq.s, 0x10, 0, 0x7f800001, 0)

  # qNaN should signal invalid for fle/flt.
  TEST_FP_CMP_OP_S(11, flt.s, 0x10, 0, NaN, 0)
  TEST_FP_CMP_OP_S(12, flt.s, 0x10, 0, NaN, NaN)
  TEST_FP_CMP_OP_S_HEX(13, flt.s, 0x10, 0, 0x7f800001, 0)
  TEST_FP_CMP_OP_S(14, fle.s, 0x10, 0, NaN, 0)
  TEST_FP_CMP_OP_S(15, fle.s, 0x10, 0, NaN, NaN)
  TEST_FP_CMP_OP_S_HEX(16, fle.s, 0x10, 0, 0x7f800001, 0)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fadd.S
#-----------------------------------------------------------------------------
#
# Test f{add|sub|mul}.s instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_OP2_S( 2,  fadd.s, 0,                3.5,        2.5,        1.0 );
  TEST_FP_OP2_S( 3,  fadd.s, 1,              -1234,    -1235.1,        1.1 );
  TEST_FP_OP2_S( 4,  fadd.s, 1,         3.14159265, 3.14159265, 0.00000001 );

  TEST_FP_OP2_S( 5,  fsub.s, 0,                1.5,        2.5,        1.0 );
  TEST_FP_OP2_S( 6,  fsub.s, 1,              -1234,    -1235.1,       -1.1 );
  TEST_FP_OP2_S( 7,  fsub.s, 1,         3.14159265, 3.14159265, 0.00000001 );

  TEST_FP_OP2_S( 8,  fmul.s, 0,                2.5,        2.5,        1.0 );
  TEST_FP_OP2_S( 9,  fmul.s, 1,            1358.61,    -1235.1,       -1.1 );
  TEST_FP_OP2_S(10,  fmul.s, 1,      3.14159265e-8, 3.14159265, 0.00000001 );

  # Is the canonical NaN generated for Inf - Inf?
  TEST_FP_OP2_S_HEX(11,  fsub.s, 0x10, 0x7fc00000, 0x7f800000, 0x7f800000);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# move.S
#-----------------------------------------------------------------------------
#
# This test verifies that the fmv.s.x, fmv.x.s, and fsgnj[x|n].d instructions
# and the fcsr work properly.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  TEST_CASE(2, a1, 1, csrwi fcsr, 1; li a0, 0x1234; fssr a1, a0)
  TEST_CASE(3, a0, 0x34, frsr a0)
  TEST_CASE(4, a0, 0x14, frflags a0)
  TEST_CASE(5, a0, 0x01, csrrwi a0, frm, 2)
  TEST_CASE(6, a0, 0x54, frsr a0)
  TEST_CASE(7, a0, 0x14, csrrci a0, fflags, 4)
  TEST_CASE(8, a0, 0x50, frsr a0)

#define TEST_FSGNJS(n, insn, new_sign, rs1_sign, rs2_sign) \
  TEST_CASE(n, a0, 0x12345678 | (-(new_sign) << 31), \
    li a1, ((rs1_sign) << 31) | 0x12345678; \
    li a2, -(rs2_sign); \
    fmv.s.x f1, a1; \
    fmv.s.x f2, a2; \
    insn f0, f1, f2; \
    fmv.x.s a0, f0)

  TEST_FSGNJS(10, fsgnj.s, 0, 0, 0)
  TEST_FSGNJS(11, fsgnj.s, 1, 0, 1)
  TEST_FSGNJS(12, fsgnj.s, 0, 1, 0)
  TEST_FSGNJS(13, fsgnj.s, 1, 1, 1)

  TEST_FSGNJS(20, fsgnjn.s, 1, 0, 0)
  TEST_FSGNJS(21, fsgnjn.s, 0, 0, 1)
  TEST_FSGNJS(22, fsgnjn.s, 1, 1, 0)
  TEST_FSGNJS(23, fsgnjn.s, 0, 1, 1)

  TEST_FSGNJS(30, fsgnjx.s, 0, 0, 0)
  TEST_FSGNJS(31, fsgnjx.s, 1, 0, 1)
  TEST_FSGNJS(32, fsgnjx.s, 1, 1, 0)
  TEST_FSGNJS(33, fsgnjx.s, 0, 1, 1)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# fcvt_w.S
#-----------------------------------------------------------------------------
#
# Test fcvt{wu|w|lu|l}.s instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64UF
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_FP_INT_OP_S( 2,  fcvt.w.s, 0x01,         -1, -1.1, rtz);
  TEST_FP_INT_OP_S( 3,  fcvt.w.s, 0x00,         -1, -1.0, rtz);
  TEST_FP_INT_OP_S( 4,  fcvt.w.s, 0x01,          0, -0.9, rtz);
  TEST_FP_INT_OP_S( 5,  fcvt.w.s, 0x01,          0,  0.9, rtz);
  TEST_FP_INT_OP_S( 6,  fcvt.w.s, 0x00,          1,  1.0, rtz);
  TEST_FP_INT_OP_S( 7,  fcvt.w.s, 0x01,          1,  1.1, rtz);
  TEST_FP_INT_OP_S( 8,  fcvt.w.s, 0x10,     -1<<31, -3e9, rtz);
  TEST_FP_INT_OP_S( 9,  fcvt.w.s, 0x10,  (1<<31)-1,  3e9, rtz);

  TEST_FP_INT_OP_S(12, fcvt.wu.s, 0x10,          0, -3.0, rtz);
  TEST_FP_INT_OP_S(13, fcvt.wu.s, 0x10,          0, -1.0, rtz);
  TEST_FP_INT_OP_S(14, fcvt.wu.s, 0x01,          0, -0.9, rtz);
  TEST_FP_INT_OP_S(15, fcvt.wu.s, 0x01,          0,  0.9, rtz);
  TEST_FP_INT_OP_S(16, fcvt.wu.s, 0x00,          1,  1.0, rtz);
  TEST_FP_INT_OP_S(17, fcvt.wu.s, 0x01,          1,  1.1, rtz);
  TEST_FP_INT_OP_S(18, fcvt.wu.s, 0x10,          0, -3e9, rtz);
  TEST_FP_INT_OP_S(19, fcvt.wu.s, 0x00, 3000000000,  3e9, rtz);

#if __riscv_xlen >= 64
  TEST_FP_INT_OP_S(22,  fcvt.l.s, 0x01,         -1, -1.1, rtz);
  TEST_FP_INT_OP_S(23,  fcvt.l.s, 0x00,         -1, -1.0, rtz);
  TEST_FP_INT_OP_S(24,  fcvt.l.s, 0x01,          0, -0.9, rtz);
  TEST_FP_INT_OP_S(25,  fcvt.l.s, 0x01,          0,  0.9, rtz);
  TEST_FP_INT_OP_S(26,  fcvt.l.s, 0x00,          1,  1.0, rtz);
  TEST_FP_INT_OP_S(27,  fcvt.l.s, 0x01,          1,  1.1, rtz);

  TEST_FP_INT_OP_S(32, fcvt.lu.s, 0x10,          0, -3.0, rtz);
  TEST_FP_INT_OP_S(33, fcvt.lu.s, 0x10,          0, -1.0, rtz);
  TEST_FP_INT_OP_S(34, fcvt.lu.s, 0x01,          0, -0.9, rtz);
  TEST_FP_INT_OP_S(35, fcvt.lu.s, 0x01,          0,  0.9, rtz);
  TEST_FP_INT_OP_S(36, fcvt.lu.s, 0x00,          1,  1.0, rtz);
  TEST_FP_INT_OP_S(37, fcvt.lu.s, 0x01,          1,  1.1, rtz);
  TEST_FP_INT_OP_S(38, fcvt.lu.s, 0x10,          0, -3e9, rtz);
#endif

  # test negative NaN, negative infinity conversion
  TEST_CASE( 42, x1, 0x000000007fffffff, la x1, tdat  ; flw f1,  0(x1); fcvt.w.s x1, f1)
  TEST_CASE( 44, x1, 0xffffffff80000000, la x1, tdat  ; flw f1,  8(x1); fcvt.w.s x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE( 43, x1, 0x7fffffffffffffff, la x1, tdat  ; flw f1,  0(x1); fcvt.l.s x1, f1)
  TEST_CASE( 45, x1, 0x8000000000000000, la x1, tdat  ; flw f1,  8(x1); fcvt.l.s x1, f1)
#endif

  # test positive NaN, positive infinity conversion
  TEST_CASE( 52, x1, 0x000000007fffffff, la x1, tdat  ; flw f1,  4(x1); fcvt.w.s x1, f1)
  TEST_CASE( 54, x1, 0x000000007fffffff, la x1, tdat  ; flw f1, 12(x1); fcvt.w.s x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE( 53, x1, 0x7fffffffffffffff, la x1, tdat  ; flw f1,  4(x1); fcvt.l.s x1, f1)
  TEST_CASE( 55, x1, 0x7fffffffffffffff, la x1, tdat  ; flw f1, 12(x1); fcvt.l.s x1, f1)
#endif

  # test NaN, infinity conversions to unsigned integer
  TEST_CASE( 62, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1,  0(x1); fcvt.wu.s x1, f1)
  TEST_CASE( 63, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1,  4(x1); fcvt.wu.s x1, f1)
  TEST_CASE( 64, x1,                  0, la x1, tdat  ; flw f1,  8(x1); fcvt.wu.s x1, f1)
  TEST_CASE( 65, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1, 12(x1); fcvt.wu.s x1, f1)
#if __riscv_xlen >= 64
  TEST_CASE( 66, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1,  0(x1); fcvt.lu.s x1, f1)
  TEST_CASE( 67, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1,  4(x1); fcvt.lu.s x1, f1)
  TEST_CASE( 68, x1,                  0, la x1, tdat  ; flw f1,  8(x1); fcvt.lu.s x1, f1)
  TEST_CASE( 69, x1, 0xffffffffffffffff, la x1, tdat  ; flw f1, 12(x1); fcvt.lu.s x1, f1)
#endif

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

# -NaN, NaN, -inf, +inf
tdat:
.word 0xffffffff
.word 0x7fffffff
.word 0xff800000
.word 0x7f800000

tdat_d:
.dword 0xffffffffffffffff
.dword 0x7fffffffffffffff
.dword 0xfff0000000000000
.dword 0x7ff0000000000000

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# amoor.w.S
#-----------------------------------------------------------------------------
#
# Test amoor.w instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amoor.w	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xfffffffffffff800, lw a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0xfffffffffffff800, \
    li  a1, 1; \
    amoor.w a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xfffffffffffff801, lw a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amomin_d.S
#-----------------------------------------------------------------------------
#
# Test amomin.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sd a0, 0(a3); \
    amomin.d	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xffffffff80000000, ld a5, 0(a3))

  TEST_CASE(4, a4, 0, \
    li a1, 0xffffffffffffffff; \
    sd x0, 0(a3); \
    amomin.d	a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xffffffffffffffff, ld a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amoadd_d.S
#-----------------------------------------------------------------------------
#
# Test amoadd.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sd a0, 0(a3); \
    amoadd.d	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xffffffff7ffff800, ld a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0xffffffff7ffff800, \
    amoadd.d a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xffffffff7ffff000, ld a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amoxor_d.S
#-----------------------------------------------------------------------------
#
# Test amoxor.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sd a0, 0(a3); \
    amoxor.d	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0x000000007ffff800, ld a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0x000000007ffff800, \
    li  a1, 1; \
    amoxor.d a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0x000000007ffff801, ld a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amomax_d.S
#-----------------------------------------------------------------------------
#
# Test amomax.w instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amomax.w	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xfffffffffffff800, lw a5, 0(a3))

  TEST_CASE(4, a4, 0, \
    li a1, 1; \
    sw x0, 0(a3); \
    amomax.w	a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 1, lw a5, 0(a3))

  TEST_CASE(6, a4, 1, \
    li a0, 0x0000000000000001; \
    li a1, 0x0000000080000000; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amomax.w	a4, a1, 0(a3); \
  )

  TEST_CASE(7, a5, 1, lw a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amoswap_w.S
#-----------------------------------------------------------------------------
#
# Test amoswap.w instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amoswap.w	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xfffffffffffff800, lw a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0xfffffffffffff800, \
    li  a1, 0x0000000080000000; \
    amoswap.w a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xffffffff80000000, lw a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amominu_d.S
#-----------------------------------------------------------------------------
#
# Test amominu.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sd a0, 0(a3); \
    amominu.d	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xffffffff80000000, ld a5, 0(a3))

  TEST_CASE(4, a4, 0, \
    li a1, 0xffffffffffffffff; \
    sd x0, 0(a3); \
    amominu.d	a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0, ld a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
  
# See LICENSE for license details.

#*****************************************************************************
# amomaxu_d.S
#-----------------------------------------------------------------------------
#
# Test amomaxu.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sd a0, 0(a3); \
    amomaxu.d	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xfffffffffffff800, ld a5, 0(a3))

  TEST_CASE(4, a4, 0, \
    li a1, 0xffffffffffffffff; \
    sd x0, 0(a3); \
    amomaxu.d	a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xffffffffffffffff, ld a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amoand_d.S
#-----------------------------------------------------------------------------
#
# Test amoand.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sd a0, 0(a3); \
    amoand.d	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xffffffff80000000, ld a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0xffffffff80000000, \
    li  a1, 0x0000000080000000; \
    amoand.d a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0x0000000080000000, ld a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# lrsr.S
#-----------------------------------------------------------------------------
#
# Test LR/SC instructions.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

# get a unique core id
la a0, coreid
li a1, 1
amoadd.w a2, a1, (a0)

# for now, only run this on core 0
1:li a3, 1
bgeu a2, a3, 1b

1: lw a1, (a0)
bltu a1, a3, 1b

# make sure that sc without a reservation fails.
TEST_CASE( 2, a4, 1, \
  la a0, foo; \
  li a5, 0xdeadbeef; \
  sc.w a4, a5, (a0); \
)

# make sure the failing sc did not commit into memory
TEST_CASE( 3, a4, 0, \
  lw a4, foo; \
)

#
# Disable test case 4 for now. It assumes a <1K reservation granule, when
# in reality any size granule is valid. After discussion in issue #315,
# decided to simply disable the test for now.
# (See https://github.com/riscv/riscv-tests/issues/315)
#
## make sure that sc with the wrong reservation fails.
## TODO is this actually mandatory behavior?
#TEST_CASE( 4, a4, 1, \
#  la a0, foo; \
#  la a1, fooTest3; \
#  lr.w a1, (a1); \
#  sc.w a4, a1, (a0); \
#)

#define LOG_ITERATIONS 10

# have each core add its coreid+1 to foo 1024 times
la a0, foo
li a1, 1<<LOG_ITERATIONS
addi a2, a2, 1
1: lr.w a4, (a0)
add a4, a4, a2
sc.w a4, a4, (a0)
bnez a4, 1b
addi a1, a1, -1
bnez a1, 1b

# wait for all cores to finish
la a0, barrier
li a1, 1
amoadd.w x0, a1, (a0)
1: lw a1, (a0)
blt a1, a3, 1b
fence

# expected result is 512*ncores*(ncores+1)
TEST_CASE( 5, a0, 0, \
  lw a0, foo; \
  slli a1, a3, LOG_ITERATIONS-1; \
1:sub a0, a0, a1; \
  addi a3, a3, -1; \
  bgez a3, 1b
)

# make sure that sc-after-successful-sc fails.
TEST_CASE( 6, a1, 2, \
  la a0, foo; \
1:lr.w a1, (a0); \
  sc.w a1, x0, (a0); \
  bnez a1, 1b; \
  sc.w a1, x0, (a0); \
  /* make sure that sc-after-failed-sc fails, too */ \
  sc.w a2, x0, (a0); \
  add a1, a1, a2
)

TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

coreid: .word 0
barrier: .word 0
foo: .word 0
.skip 1024
fooTest3: .word 0
RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# amomaxu_d.S
#-----------------------------------------------------------------------------
#
# Test amomaxu.w instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amomaxu.w	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xfffffffffffff800, lw a5, 0(a3))

  TEST_CASE(4, a4, 0, \
    li a1, 0xffffffffffffffff; \
    sw x0, 0(a3); \
    amomaxu.w	a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xffffffffffffffff, lw a5, 0(a3))

  # The following two cases check that the upper 32 bits are ignored on rv64
  # implementations. Only enable them for rv64.
  #if __riscv_xlen == 64
  TEST_CASE(6, a4, 1, \
    li a0, 0x0000000000000001; \
    li a1, 0x8000000000000000; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amomaxu.w	a4, a1, 0(a3); \
  )

  TEST_CASE(7, a5, 1, lw a5, 0(a3))
  #endif

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amoand.w.S
#-----------------------------------------------------------------------------
#
# Test amoand.w instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amoand.w	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xffffffff80000000, lw a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0xffffffff80000000, \
    li  a1, 0x0000000080000000; \
    amoand.w a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xffffffff80000000, lw a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amomax_d.S
#-----------------------------------------------------------------------------
#
# Test amomax.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sd a0, 0(a3); \
    amomax.d	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xfffffffffffff800, ld a5, 0(a3))

  TEST_CASE(4, a4, 0, \
    li a1, 1; \
    sd x0, 0(a3); \
    amomax.d	a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 1, ld a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amoxor_w.S
#-----------------------------------------------------------------------------
#
# Test amoxor.w instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amoxor.w	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0x7ffff800, lw a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0x7ffff800, \
    li  a1, 0xc0000001; \
    amoxor.w a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xffffffffbffff801, lw a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amominu_d.S
#-----------------------------------------------------------------------------
#
# Test amominu.w instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amominu.w	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xffffffff80000000, lw a5, 0(a3))

  TEST_CASE(4, a4, 0, \
    li a1, 0xffffffffffffffff; \
    sw x0, 0(a3); \
    amominu.w	a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0, lw a5, 0(a3))

  # The following two cases check that the upper 32 bits are ignored on rv64
  # implementations. Only enable them for rv64.
  #if __riscv_xlen == 64
  TEST_CASE(6, a4, 1, \
    li a0, 0x0000000000000001; \
    li a1, 0x8000000000000000; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amominu.w	a4, a1, 0(a3); \
  )

  TEST_CASE(7, a5, 0, lw a5, 0(a3))
  #endif

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amoswap.d.S
#-----------------------------------------------------------------------------
#
# Test amoswap.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sd a0, 0(a3); \
    amoswap.d	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xfffffffffffff800, ld a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0xfffffffffffff800, \
    li  a1, 0x0000000080000000; \
    amoswap.d a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0x0000000080000000, ld a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amoadd_w.S
#-----------------------------------------------------------------------------
#
# Test amoadd.w instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amoadd.w	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0x000000007ffff800, lw a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0x000000007ffff800, \
    li  a1, 0xffffffff80000000; \
    amoadd.w a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xfffffffffffff800, lw a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

    .bss
    .align 3
amo_operand:
    .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amomin_d.S
#-----------------------------------------------------------------------------
#
# Test amomin.w instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amomin.w	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xffffffff80000000, lw a5, 0(a3))

  TEST_CASE(4, a4, 0, \
    li a1, 0xffffffffffffffff; \
    sw x0, 0(a3); \
    amomin.w	a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xffffffffffffffff, lw a5, 0(a3))

  TEST_CASE(6, a4, 1, \
    li a0, 0x0000000000000001; \
    li a1, 0x0000000080000000; \
    la a3, amo_operand; \
    sw a0, 0(a3); \
    amomin.w	a4, a1, 0(a3); \
  )

  TEST_CASE(7, a5, 0xffffffff80000000, lw a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# amoor_d.S
#-----------------------------------------------------------------------------
#
# Test amoor.d instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a4, 0xffffffff80000000, \
    li a0, 0xffffffff80000000; \
    li a1, 0xfffffffffffff800; \
    la a3, amo_operand; \
    sd a0, 0(a3); \
    amoor.d	a4, a1, 0(a3); \
  )

  TEST_CASE(3, a5, 0xfffffffffffff800, ld a5, 0(a3))

  # try again after a cache miss
  TEST_CASE(4, a4, 0xfffffffffffff800, \
    li  a1, 1; \
    amoor.d a4, a1, 0(a3); \
  )

  TEST_CASE(5, a5, 0xfffffffffffff801, ld a5, 0(a3))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END

  .bss
  .align 3
amo_operand:
  .dword 0
# See LICENSE for license details.

#*****************************************************************************
# fence_i.S
#-----------------------------------------------------------------------------
#
# Test self-modifying code and the fence.i instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

li a3, 111
lh a0, insn
lh a1, insn+2

# test I$ hit
.align 6
sh a0, 2f, t0
sh a1, 2f+2, t0
fence.i

la a5, 2f
jalr t1, a5, 0
TEST_CASE( 2, a3, 444, nop )

# test prefetcher hit
li a4, 100
1: addi a4, a4, -1
bnez a4, 1b

sh a0, 3f, t0
sh a1, 3f+2, t0
fence.i

.align 6
la a5, 3f
jalr t1, a5, 0
TEST_CASE( 3, a3, 777, nop )

TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

insn:
  addi a3, a3, 333

2: addi a3, a3, 222
jalr a5, t1, 0

3: addi a3, a3, 555
jalr a5, t1, 0

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# beq.S
#-----------------------------------------------------------------------------
#
# Test beq instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, beq,  0,  0 );
  TEST_BR2_OP_TAKEN( 3, beq,  1,  1 );
  TEST_BR2_OP_TAKEN( 4, beq, -1, -1 );

  TEST_BR2_OP_NOTTAKEN( 5, beq,  0,  1 );
  TEST_BR2_OP_NOTTAKEN( 6, beq,  1,  0 );
  TEST_BR2_OP_NOTTAKEN( 7, beq, -1,  1 );
  TEST_BR2_OP_NOTTAKEN( 8, beq,  1, -1 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 9,  0, 0, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 10, 0, 1, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 11, 0, 2, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 12, 1, 0, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 13, 1, 1, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 14, 2, 0, beq, 0, -1 );

  TEST_BR2_SRC12_BYPASS( 15, 0, 0, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 16, 0, 1, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 17, 0, 2, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 18, 1, 0, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 19, 1, 1, beq, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 20, 2, 0, beq, 0, -1 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 21, x1, 3, \
    li  x1, 1; \
    beq x0, x0, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# lbu.S
#-----------------------------------------------------------------------------
#
# Test lbu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lbu, 0x00000000000000ff, 0,  tdat );
  TEST_LD_OP( 3, lbu, 0x0000000000000000, 1,  tdat );
  TEST_LD_OP( 4, lbu, 0x00000000000000f0, 2,  tdat );
  TEST_LD_OP( 5, lbu, 0x000000000000000f, 3, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lbu, 0x00000000000000ff, -3, tdat4 );
  TEST_LD_OP( 7, lbu, 0x0000000000000000, -2,  tdat4 );
  TEST_LD_OP( 8, lbu, 0x00000000000000f0, -1,  tdat4 );
  TEST_LD_OP( 9, lbu, 0x000000000000000f, 0,   tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x00000000000000ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lbu x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x0000000000000000, \
    la  x1, tdat; \
    addi x1, x1, -6; \
    lbu x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lbu, 0x00000000000000f0, 1, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lbu, 0x000000000000000f, 1, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lbu, 0x0000000000000000, 1, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lbu, 0x00000000000000f0, 1, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lbu, 0x000000000000000f, 1, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lbu, 0x0000000000000000, 1, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lbu  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lbu  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .byte 0xff
tdat2:  .byte 0x00
tdat3:  .byte 0xf0
tdat4:  .byte 0x0f

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# slliw.S
#-----------------------------------------------------------------------------
#
# Test slliw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  slliw, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_IMM_OP( 3,  slliw, 0x0000000000000002, 0x0000000000000001, 1  );
  TEST_IMM_OP( 4,  slliw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_OP( 5,  slliw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_OP( 6,  slliw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_IMM_OP( 7,  slliw, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  slliw, 0xfffffffffffffffe, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  slliw, 0xffffffffffffff80, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, slliw, 0xffffffffffffc000, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, slliw, 0xffffffff80000000, 0xffffffffffffffff, 31 );

  TEST_IMM_OP( 12, slliw, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_IMM_OP( 13, slliw, 0x0000000042424242, 0x0000000021212121, 1  );
  TEST_IMM_OP( 14, slliw, 0xffffffff90909080, 0x0000000021212121, 7  );
  TEST_IMM_OP( 15, slliw, 0x0000000048484000, 0x0000000021212121, 14 );
  TEST_IMM_OP( 16, slliw, 0xffffffff80000000, 0x0000000021212121, 31 );

  # Verify that shifts ignore top 32 (using true 64-bit values)

  TEST_IMM_OP( 44, slliw, 0x0000000012345678, 0xffffffff12345678, 0 );
  TEST_IMM_OP( 45, slliw, 0x0000000023456780, 0xffffffff12345678, 4 );
  TEST_IMM_OP( 46, slliw, 0xffffffff92345678, 0x0000000092345678, 0 );
  TEST_IMM_OP( 47, slliw, 0xffffffff93456780, 0x0000000099345678, 4 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, slliw, 0x00000080, 0x00000001, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, slliw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, slliw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, slliw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, slliw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_SRC1_BYPASS( 22, 1, slliw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, slliw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_IMM_ZEROSRC1( 24, slliw, 0, 31 );
  TEST_IMM_ZERODEST( 25, slliw, 31, 28 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# and.S
#-----------------------------------------------------------------------------
#
# Test and instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_OP( 3, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_OP( 4, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_OP( 5, and, 0xf000f000, 0xf00ff00f, 0xf0f0f0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 6, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC2_EQ_DEST( 7, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_EQ_DEST( 8, and, 0xff00ff00, 0xff00ff00 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 9,  0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_DEST_BYPASS( 10, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_DEST_BYPASS( 11, 2, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC12_BYPASS( 12, 0, 0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 13, 0, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 14, 0, 2, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 15, 1, 0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 16, 1, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 17, 2, 0, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC21_BYPASS( 18, 0, 0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 19, 0, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 20, 0, 2, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 21, 1, 0, and, 0x0f000f00, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 22, 1, 1, and, 0x00f000f0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 23, 2, 0, and, 0x000f000f, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_ZEROSRC1( 24, and, 0, 0xff00ff00 );
  TEST_RR_ZEROSRC2( 25, and, 0, 0x00ff00ff );
  TEST_RR_ZEROSRC12( 26, and, 0 );
  TEST_RR_ZERODEST( 27, and, 0x11111111, 0x22222222 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# andi.S
#-----------------------------------------------------------------------------
#
# Test andi instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2, andi, 0xff00ff00, 0xff00ff00, 0xf0f );
  TEST_IMM_OP( 3, andi, 0x000000f0, 0x0ff00ff0, 0x0f0 );
  TEST_IMM_OP( 4, andi, 0x0000000f, 0x00ff00ff, 0x70f );
  TEST_IMM_OP( 5, andi, 0x00000000, 0xf00ff00f, 0x0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 6, andi, 0x00000000, 0xff00ff00, 0x0f0 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 7,  0, andi, 0x00000700, 0x0ff00ff0, 0x70f );
  TEST_IMM_DEST_BYPASS( 8,  1, andi, 0x000000f0, 0x00ff00ff, 0x0f0 );
  TEST_IMM_DEST_BYPASS( 9,  2, andi, 0xf00ff00f, 0xf00ff00f, 0xf0f );

  TEST_IMM_SRC1_BYPASS( 10, 0, andi, 0x00000700, 0x0ff00ff0, 0x70f );
  TEST_IMM_SRC1_BYPASS( 11, 1, andi, 0x000000f0, 0x00ff00ff, 0x0f0 );
  TEST_IMM_SRC1_BYPASS( 12, 2, andi, 0x0000000f, 0xf00ff00f, 0x70f );

  TEST_IMM_ZEROSRC1( 13, andi, 0, 0x0f0 );
  TEST_IMM_ZERODEST( 14, andi, 0x00ff00ff, 0x70f );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# jal.S
#-----------------------------------------------------------------------------
#
# Test jal instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Test 2: Basic test
  #-------------------------------------------------------------

test_2:
  li  TESTNUM, 2
  li  ra, 0

  jal x4, target_2
linkaddr_2:
  nop
  nop

  j fail

target_2:
  la  x2, linkaddr_2
  bne x2, x4, fail

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 3, ra, 3, \
    li  ra, 1; \
    jal x0, 1f; \
    addi ra, ra, 1; \
    addi ra, ra, 1; \
    addi ra, ra, 1; \
    addi ra, ra, 1; \
1:  addi ra, ra, 1; \
    addi ra, ra, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sh.S
#-----------------------------------------------------------------------------
#
# Test sh instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_ST_OP( 2, lh, sh, 0x00000000000000aa, 0, tdat );
  TEST_ST_OP( 3, lh, sh, 0xffffffffffffaa00, 2, tdat );
  TEST_ST_OP( 4, lw, sh, 0xffffffffbeef0aa0, 4, tdat );
  TEST_ST_OP( 5, lh, sh, 0xffffffffffffa00a, 6, tdat );

  # Test with negative offset

  TEST_ST_OP( 6, lh, sh, 0x00000000000000aa, -6, tdat8 );
  TEST_ST_OP( 7, lh, sh, 0xffffffffffffaa00, -4, tdat8 );
  TEST_ST_OP( 8, lh, sh, 0x0000000000000aa0, -2, tdat8 );
  TEST_ST_OP( 9, lh, sh, 0xffffffffffffa00a, 0,  tdat8 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x5678, \
    la  x1, tdat9; \
    li  x2, 0x12345678; \
    addi x4, x1, -32; \
    sh x2, 32(x4); \
    lh x5, 0(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x3098, \
    la  x1, tdat9; \
    li  x2, 0x00003098; \
    addi x1, x1, -5; \
    sh x2, 7(x1); \
    la  x4, tdat10; \
    lh x5, 0(x4); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_ST_SRC12_BYPASS( 12, 0, 0, lh, sh, 0xffffffffffffccdd, 0,  tdat );
  TEST_ST_SRC12_BYPASS( 13, 0, 1, lh, sh, 0xffffffffffffbccd, 2,  tdat );
  TEST_ST_SRC12_BYPASS( 14, 0, 2, lh, sh, 0xffffffffffffbbcc, 4,  tdat );
  TEST_ST_SRC12_BYPASS( 15, 1, 0, lh, sh, 0xffffffffffffabbc, 6, tdat );
  TEST_ST_SRC12_BYPASS( 16, 1, 1, lh, sh, 0xffffffffffffaabb, 8, tdat );
  TEST_ST_SRC12_BYPASS( 17, 2, 0, lh, sh, 0xffffffffffffdaab, 10, tdat );

  TEST_ST_SRC21_BYPASS( 18, 0, 0, lh, sh, 0x2233, 0,  tdat );
  TEST_ST_SRC21_BYPASS( 19, 0, 1, lh, sh, 0x1223, 2,  tdat );
  TEST_ST_SRC21_BYPASS( 20, 0, 2, lh, sh, 0x1122, 4,  tdat );
  TEST_ST_SRC21_BYPASS( 21, 1, 0, lh, sh, 0x0112, 6, tdat );
  TEST_ST_SRC21_BYPASS( 22, 1, 1, lh, sh, 0x0011, 8, tdat );
  TEST_ST_SRC21_BYPASS( 23, 2, 0, lh, sh, 0x3001, 10, tdat );

  li a0, 0xbeef
  la a1, tdat
  sh a0, 6(a1)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .half 0xbeef
tdat2:  .half 0xbeef
tdat3:  .half 0xbeef
tdat4:  .half 0xbeef
tdat5:  .half 0xbeef
tdat6:  .half 0xbeef
tdat7:  .half 0xbeef
tdat8:  .half 0xbeef
tdat9:  .half 0xbeef
tdat10: .half 0xbeef

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sb.S
#-----------------------------------------------------------------------------
#
# Test sb instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_ST_OP( 2, lb, sb, 0xffffffffffffffaa, 0, tdat );
  TEST_ST_OP( 3, lb, sb, 0x0000000000000000, 1, tdat );
  TEST_ST_OP( 4, lh, sb, 0xffffffffffffefa0, 2, tdat );
  TEST_ST_OP( 5, lb, sb, 0x000000000000000a, 3, tdat );

  # Test with negative offset

  TEST_ST_OP( 6, lb, sb, 0xffffffffffffffaa, -3, tdat8 );
  TEST_ST_OP( 7, lb, sb, 0x0000000000000000, -2, tdat8 );
  TEST_ST_OP( 8, lb, sb, 0xffffffffffffffa0, -1, tdat8 );
  TEST_ST_OP( 9, lb, sb, 0x000000000000000a, 0,  tdat8 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x78, \
    la  x1, tdat9; \
    li  x2, 0x12345678; \
    addi x4, x1, -32; \
    sb x2, 32(x4); \
    lb x5, 0(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0xffffffffffffff98, \
    la  x1, tdat9; \
    li  x2, 0x00003098; \
    addi x1, x1, -6; \
    sb x2, 7(x1); \
    la  x4, tdat10; \
    lb x5, 0(x4); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_ST_SRC12_BYPASS( 12, 0, 0, lb, sb, 0xffffffffffffffdd, 0, tdat );
  TEST_ST_SRC12_BYPASS( 13, 0, 1, lb, sb, 0xffffffffffffffcd, 1, tdat );
  TEST_ST_SRC12_BYPASS( 14, 0, 2, lb, sb, 0xffffffffffffffcc, 2, tdat );
  TEST_ST_SRC12_BYPASS( 15, 1, 0, lb, sb, 0xffffffffffffffbc, 3, tdat );
  TEST_ST_SRC12_BYPASS( 16, 1, 1, lb, sb, 0xffffffffffffffbb, 4, tdat );
  TEST_ST_SRC12_BYPASS( 17, 2, 0, lb, sb, 0xffffffffffffffab, 5, tdat );

  TEST_ST_SRC21_BYPASS( 18, 0, 0, lb, sb, 0x33, 0, tdat );
  TEST_ST_SRC21_BYPASS( 19, 0, 1, lb, sb, 0x23, 1, tdat );
  TEST_ST_SRC21_BYPASS( 20, 0, 2, lb, sb, 0x22, 2, tdat );
  TEST_ST_SRC21_BYPASS( 21, 1, 0, lb, sb, 0x12, 3, tdat );
  TEST_ST_SRC21_BYPASS( 22, 1, 1, lb, sb, 0x11, 4, tdat );
  TEST_ST_SRC21_BYPASS( 23, 2, 0, lb, sb, 0x01, 5, tdat );

  li a0, 0xef
  la a1, tdat
  sb a0, 3(a1)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .byte 0xef
tdat2:  .byte 0xef
tdat3:  .byte 0xef
tdat4:  .byte 0xef
tdat5:  .byte 0xef
tdat6:  .byte 0xef
tdat7:  .byte 0xef
tdat8:  .byte 0xef
tdat9:  .byte 0xef
tdat10: .byte 0xef

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bgeu.S
#-----------------------------------------------------------------------------
#
# Test bgeu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, bgeu, 0x00000000, 0x00000000 );
  TEST_BR2_OP_TAKEN( 3, bgeu, 0x00000001, 0x00000001 );
  TEST_BR2_OP_TAKEN( 4, bgeu, 0xffffffff, 0xffffffff );
  TEST_BR2_OP_TAKEN( 5, bgeu, 0x00000001, 0x00000000 );
  TEST_BR2_OP_TAKEN( 6, bgeu, 0xffffffff, 0xfffffffe );
  TEST_BR2_OP_TAKEN( 7, bgeu, 0xffffffff, 0x00000000 );

  TEST_BR2_OP_NOTTAKEN(  8, bgeu, 0x00000000, 0x00000001 );
  TEST_BR2_OP_NOTTAKEN(  9, bgeu, 0xfffffffe, 0xffffffff );
  TEST_BR2_OP_NOTTAKEN( 10, bgeu, 0x00000000, 0xffffffff );
  TEST_BR2_OP_NOTTAKEN( 11, bgeu, 0x7fffffff, 0x80000000 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 12, 0, 0, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 13, 0, 1, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 14, 0, 2, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 15, 1, 0, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 16, 1, 1, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 17, 2, 0, bgeu, 0xefffffff, 0xf0000000 );

  TEST_BR2_SRC12_BYPASS( 18, 0, 0, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 19, 0, 1, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 20, 0, 2, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 21, 1, 0, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 22, 1, 1, bgeu, 0xefffffff, 0xf0000000 );
  TEST_BR2_SRC12_BYPASS( 23, 2, 0, bgeu, 0xefffffff, 0xf0000000 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 24, x1, 3, \
    li  x1, 1; \
    bgeu x1, x0, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# simple.S
#-----------------------------------------------------------------------------
#
# This is the most basic self checking test. If your simulator does not
# pass thiss then there is little chance that it will pass any of the
# more complicated self checking tests.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

RVTEST_PASS

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# srli.S
#-----------------------------------------------------------------------------
#
# Test srli instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

#define TEST_SRLI(n, v, a) \
  TEST_IMM_OP(n, srli, ((v) & ((1 << (__riscv_xlen-1) << 1) - 1)) >> (a), v, a)

  TEST_SRLI( 2,  0xffffffff80000000, 0  );
  TEST_SRLI( 3,  0xffffffff80000000, 1  );
  TEST_SRLI( 4,  0xffffffff80000000, 7  );
  TEST_SRLI( 5,  0xffffffff80000000, 14 );
  TEST_SRLI( 6,  0xffffffff80000001, 31 );

  TEST_SRLI( 7,  0xffffffffffffffff, 0  );
  TEST_SRLI( 8,  0xffffffffffffffff, 1  );
  TEST_SRLI( 9,  0xffffffffffffffff, 7  );
  TEST_SRLI( 10, 0xffffffffffffffff, 14 );
  TEST_SRLI( 11, 0xffffffffffffffff, 31 );

  TEST_SRLI( 12, 0x0000000021212121, 0  );
  TEST_SRLI( 13, 0x0000000021212121, 1  );
  TEST_SRLI( 14, 0x0000000021212121, 7  );
  TEST_SRLI( 15, 0x0000000021212121, 14 );
  TEST_SRLI( 16, 0x0000000021212121, 31 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, srli, 0x01000000, 0x80000000, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, srli, 0x01000000, 0x80000000, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, srli, 0x00020000, 0x80000000, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, srli, 0x00000001, 0x80000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, srli, 0x01000000, 0x80000000, 7  );
  TEST_IMM_SRC1_BYPASS( 22, 1, srli, 0x00020000, 0x80000000, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, srli, 0x00000001, 0x80000001, 31 );

  TEST_IMM_ZEROSRC1( 24, srli, 0, 4 );
  TEST_IMM_ZERODEST( 25, srli, 33, 10 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# auipc.S
#-----------------------------------------------------------------------------
#
# Test auipc instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  TEST_CASE(2, a0, 10000, \
    .align 3; \
    lla a0, 1f + 10000; \
    jal a1, 1f; \
    1: sub a0, a0, a1; \
  )

  TEST_CASE(3, a0, -10000, \
    .align 3; \
    lla a0, 1f - 10000; \
    jal a1, 1f; \
    1: sub a0, a0, a1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sraw.S
#-----------------------------------------------------------------------------
#
# Test sraw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sraw, 0xffffffff80000000, 0xffffffff80000000, 0  );
  TEST_RR_OP( 3,  sraw, 0xffffffffc0000000, 0xffffffff80000000, 1  );
  TEST_RR_OP( 4,  sraw, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_OP( 5,  sraw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_OP( 6,  sraw, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_RR_OP( 7,  sraw, 0x000000007fffffff, 0x000000007fffffff, 0  );
  TEST_RR_OP( 8,  sraw, 0x000000003fffffff, 0x000000007fffffff, 1  );
  TEST_RR_OP( 9,  sraw, 0x0000000000ffffff, 0x000000007fffffff, 7  );
  TEST_RR_OP( 10, sraw, 0x000000000001ffff, 0x000000007fffffff, 14 );
  TEST_RR_OP( 11, sraw, 0x0000000000000000, 0x000000007fffffff, 31 );

  TEST_RR_OP( 12, sraw, 0xffffffff81818181, 0xffffffff81818181, 0  );
  TEST_RR_OP( 13, sraw, 0xffffffffc0c0c0c0, 0xffffffff81818181, 1  );
  TEST_RR_OP( 14, sraw, 0xffffffffff030303, 0xffffffff81818181, 7  );
  TEST_RR_OP( 15, sraw, 0xfffffffffffe0606, 0xffffffff81818181, 14 );
  TEST_RR_OP( 16, sraw, 0xffffffffffffffff, 0xffffffff81818181, 31 );

  # Verify that shifts only use bottom five bits

  TEST_RR_OP( 17, sraw, 0xffffffff81818181, 0xffffffff81818181, 0xffffffffffffffe0 );
  TEST_RR_OP( 18, sraw, 0xffffffffc0c0c0c0, 0xffffffff81818181, 0xffffffffffffffe1 );
  TEST_RR_OP( 19, sraw, 0xffffffffff030303, 0xffffffff81818181, 0xffffffffffffffe7 );
  TEST_RR_OP( 20, sraw, 0xfffffffffffe0606, 0xffffffff81818181, 0xffffffffffffffee );
  TEST_RR_OP( 21, sraw, 0xffffffffffffffff, 0xffffffff81818181, 0xffffffffffffffff );

  # Verify that shifts ignore top 32 (using true 64-bit values)

  TEST_RR_OP( 44, sraw, 0x0000000012345678, 0xffffffff12345678, 0 );
  TEST_RR_OP( 45, sraw, 0x0000000001234567, 0xffffffff12345678, 4 );
  TEST_RR_OP( 46, sraw, 0xffffffff92345678, 0x0000000092345678, 0 );
  TEST_RR_OP( 47, sraw, 0xfffffffff9234567, 0x0000000092345678, 4 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, sraw, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, sraw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, sraw, 0, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, sraw, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, sraw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, sraw, 0xffffffffffffffff, 0xffffffff80000000, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, sraw, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, sraw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, sraw, 0xffffffffffffffff, 0xffffffff80000000, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, sraw, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, sraw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, sraw, 0xffffffffffffffff, 0xffffffff80000000, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, sraw, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, sraw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, sraw, 0xffffffffffffffff, 0xffffffff80000000, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, sraw, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, sraw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, sraw, 0xffffffffffffffff, 0xffffffff80000000, 31 );

  TEST_RR_ZEROSRC1( 40, sraw, 0, 15 );
  TEST_RR_ZEROSRC2( 41, sraw, 32, 32 );
  TEST_RR_ZEROSRC12( 42, sraw, 0 );
  TEST_RR_ZERODEST( 43, sraw, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ma_data.S
#-----------------------------------------------------------------------------
#
# Test misaligned ld/st data.
# Based on rv64mi-ma_addr.S
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  la s0, data

#define SEXT(x, n) ((-((x) >> ((n)-1)) << (n)) | ((x) & ((1 << (n))-1)))

/* Check that a misaligned load reads the correct value. */
#define MISALIGNED_LOAD_TEST(testnum, insn, base, offset, res) \
  li TESTNUM, testnum; \
  li t1, res; \
  insn t2, offset(base); \
  bne t1, t2, fail; \
1:

# within quadword
  MISALIGNED_LOAD_TEST(1,  lh,  s0, 1, SEXT(0x0201, 16))
  MISALIGNED_LOAD_TEST(2,  lhu, s0, 1, 0x0201)
  MISALIGNED_LOAD_TEST(3,  lw,  s0, 1, SEXT(0x04030201, 32))
  MISALIGNED_LOAD_TEST(4,  lw,  s0, 2, SEXT(0x05040302, 32))
  MISALIGNED_LOAD_TEST(5,  lw,  s0, 3, SEXT(0x06050403, 32))

#if __riscv_xlen == 64
  MISALIGNED_LOAD_TEST(6,  lwu, s0, 1, 0x04030201)
  MISALIGNED_LOAD_TEST(7,  lwu, s0, 2, 0x05040302)
  MISALIGNED_LOAD_TEST(8,  lwu, s0, 3, 0x06050403)

  MISALIGNED_LOAD_TEST(9,  ld, s0, 1, 0x0807060504030201)
  MISALIGNED_LOAD_TEST(10, ld, s0, 2, 0x0908070605040302)
  MISALIGNED_LOAD_TEST(11, ld, s0, 3, 0x0a09080706050403)
  MISALIGNED_LOAD_TEST(12, ld, s0, 4, 0x0b0a090807060504)
  MISALIGNED_LOAD_TEST(13, ld, s0, 5, 0x0c0b0a0908070605)
  MISALIGNED_LOAD_TEST(14, ld, s0, 6, 0x0d0c0b0a09080706)
  MISALIGNED_LOAD_TEST(15, ld, s0, 7, 0x0e0d0c0b0a090807)
#endif

# octword crossing
  MISALIGNED_LOAD_TEST(16, lh,  s0, 31, SEXT(0x201f, 16))
  MISALIGNED_LOAD_TEST(17, lhu, s0, 31, 0x201f)
  MISALIGNED_LOAD_TEST(18, lw,  s0, 29, SEXT(0x201f1e1d, 32))
  MISALIGNED_LOAD_TEST(19, lw,  s0, 30, SEXT(0x21201f1e, 32))
  MISALIGNED_LOAD_TEST(20, lw,  s0, 31, SEXT(0x2221201f, 32))

#if __riscv_xlen == 64
  MISALIGNED_LOAD_TEST(21, lwu, s0, 29, 0x201f1e1d)
  MISALIGNED_LOAD_TEST(22, lwu, s0, 30, 0x21201f1e)
  MISALIGNED_LOAD_TEST(23, lwu, s0, 31, 0x2221201f)

  MISALIGNED_LOAD_TEST(24, ld, s0, 25, 0x201f1e1d1c1b1a19)
  MISALIGNED_LOAD_TEST(25, ld, s0, 26, 0x21201f1e1d1c1b1a)
  MISALIGNED_LOAD_TEST(26, ld, s0, 27, 0x2221201f1e1d1c1b)
  MISALIGNED_LOAD_TEST(27, ld, s0, 28, 0x232221201f1e1d1c)
  MISALIGNED_LOAD_TEST(28, ld, s0, 29, 0x24232221201f1e1d)
  MISALIGNED_LOAD_TEST(29, ld, s0, 30, 0x2524232221201f1e)
  MISALIGNED_LOAD_TEST(30, ld, s0, 31, 0x262524232221201f)
#endif

# cacheline crossing
  MISALIGNED_LOAD_TEST(31, lh,  s0, 63, SEXT(0x403f, 16))
  MISALIGNED_LOAD_TEST(32, lhu, s0, 63, 0x403f)
  MISALIGNED_LOAD_TEST(33, lw,  s0, 61, SEXT(0x403f3e3d, 32))
  MISALIGNED_LOAD_TEST(34, lw,  s0, 62, SEXT(0x41403f3e, 32))
  MISALIGNED_LOAD_TEST(35, lw,  s0, 63, SEXT(0x4241403f, 32))

#if __riscv_xlen == 64
  MISALIGNED_LOAD_TEST(36, lwu, s0, 61, 0x403f3e3d)
  MISALIGNED_LOAD_TEST(37, lwu, s0, 62, 0x41403f3e)
  MISALIGNED_LOAD_TEST(38, lwu, s0, 63, 0x4241403f)

  MISALIGNED_LOAD_TEST(39, ld, s0, 57, 0x403f3e3d3c3b3a39)
  MISALIGNED_LOAD_TEST(40, ld, s0, 58, 0x41403f3e3d3c3b3a)
  MISALIGNED_LOAD_TEST(41, ld, s0, 59, 0x4241403f3e3d3c3b)
  MISALIGNED_LOAD_TEST(42, ld, s0, 60, 0x434241403f3e3d3c)
  MISALIGNED_LOAD_TEST(43, ld, s0, 61, 0x44434241403f3e3d)
  MISALIGNED_LOAD_TEST(44, ld, s0, 62, 0x4544434241403f3e)
  MISALIGNED_LOAD_TEST(45, ld, s0, 63, 0x464544434241403f)
#endif


/* Check that a misaligned store writes the correct value. */
#define MISALIGNED_STORE_TEST(testnum, st_insn, ld_insn, base, offset, st_data) \
  li TESTNUM, testnum; \
  li t1, st_data; \
  st_insn t1, offset(base); \
  ld_insn t2, offset(base); \
  bne t1, t2, fail; \
1:

# within quadword
  MISALIGNED_STORE_TEST(46, sh, lh,  s0, 1, SEXT(0x8180, 16))
  MISALIGNED_STORE_TEST(47, sh, lhu, s0, 1, 0x8382)
  MISALIGNED_STORE_TEST(48, sw, lw,  s0, 1, SEXT(0x87868584, 32))
  MISALIGNED_STORE_TEST(49, sw, lw,  s0, 2, SEXT(0x8b8a8988, 32))
  MISALIGNED_STORE_TEST(50, sw, lw,  s0, 3, SEXT(0x8f8e8d8c, 32))

#if __riscv_xlen == 64
  MISALIGNED_STORE_TEST(51, sw, lwu, s0, 1, 0x93929190)
  MISALIGNED_STORE_TEST(52, sw, lwu, s0, 2, 0x97969594)
  MISALIGNED_STORE_TEST(53, sw, lwu, s0, 3, 0x9b9a9998)

  MISALIGNED_STORE_TEST(54, sd, ld, s0, 1, 0xa3a2a1a09f9e9d9c)
  MISALIGNED_STORE_TEST(55, sd, ld, s0, 2, 0xabaaa9a8a7a6a5a4)
  MISALIGNED_STORE_TEST(56, sd, ld, s0, 3, 0xb3b2b1b0afaeadac)
  MISALIGNED_STORE_TEST(57, sd, ld, s0, 4, 0xbbbab9b8b7b6b5b4)
  MISALIGNED_STORE_TEST(58, sd, ld, s0, 5, 0xc3c2c1c0bfbebdbc)
  MISALIGNED_STORE_TEST(59, sd, ld, s0, 6, 0xcbcac9c8c7c6c5c4)
  MISALIGNED_STORE_TEST(60, sd, ld, s0, 7, 0xd3d2d1d0cfcecdcc)
#endif

# octword crossing
  MISALIGNED_STORE_TEST(61, sh, lh,  s0, 31, SEXT(0xd5d4, 16))
  MISALIGNED_STORE_TEST(62, sh, lhu, s0, 31, 0xd7d6)
  MISALIGNED_STORE_TEST(63, sw, lw,  s0, 29, SEXT(0xdbdad9d8, 32))
  MISALIGNED_STORE_TEST(64, sw, lw,  s0, 30, SEXT(0xdfdedddc, 32))
  MISALIGNED_STORE_TEST(65, sw, lw,  s0, 31, SEXT(0xe3e2e1e0, 32))

#if __riscv_xlen == 64
  MISALIGNED_STORE_TEST(66, sw, lwu, s0, 29, 0xe7e6e5e4)
  MISALIGNED_STORE_TEST(67, sw, lwu, s0, 30, 0xebeae9e8)
  MISALIGNED_STORE_TEST(68, sw, lwu, s0, 31, 0xefeeedec)

  MISALIGNED_STORE_TEST(69, sd, ld, s0, 25, 0xf7f6f5f4f3f2f1f0)
  MISALIGNED_STORE_TEST(70, sd, ld, s0, 26, 0xfffefdfcfbfaf9f8)
  MISALIGNED_STORE_TEST(71, sd, ld, s0, 27, 0x0706050403020100)
  MISALIGNED_STORE_TEST(72, sd, ld, s0, 28, 0x0f0e0d0c0b0a0908)
  MISALIGNED_STORE_TEST(73, sd, ld, s0, 29, 0x1716151413121110)
  MISALIGNED_STORE_TEST(74, sd, ld, s0, 30, 0x1f1e1d1c1b1a1918)
  MISALIGNED_STORE_TEST(75, sd, ld, s0, 31, 0x2726252423222120)
#endif

# cacheline crossing
  MISALIGNED_STORE_TEST(76, sh, lh,  s0, 63, SEXT(0x3534, 16))
  MISALIGNED_STORE_TEST(77, sh, lhu, s0, 63, 0x3736)
  MISALIGNED_STORE_TEST(78, sw, lw,  s0, 61, SEXT(0x3b3a3938, 32))
  MISALIGNED_STORE_TEST(79, sw, lw,  s0, 62, SEXT(0x3f3e3d3c, 32))
  MISALIGNED_STORE_TEST(80, sw, lw,  s0, 63, SEXT(0x43424140, 32))

#if __riscv_xlen == 64
  MISALIGNED_STORE_TEST(81, sw, lwu, s0, 61, 0x47464544)
  MISALIGNED_STORE_TEST(82, sw, lwu, s0, 62, 0x4b4a4948)
  MISALIGNED_STORE_TEST(83, sw, lwu, s0, 63, 0x4f4e4d4c)

  MISALIGNED_STORE_TEST(84, sd, ld, s0, 57, 0x5756555453525150)
  MISALIGNED_STORE_TEST(85, sd, ld, s0, 58, 0x5f5e5d5c5b5a5958)
  MISALIGNED_STORE_TEST(86, sd, ld, s0, 59, 0x6766656463626160)
  MISALIGNED_STORE_TEST(87, sd, ld, s0, 60, 0x6f6e6d6c6b6a6968)
  MISALIGNED_STORE_TEST(88, sd, ld, s0, 61, 0x7776757473727170)
  MISALIGNED_STORE_TEST(89, sd, ld, s0, 62, 0x7f7e7d7c7b7a7978)
  MISALIGNED_STORE_TEST(90, sd, ld, s0, 63, 0x8786858483828180)
#endif


/* Check that a misaligned store writes the correct value, checked by a narrower load. */
#define MISMATCHED_STORE_TEST(testnum, st_insn, ld_insn, base, st_offset, ld_offset, st_data, ld_data) \
  li TESTNUM, testnum; \
  li t1, st_data; \
  li t2, ld_data; \
  st_insn t1, st_offset(base); \
  ld_insn t3, ld_offset(base); \
  bne t2, t3, fail; \
1:

# within quadword
  MISMATCHED_STORE_TEST(91,  sh, lb,  s0, 1, 1, 0x9998, SEXT(0x98, 8))
  MISMATCHED_STORE_TEST(92,  sh, lb,  s0, 1, 2, 0x9b9a, SEXT(0x9b, 8))
  MISMATCHED_STORE_TEST(93,  sh, lbu, s0, 1, 1, 0x9d9c, 0x9c)
  MISMATCHED_STORE_TEST(94,  sh, lbu, s0, 1, 2, 0x9f9e, 0x9f)
  MISMATCHED_STORE_TEST(95,  sw, lb,  s0, 1, 1, 0xa3a2a1a0, SEXT(0xa0, 8))
  MISMATCHED_STORE_TEST(96,  sw, lbu, s0, 2, 3, 0xa7a6a5a4, 0xa5)
  MISMATCHED_STORE_TEST(97,  sw, lh,  s0, 3, 4, 0xabaaa9a8, SEXT(0xaaa9, 16))
  MISMATCHED_STORE_TEST(98,  sw, lhu, s0, 3, 5, 0xafaeadac, 0xafae)

#if __riscv_xlen == 64
  MISMATCHED_STORE_TEST(99,  sd, lb,  s0, 1, 7, 0xb7b6b5b4b3b2b1b0, SEXT(0xb6, 8))
  MISMATCHED_STORE_TEST(100, sd, lbu, s0, 2, 3, 0xbfbebdbcbbbab9b8, 0xb9)
  MISMATCHED_STORE_TEST(101, sd, lh,  s0, 3, 9, 0xc7c6c5c4c3c2c1c0, SEXT(0xc7c6, 16))
  MISMATCHED_STORE_TEST(102, sd, lhu, s0, 4, 5, 0xcfcecdcccbcac9c8, 0xcac9)
  MISMATCHED_STORE_TEST(103, sd, lw,  s0, 5, 9, 0xd7d6d5d4d3d2d1d0, SEXT(0xd7d6d5d4, 32))
  MISMATCHED_STORE_TEST(104, sd, lw,  s0, 6, 8, 0xdfdedddcdbdad9d8, SEXT(0xdddcdbda, 32))
  MISMATCHED_STORE_TEST(105, sd, lwu, s0, 7, 8, 0xe7e6e5e4e3e2e1e0, 0xe4e3e2e1)
#endif

# octword crossing
  MISMATCHED_STORE_TEST(106, sh, lb,  s0, 31, 31, 0xe9e8, SEXT(0xe8, 8))
  MISMATCHED_STORE_TEST(107, sh, lb,  s0, 31, 32, 0xebea, SEXT(0xeb, 8))
  MISMATCHED_STORE_TEST(108, sh, lbu, s0, 31, 31, 0xedec, 0xec)
  MISMATCHED_STORE_TEST(109, sh, lbu, s0, 31, 32, 0xefee, 0xef)
  MISMATCHED_STORE_TEST(110, sw, lb,  s0, 29, 29, 0xf3f2f1f0, SEXT(0xf0, 8))
  MISMATCHED_STORE_TEST(111, sw, lbu, s0, 30, 32, 0xf7f6f5f4, 0xf6)
  MISMATCHED_STORE_TEST(112, sw, lh,  s0, 29, 31, 0xfbfaf9f8, SEXT(0xfbfa, 16))
  MISMATCHED_STORE_TEST(113, sw, lhu, s0, 31, 31, 0xfffefdfc, 0xfdfc)

#if __riscv_xlen == 64
  MISMATCHED_STORE_TEST(114, sd, lb,  s0, 25, 32, 0x0706050403020100, SEXT(0x07, 8))
  MISMATCHED_STORE_TEST(115, sd, lbu, s0, 26, 33, 0x0f0e0d0c0b0a0908, 0x0f)
  MISMATCHED_STORE_TEST(116, sd, lh,  s0, 27, 31, 0x1716151413121110, SEXT(0x1514, 16))
  MISMATCHED_STORE_TEST(117, sd, lhu, s0, 28, 31, 0x1f1e1d1c1b1a1918, 0x1c1b)
  MISMATCHED_STORE_TEST(118, sd, lw,  s0, 29, 29, 0x2726252423222120, SEXT(0x23222120, 32))
  MISMATCHED_STORE_TEST(119, sd, lw,  s0, 30, 30, 0x2f2e2d2c2b2a2928, SEXT(0x2b2a2928, 32))
  MISMATCHED_STORE_TEST(120, sd, lwu, s0, 31, 31, 0x3736353433323130, 0x33323130)
#endif

# cacheline crossing
  MISMATCHED_STORE_TEST(121, sh, lb,  s0, 63, 63, 0x4948, SEXT(0x48, 8))
  MISMATCHED_STORE_TEST(122, sh, lb,  s0, 63, 64, 0x4b4a, SEXT(0x4b, 8))
  MISMATCHED_STORE_TEST(123, sh, lbu, s0, 63, 63, 0x4d4c, 0x4c)
  MISMATCHED_STORE_TEST(124, sh, lbu, s0, 63, 64, 0x4f4e, 0x4f)
  MISMATCHED_STORE_TEST(125, sw, lb,  s0, 61, 61, 0x53525150, SEXT(0x50, 8))
  MISMATCHED_STORE_TEST(126, sw, lbu, s0, 62, 64, 0x57565554, 0x56)
  MISMATCHED_STORE_TEST(127, sw, lh,  s0, 61, 63, 0x5b5a5958, SEXT(0x5b5a, 16))
  MISMATCHED_STORE_TEST(128, sw, lhu, s0, 63, 63, 0x5f5e5d5c, 0x5d5c)

#if __riscv_xlen == 64
  MISMATCHED_STORE_TEST(129, sd, lb,  s0, 57, 64, 0x6766656463626160, SEXT(0x67, 8))
  MISMATCHED_STORE_TEST(130, sd, lbu, s0, 58, 65, 0x6f6e6d6c6b6a6968, 0x6f)
  MISMATCHED_STORE_TEST(131, sd, lh,  s0, 59, 63, 0x7776757473727170, SEXT(0x7574, 16))
  MISMATCHED_STORE_TEST(132, sd, lhu, s0, 60, 63, 0x7f7e7d7c7b7a7978, 0x7c7b)
  MISMATCHED_STORE_TEST(133, sd, lw,  s0, 61, 61, 0x8786858483828180, SEXT(0x83828180, 32))
  MISMATCHED_STORE_TEST(134, sd, lw,  s0, 62, 62, 0x8f8e8d8c8b8a8988, SEXT(0x8b8a8988, 32))
  MISMATCHED_STORE_TEST(135, sd, lwu, s0, 63, 63, 0x9796959493929190, 0x93929190)
#endif

/* Memory contents at this point should be:
.word 0x10080000
.word 0x30282018
.word 0x34333231
.word 0x0f373635
.word 0x13121110
.word 0x17161514
.word 0x10080018
.word 0x30282018

.word 0x34333231
.word 0x27373635
.word 0x2b2a2928
.word 0x2f2e2d2c
.word 0x33323130
.word 0x37363534
.word 0x70686038
.word 0x90888078

.word 0x94939291
.word 0x47979695
.word 0x4b4a4948
.word 0x4f4e4d4c
.word 0x53525150
.word 0x57565554
.word 0x5b5a5958
.word 0x5f5e5d5c
.word 0x63626160
.word 0x67666564
.word 0x6b6a6968
.word 0x6f6e6d6c
.word 0x73727170
.word 0x77767574
.word 0x7b7a7978
.word 0x7f7e7d7c
*/

/* Check that a misaligned store writes the correct value, checked by a wider load. */

#if __riscv_xlen == 64
# within quadword
  MISMATCHED_STORE_TEST(136, sb, lh,  s0, 1, 1, 0x98, SEXT(0xb898, 16))
  MISMATCHED_STORE_TEST(137, sb, lhu, s0, 2, 1, 0x99, 0x9998)
  MISMATCHED_STORE_TEST(138, sh, lw,  s0, 1, 1, 0x9b9a, SEXT(0xc8c09b9a, 32))
  MISMATCHED_STORE_TEST(139, sh, lw,  s0, 3, 2, 0x9d9c, SEXT(0xd09d9c9b, 32))
  MISMATCHED_STORE_TEST(140, sh, lw,  s0, 5, 3, 0x9f9e, SEXT(0x9f9e9d9c, 32))

  MISMATCHED_STORE_TEST(141, sb, lwu, s0, 2, 1, 0xa0, 0x9d9ca09a)
  MISMATCHED_STORE_TEST(142, sh, lwu, s0, 3, 2, 0xa2a1, 0x9ea2a1a0)
  MISMATCHED_STORE_TEST(143, sh, lwu, s0, 5, 3, 0xa4a3, 0xa4a3a2a1)

  MISMATCHED_STORE_TEST(144, sb, ld, s0, 2,  1, 0xa5, 0xe1e0a4a3a2a1a59a)
  MISMATCHED_STORE_TEST(145, sh, ld, s0, 7,  2, 0xa7a6, 0xe2a7a6a4a3a2a1a5)
  MISMATCHED_STORE_TEST(146, sh, ld, s0, 9,  3, 0xa9a8, 0xa9a8a7a6a4a3a2a1)
  MISMATCHED_STORE_TEST(147, sw, ld, s0, 5,  4, 0xadacabaa, 0xe4a9a8adacabaaa2)
  MISMATCHED_STORE_TEST(148, sw, ld, s0, 7,  5, 0xb1b0afae, 0xe5e4b1b0afaeabaa)
  MISMATCHED_STORE_TEST(149, sw, ld, s0, 9,  6, 0xb5b4b3b2, 0xe6b5b4b3b2afaeab)
  MISMATCHED_STORE_TEST(150, sw, ld, s0, 11, 7, 0xb9b8b7b6, 0xb9b8b7b6b3b2afae)

# octword crossing
  MISMATCHED_STORE_TEST(151, sb, lh,  s0, 31, 31, 0xba, SEXT(0x31ba, 16))
  MISMATCHED_STORE_TEST(152, sb, lhu, s0, 32, 31, 0xbb, 0xbbba)
  MISMATCHED_STORE_TEST(153, sh, lw,  s0, 30, 30, 0xbdbc, SEXT(0x32bbbdbc, 32))
  MISMATCHED_STORE_TEST(154, sh, lw,  s0, 31, 30, 0xbfbe, SEXT(0x32bfbebc, 32))
  MISMATCHED_STORE_TEST(155, sh, lw,  s0, 32, 30, 0xc1c0, SEXT(0xc1c0bebc, 32))

  MISMATCHED_STORE_TEST(156, sb, lwu, s0, 32, 31, 0xc2, 0x33c1c2be)
  MISMATCHED_STORE_TEST(157, sh, lwu, s0, 31, 29, 0xc4c3, 0xc4c3bc20)
  MISMATCHED_STORE_TEST(158, sh, lwu, s0, 32, 30, 0xc6c5, 0xc6c5c3bc)

  MISMATCHED_STORE_TEST(159, sb, ld, s0, 32, 25, 0xc7, 0xc7c3bc2018100800)
  MISMATCHED_STORE_TEST(160, sh, ld, s0, 31, 26, 0xc9c8, 0xc6c9c8bc20181008)
  MISMATCHED_STORE_TEST(161, sh, ld, s0, 31, 27, 0xcbca, 0x33c6cbcabc201810)
  MISMATCHED_STORE_TEST(162, sw, ld, s0, 32, 28, 0xcfcecdcc, 0xcfcecdcccabc2018)
  MISMATCHED_STORE_TEST(163, sw, ld, s0, 31, 29, 0xd3d2d1d0, 0x35cfd3d2d1d0bc20)
  MISMATCHED_STORE_TEST(164, sw, ld, s0, 30, 30, 0xd7d6d5d4, 0x3635cfd3d7d6d5d4)
  MISMATCHED_STORE_TEST(165, sw, ld, s0, 29, 31, 0xdbdad9d8, 0x373635cfd3d7dbda)

# cacheline crossing
  MISMATCHED_STORE_TEST(166, sb, lh,  s0, 63, 63, 0xdc, SEXT(0x91dc, 16))
  MISMATCHED_STORE_TEST(167, sb, lhu, s0, 64, 63, 0xdd, 0xdddc)
  MISMATCHED_STORE_TEST(168, sh, lw,  s0, 62, 62, 0xdfde, SEXT(0x92dddfde, 32))
  MISMATCHED_STORE_TEST(169, sh, lw,  s0, 63, 62, 0xe1e0, SEXT(0x92e1e0de, 32))
  MISMATCHED_STORE_TEST(170, sh, lw,  s0, 64, 62, 0xe3e2, SEXT(0xe3e2e0de, 32))

  MISMATCHED_STORE_TEST(171, sb, lwu, s0, 64, 63, 0xe4, 0x93e3e4e0)
  MISMATCHED_STORE_TEST(172, sh, lwu, s0, 63, 61, 0xe6e5, 0xe6e5de80)
  MISMATCHED_STORE_TEST(173, sh, lwu, s0, 64, 62, 0xe8e7, 0xe8e7e5de)

  MISMATCHED_STORE_TEST(174, sb, ld, s0, 64, 57, 0xe9, 0xe9e5de8078706860)
  MISMATCHED_STORE_TEST(175, sh, ld, s0, 63, 58, 0xebea, 0xe8ebeade80787068)
  MISMATCHED_STORE_TEST(176, sh, ld, s0, 63, 59, 0xedec, 0x93e8edecde807870)
  MISMATCHED_STORE_TEST(177, sw, ld, s0, 64, 60, 0xf1f0efee, 0xf1f0efeeecde8078)
  MISMATCHED_STORE_TEST(178, sw, ld, s0, 63, 61, 0xf5f4f3f2, 0x95f1f5f4f3f2de80)
  MISMATCHED_STORE_TEST(179, sw, ld, s0, 62, 62, 0xf9f8f7f6, 0x9695f1f5f9f8f7f6)
  MISMATCHED_STORE_TEST(180, sw, ld, s0, 61, 63, 0xfdfcfbfa, 0x979695f1f5f9fdfc)
#endif

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

data:
  .align 3

.word 0x03020100
.word 0x07060504
.word 0x0b0a0908
.word 0x0f0e0d0c
.word 0x13121110
.word 0x17161514
.word 0x1b1a1918
.word 0x1f1e1d1c
.word 0x23222120
.word 0x27262524
.word 0x2b2a2928
.word 0x2f2e2d2c
.word 0x33323130
.word 0x37363534
.word 0x3b3a3938
.word 0x3f3e3d3c

.word 0x43424140
.word 0x47464544
.word 0x4b4a4948
.word 0x4f4e4d4c
.word 0x53525150
.word 0x57565554
.word 0x5b5a5958
.word 0x5f5e5d5c
.word 0x63626160
.word 0x67666564
.word 0x6b6a6968
.word 0x6f6e6d6c
.word 0x73727170
.word 0x77767574
.word 0x7b7a7978
.word 0x7f7e7d7c

.fill 0xff, 1, 80


  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ld.S
#-----------------------------------------------------------------------------
#
# Test ld instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, ld, 0x00ff00ff00ff00ff, 0,  tdat );
  TEST_LD_OP( 3, ld, 0xff00ff00ff00ff00, 8,  tdat );
  TEST_LD_OP( 4, ld, 0x0ff00ff00ff00ff0, 16, tdat );
  TEST_LD_OP( 5, ld, 0xf00ff00ff00ff00f, 24, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, ld, 0x00ff00ff00ff00ff, -24, tdat4 );
  TEST_LD_OP( 7, ld, 0xff00ff00ff00ff00, -16, tdat4 );
  TEST_LD_OP( 8, ld, 0x0ff00ff00ff00ff0, -8,  tdat4 );
  TEST_LD_OP( 9, ld, 0xf00ff00ff00ff00f, 0,   tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x00ff00ff00ff00ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    ld x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0xff00ff00ff00ff00, \
    la  x1, tdat; \
    addi x1, x1, -3; \
    ld x5, 11(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, ld, 0x0ff00ff00ff00ff0, 8, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, ld, 0xf00ff00ff00ff00f, 8, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, ld, 0xff00ff00ff00ff00, 8, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, ld, 0x0ff00ff00ff00ff0, 8, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, ld, 0xf00ff00ff00ff00f, 8, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, ld, 0xff00ff00ff00ff00, 8, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    ld  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    ld  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .dword 0x00ff00ff00ff00ff
tdat2:  .dword 0xff00ff00ff00ff00
tdat3:  .dword 0x0ff00ff00ff00ff0
tdat4:  .dword 0xf00ff00ff00ff00f

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ld_st.S
#-----------------------------------------------------------------------------
#
# Test load and store instructions
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Bypassing Tests
  #-------------------------------------------------------------

  # Test sb and lb (signed byte)
  TEST_LD_ST_BYPASS(2,  lb,  sb, 0xffffffffffffffdd, 0, tdat );
  TEST_LD_ST_BYPASS(3,  lb,  sb, 0xffffffffffffffcd, 1, tdat );
  TEST_LD_ST_BYPASS(4,  lb,  sb, 0xffffffffffffffcc, 2, tdat );
  TEST_LD_ST_BYPASS(5,  lb,  sb, 0xffffffffffffffbc, 3, tdat );
  TEST_LD_ST_BYPASS(6,  lb,  sb, 0xffffffffffffffbb, 4, tdat );
  TEST_LD_ST_BYPASS(7,  lb,  sb, 0xffffffffffffffab, 5, tdat );

  TEST_LD_ST_BYPASS(8,  lb, sb, 0x33, 0, tdat );
  TEST_LD_ST_BYPASS(9,  lb, sb, 0x23, 1, tdat );
  TEST_LD_ST_BYPASS(10, lb, sb, 0x22, 2, tdat );
  TEST_LD_ST_BYPASS(11, lb, sb, 0x12, 3, tdat );
  TEST_LD_ST_BYPASS(12, lb, sb, 0x11, 4, tdat );
  TEST_LD_ST_BYPASS(13, lb, sb, 0x01, 5, tdat );

  # Test sb and lbu (unsigned byte)
  TEST_LD_ST_BYPASS(14, lbu, sb, 0x33, 0, tdat );
  TEST_LD_ST_BYPASS(15, lbu, sb, 0x23, 1, tdat );
  TEST_LD_ST_BYPASS(16, lbu, sb, 0x22, 2, tdat );
  TEST_LD_ST_BYPASS(17, lbu, sb, 0x12, 3, tdat );
  TEST_LD_ST_BYPASS(18, lbu, sb, 0x11, 4, tdat );
  TEST_LD_ST_BYPASS(19, lbu, sb, 0x01, 5, tdat );

  # Test sw and lw (signed word)
  TEST_LD_ST_BYPASS(20, lw, sw, 0xffffffffaabbccdd, 0,  tdat );
  TEST_LD_ST_BYPASS(21, lw, sw, 0xffffffffdaabbccd, 4,  tdat );
  TEST_LD_ST_BYPASS(22, lw, sw, 0xffffffffddaabbcc, 8,  tdat );
  TEST_LD_ST_BYPASS(23, lw, sw, 0xffffffffcddaabbc, 12, tdat );
  TEST_LD_ST_BYPASS(24, lw, sw, 0xffffffffccddaabb, 16, tdat );
  TEST_LD_ST_BYPASS(25, lw, sw, 0xffffffffbccddaab, 20, tdat );

  TEST_LD_ST_BYPASS(26, lw, sw, 0x00112233, 0,  tdat );
  TEST_LD_ST_BYPASS(27, lw, sw, 0x30011223, 4,  tdat );
  TEST_LD_ST_BYPASS(28, lw, sw, 0x33001122, 8,  tdat );
  TEST_LD_ST_BYPASS(29, lw, sw, 0x23300112, 12, tdat );
  TEST_LD_ST_BYPASS(30, lw, sw, 0x22330011, 16, tdat );
  TEST_LD_ST_BYPASS(31, lw, sw, 0x12233001, 20, tdat );

  # Test sh and lh (signed halfword)
  TEST_LD_ST_BYPASS(32, lh, sh, 0xffffffffffffccdd, 0, tdat );
  TEST_LD_ST_BYPASS(33, lh, sh, 0xffffffffffffbccd, 2, tdat );
  TEST_LD_ST_BYPASS(34, lh, sh, 0xffffffffffffbbcc, 4, tdat );
  TEST_LD_ST_BYPASS(35, lh, sh, 0xffffffffffffabbc, 6, tdat );
  TEST_LD_ST_BYPASS(36, lh, sh, 0xffffffffffffaabb, 8, tdat );
  TEST_LD_ST_BYPASS(37, lh, sh, 0xffffffffffffdaab, 10, tdat );

  TEST_LD_ST_BYPASS(38, lh, sh, 0x2233, 0, tdat );
  TEST_LD_ST_BYPASS(39, lh, sh, 0x1223, 2, tdat );
  TEST_LD_ST_BYPASS(40, lh, sh, 0x1122, 4, tdat );
  TEST_LD_ST_BYPASS(41, lh, sh, 0x0112, 6, tdat );
  TEST_LD_ST_BYPASS(42, lh, sh, 0x0011, 8, tdat );
  TEST_LD_ST_BYPASS(43, lh, sh, 0x3001, 10, tdat );

  # Test sh and lhu (unsigned halfword)
  TEST_LD_ST_BYPASS(44, lhu, sh, 0x2233, 0, tdat );
  TEST_LD_ST_BYPASS(45, lhu, sh, 0x1223, 2, tdat );
  TEST_LD_ST_BYPASS(46, lhu, sh, 0x1122, 4, tdat );
  TEST_LD_ST_BYPASS(47, lhu, sh, 0x0112, 6, tdat );
  TEST_LD_ST_BYPASS(48, lhu, sh, 0x0011, 8, tdat );
  TEST_LD_ST_BYPASS(49, lhu, sh, 0x3001, 10, tdat );

  # RV64-specific tests for ld, sd, and lwu
#if __riscv_xlen == 64
  # Test sd and ld (doubleword)
  TEST_LD_ST_BYPASS(50, ld, sd, 0x0011223344556677, 0,  tdat );
  TEST_LD_ST_BYPASS(51, ld, sd, 0x1122334455667788, 8,  tdat );
  TEST_LD_ST_BYPASS(52, ld, sd, 0x2233445566778899, 16, tdat );
  TEST_LD_ST_BYPASS(53, ld, sd, 0xabbccdd, 0,  tdat );
  TEST_LD_ST_BYPASS(54, ld, sd, 0xaabbccd, 8,  tdat );
  TEST_LD_ST_BYPASS(55, ld, sd, 0xdaabbcc, 16, tdat );
  TEST_LD_ST_BYPASS(56, ld, sd, 0xddaabbc, 24, tdat );
  TEST_LD_ST_BYPASS(57, ld, sd, 0xcddaabb, 32, tdat );
  TEST_LD_ST_BYPASS(58, ld, sd, 0xccddaab, 40, tdat );

  TEST_LD_ST_BYPASS(59, ld, sd, 0x00112233, 0,  tdat );
  TEST_LD_ST_BYPASS(60, ld, sd, 0x30011223, 8,  tdat );
  TEST_LD_ST_BYPASS(61, ld, sd, 0x33001122, 16, tdat );
  TEST_LD_ST_BYPASS(62, ld, sd, 0x23300112, 24, tdat );
  TEST_LD_ST_BYPASS(63, ld, sd, 0x22330011, 32, tdat );
  TEST_LD_ST_BYPASS(64, ld, sd, 0x12233001, 40, tdat );

  # Test sw and lwu (unsigned word)
  TEST_LD_ST_BYPASS(65, lwu, sw, 0x00112233, 0,  tdat );
  TEST_LD_ST_BYPASS(66, lwu, sw, 0x33001122, 8,  tdat );
  TEST_LD_ST_BYPASS(67, lwu, sw, 0x30011223, 4,  tdat );
  TEST_LD_ST_BYPASS(68, lwu, sw, 0x23300112, 12, tdat );
  TEST_LD_ST_BYPASS(69, lwu, sw, 0x22330011, 16, tdat );
  TEST_LD_ST_BYPASS(70, lwu, sw, 0x12233001, 20, tdat );
#endif

  li a0, 0xef         # Immediate load for manual store test
  la a1, tdat         # Load address of tdat
  sb a0, 3(a1)        # Store byte at offset 3 of tdat
  lb a2, 3(a1)        # Load byte back for verification

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
    .rept 20
    .word 0xdeadbeef
    .endr


RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# lhu.S
#-----------------------------------------------------------------------------
#
# Test lhu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lhu, 0x00000000000000ff, 0,  tdat );
  TEST_LD_OP( 3, lhu, 0x000000000000ff00, 2,  tdat );
  TEST_LD_OP( 4, lhu, 0x0000000000000ff0, 4,  tdat );
  TEST_LD_OP( 5, lhu, 0x000000000000f00f, 6, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lhu, 0x00000000000000ff, -6,  tdat4 );
  TEST_LD_OP( 7, lhu, 0x000000000000ff00, -4,  tdat4 );
  TEST_LD_OP( 8, lhu, 0x0000000000000ff0, -2,  tdat4 );
  TEST_LD_OP( 9, lhu, 0x000000000000f00f,  0, tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x00000000000000ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lhu x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x000000000000ff00, \
    la  x1, tdat; \
    addi x1, x1, -5; \
    lhu x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lhu, 0x0000000000000ff0, 2, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lhu, 0x000000000000f00f, 2, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lhu, 0x000000000000ff00, 2, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lhu, 0x0000000000000ff0, 2, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lhu, 0x000000000000f00f, 2, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lhu, 0x000000000000ff00, 2, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lhu  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lhu  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .half 0x00ff
tdat2:  .half 0xff00
tdat3:  .half 0x0ff0
tdat4:  .half 0xf00f

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sllw.S
#-----------------------------------------------------------------------------
#
# Test sllw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sllw, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_RR_OP( 3,  sllw, 0x0000000000000002, 0x0000000000000001, 1  );
  TEST_RR_OP( 4,  sllw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_OP( 5,  sllw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_OP( 6,  sllw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_RR_OP( 7,  sllw, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  sllw, 0xfffffffffffffffe, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  sllw, 0xffffffffffffff80, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, sllw, 0xffffffffffffc000, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, sllw, 0xffffffff80000000, 0xffffffffffffffff, 31 );

  TEST_RR_OP( 12, sllw, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_RR_OP( 13, sllw, 0x0000000042424242, 0x0000000021212121, 1  );
  TEST_RR_OP( 14, sllw, 0xffffffff90909080, 0x0000000021212121, 7  );
  TEST_RR_OP( 15, sllw, 0x0000000048484000, 0x0000000021212121, 14 );
  TEST_RR_OP( 16, sllw, 0xffffffff80000000, 0x0000000021212121, 31 );

  # Verify that shifts only use bottom five bits

  TEST_RR_OP( 17, sllw, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffe0 );
  TEST_RR_OP( 18, sllw, 0x0000000042424242, 0x0000000021212121, 0xffffffffffffffe1 );
  TEST_RR_OP( 19, sllw, 0xffffffff90909080, 0x0000000021212121, 0xffffffffffffffe7 );
  TEST_RR_OP( 20, sllw, 0x0000000048484000, 0x0000000021212121, 0xffffffffffffffee );
  TEST_RR_OP( 21, sllw, 0xffffffff80000000, 0x0000000021212121, 0xffffffffffffffff );

  # Verify that shifts ignore top 32 (using true 64-bit values)

  TEST_RR_OP( 44, sllw, 0x0000000012345678, 0xffffffff12345678, 0 );
  TEST_RR_OP( 45, sllw, 0x0000000023456780, 0xffffffff12345678, 4 );
  TEST_RR_OP( 46, sllw, 0xffffffff92345678, 0x0000000092345678, 0 );
  TEST_RR_OP( 47, sllw, 0xffffffff93456780, 0x0000000099345678, 4 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, sllw, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, sllw, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, sllw, 24, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, sllw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, sllw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, sllw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, sllw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, sllw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, sllw, 0xffffffff80000000, 0x0000000000000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, sllw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, sllw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, sllw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, sllw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, sllw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, sllw, 0xffffffff80000000, 0x0000000000000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, sllw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, sllw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, sllw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_RR_ZEROSRC1( 40, sllw, 0, 15 );
  TEST_RR_ZEROSRC2( 41, sllw, 32, 32 );
  TEST_RR_ZEROSRC12( 42, sllw, 0 );
  TEST_RR_ZERODEST( 43, sllw, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# xori.S
#-----------------------------------------------------------------------------
#
# Test xori instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2, xori, 0xffffffffff00f00f, 0x0000000000ff0f00, 0xf0f );
  TEST_IMM_OP( 3, xori, 0x000000000ff00f00, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_OP( 4, xori, 0x0000000000ff0ff0, 0x0000000000ff08ff, 0x70f );
  TEST_IMM_OP( 5, xori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 6, xori, 0xffffffffff00f00f, 0xffffffffff00f700, 0x70f );

   #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 7,  0, xori, 0x000000000ff00f00, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_DEST_BYPASS( 8,  1, xori, 0x0000000000ff0ff0, 0x0000000000ff08ff, 0x70f );
  TEST_IMM_DEST_BYPASS( 9,  2, xori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  TEST_IMM_SRC1_BYPASS( 10, 0, xori, 0x000000000ff00f00, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_SRC1_BYPASS( 11, 1, xori, 0x0000000000ff0ff0, 0x0000000000ff0fff, 0x00f );
  TEST_IMM_SRC1_BYPASS( 12, 2, xori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  TEST_IMM_ZEROSRC1( 13, xori, 0x0f0, 0x0f0 );
  TEST_IMM_ZERODEST( 14, xori, 0x00ff00ff, 0x70f );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# lui.S
#-----------------------------------------------------------------------------
#
# Test lui instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_CASE( 2, x1, 0x0000000000000000, lui x1, 0x00000 );
  TEST_CASE( 3, x1, 0xfffffffffffff800, lui x1, 0xfffff;sra x1,x1,1);
  TEST_CASE( 4, x1, 0x00000000000007ff, lui x1, 0x7ffff;sra x1,x1,20);
  TEST_CASE( 5, x1, 0xfffffffffffff800, lui x1, 0x80000;sra x1,x1,20);

  TEST_CASE( 6, x0, 0, lui x0, 0x80000 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# slt.S
#-----------------------------------------------------------------------------
#
# Test slt instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  slt, 0, 0x0000000000000000, 0x0000000000000000 );
  TEST_RR_OP( 3,  slt, 0, 0x0000000000000001, 0x0000000000000001 );
  TEST_RR_OP( 4,  slt, 1, 0x0000000000000003, 0x0000000000000007 );
  TEST_RR_OP( 5,  slt, 0, 0x0000000000000007, 0x0000000000000003 );

  TEST_RR_OP( 6,  slt, 0, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 7,  slt, 1, 0xffffffff80000000, 0x0000000000000000 );
  TEST_RR_OP( 8,  slt, 1, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 9,  slt, 1, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 10, slt, 0, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 11, slt, 0, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 12, slt, 1, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 13, slt, 0, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 14, slt, 0, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 15, slt, 1, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 16, slt, 0, 0xffffffffffffffff, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, slt, 0, 14, 13 );
  TEST_RR_SRC2_EQ_DEST( 18, slt, 1, 11, 13 );
  TEST_RR_SRC12_EQ_DEST( 19, slt, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, slt, 1, 11, 13 );
  TEST_RR_DEST_BYPASS( 21, 1, slt, 0, 14, 13 );
  TEST_RR_DEST_BYPASS( 22, 2, slt, 1, 12, 13 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, slt, 0, 14, 13 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, slt, 1, 11, 13 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, slt, 0, 15, 13 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, slt, 1, 10, 13 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, slt, 0, 16, 13 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, slt, 1,  9, 13 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, slt, 0, 17, 13 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, slt, 1,  8, 13 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, slt, 0, 18, 13 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, slt, 1,  7, 13 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, slt, 0, 19, 13 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, slt, 1,  6, 13 );

  TEST_RR_ZEROSRC1( 35, slt, 0, -1 );
  TEST_RR_ZEROSRC2( 36, slt, 1, -1 );
  TEST_RR_ZEROSRC12( 37, slt, 0 );
  TEST_RR_ZERODEST( 38, slt, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# add.S
#-----------------------------------------------------------------------------
#
# Test add instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  add, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  add, 0x00000002, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  add, 0x0000000a, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  add, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  add, 0xffffffff80000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  add, 0xffffffff7fff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  add, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  add, 0x000000007fffffff, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, add, 0x0000000080007ffe, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, add, 0xffffffff80007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, add, 0x000000007fff7fff, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, add, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, add, 0x0000000000000000, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, add, 0xfffffffffffffffe, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, add, 0x0000000080000000, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, add, 24, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, add, 25, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, add, 26, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, add, 24, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, add, 25, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, add, 26, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, add, 24, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, add, 25, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, add, 26, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, add, 24, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, add, 25, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, add, 26, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, add, 24, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, add, 25, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, add, 26, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, add, 24, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, add, 25, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, add, 26, 15, 11 );

  TEST_RR_ZEROSRC1( 35, add, 15, 15 );
  TEST_RR_ZEROSRC2( 36, add, 32, 32 );
  TEST_RR_ZEROSRC12( 37, add, 0 );
  TEST_RR_ZERODEST( 38, add, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sw.S
#-----------------------------------------------------------------------------
#
# Test sw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_ST_OP( 2, lw, sw, 0x0000000000aa00aa, 0,  tdat );
  TEST_ST_OP( 3, lw, sw, 0xffffffffaa00aa00, 4,  tdat );
  TEST_ST_OP( 4, lw, sw, 0x000000000aa00aa0, 8,  tdat );
  TEST_ST_OP( 5, lw, sw, 0xffffffffa00aa00a, 12, tdat );

  # Test with negative offset

  TEST_ST_OP( 6, lw, sw, 0x0000000000aa00aa, -12, tdat8 );
  TEST_ST_OP( 7, lw, sw, 0xffffffffaa00aa00, -8,  tdat8 );
  TEST_ST_OP( 8, lw, sw, 0x000000000aa00aa0, -4,  tdat8 );
  TEST_ST_OP( 9, lw, sw, 0xffffffffa00aa00a, 0,   tdat8 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x12345678, \
    la  x1, tdat9; \
    li  x2, 0x12345678; \
    addi x4, x1, -32; \
    sw x2, 32(x4); \
    lw x5, 0(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x58213098, \
    la  x1, tdat9; \
    li  x2, 0x58213098; \
    addi x1, x1, -3; \
    sw x2, 7(x1); \
    la  x4, tdat10; \
    lw x5, 0(x4); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_ST_SRC12_BYPASS( 12, 0, 0, lw, sw, 0xffffffffaabbccdd, 0,  tdat );
  TEST_ST_SRC12_BYPASS( 13, 0, 1, lw, sw, 0xffffffffdaabbccd, 4,  tdat );
  TEST_ST_SRC12_BYPASS( 14, 0, 2, lw, sw, 0xffffffffddaabbcc, 8,  tdat );
  TEST_ST_SRC12_BYPASS( 15, 1, 0, lw, sw, 0xffffffffcddaabbc, 12, tdat );
  TEST_ST_SRC12_BYPASS( 16, 1, 1, lw, sw, 0xffffffffccddaabb, 16, tdat );
  TEST_ST_SRC12_BYPASS( 17, 2, 0, lw, sw, 0xffffffffbccddaab, 20, tdat );

  TEST_ST_SRC21_BYPASS( 18, 0, 0, lw, sw, 0x00112233, 0,  tdat );
  TEST_ST_SRC21_BYPASS( 19, 0, 1, lw, sw, 0x30011223, 4,  tdat );
  TEST_ST_SRC21_BYPASS( 20, 0, 2, lw, sw, 0x33001122, 8,  tdat );
  TEST_ST_SRC21_BYPASS( 21, 1, 0, lw, sw, 0x23300112, 12, tdat );
  TEST_ST_SRC21_BYPASS( 22, 1, 1, lw, sw, 0x22330011, 16, tdat );
  TEST_ST_SRC21_BYPASS( 23, 2, 0, lw, sw, 0x12233001, 20, tdat );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .word 0xdeadbeef
tdat2:  .word 0xdeadbeef
tdat3:  .word 0xdeadbeef
tdat4:  .word 0xdeadbeef
tdat5:  .word 0xdeadbeef
tdat6:  .word 0xdeadbeef
tdat7:  .word 0xdeadbeef
tdat8:  .word 0xdeadbeef
tdat9:  .word 0xdeadbeef
tdat10: .word 0xdeadbeef

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sub.S
#-----------------------------------------------------------------------------
#
# Test sub instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sub, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 );
  TEST_RR_OP( 3,  sub, 0x0000000000000000, 0x0000000000000001, 0x0000000000000001 );
  TEST_RR_OP( 4,  sub, 0xfffffffffffffffc, 0x0000000000000003, 0x0000000000000007 );

  TEST_RR_OP( 5,  sub, 0x0000000000008000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  sub, 0xffffffff80000000, 0xffffffff80000000, 0x0000000000000000 );
  TEST_RR_OP( 7,  sub, 0xffffffff80008000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  sub, 0xffffffffffff8001, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  sub, 0x000000007fffffff, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, sub, 0x000000007fff8000, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, sub, 0xffffffff7fff8001, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, sub, 0x0000000080007fff, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, sub, 0x0000000000000001, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, sub, 0xfffffffffffffffe, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, sub, 0x0000000000000000, 0xffffffffffffffff, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 16, sub, 2, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 17, sub, 3, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 18, sub, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 19, 0, sub, 2, 13, 11 );
  TEST_RR_DEST_BYPASS( 20, 1, sub, 3, 14, 11 );
  TEST_RR_DEST_BYPASS( 21, 2, sub, 4, 15, 11 );

  TEST_RR_SRC12_BYPASS( 22, 0, 0, sub, 2, 13, 11 );
  TEST_RR_SRC12_BYPASS( 23, 0, 1, sub, 3, 14, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 2, sub, 4, 15, 11 );
  TEST_RR_SRC12_BYPASS( 25, 1, 0, sub, 2, 13, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 1, sub, 3, 14, 11 );
  TEST_RR_SRC12_BYPASS( 27, 2, 0, sub, 4, 15, 11 );

  TEST_RR_SRC21_BYPASS( 28, 0, 0, sub, 2, 13, 11 );
  TEST_RR_SRC21_BYPASS( 29, 0, 1, sub, 3, 14, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 2, sub, 4, 15, 11 );
  TEST_RR_SRC21_BYPASS( 31, 1, 0, sub, 2, 13, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 1, sub, 3, 14, 11 );
  TEST_RR_SRC21_BYPASS( 33, 2, 0, sub, 4, 15, 11 );

  TEST_RR_ZEROSRC1( 34, sub, 15, -15 );
  TEST_RR_ZEROSRC2( 35, sub, 32, 32 );
  TEST_RR_ZEROSRC12( 36, sub, 0 );
  TEST_RR_ZERODEST( 37, sub, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bltu.S
#-----------------------------------------------------------------------------
#
# Test bltu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, bltu, 0x00000000, 0x00000001 );
  TEST_BR2_OP_TAKEN( 3, bltu, 0xfffffffe, 0xffffffff );
  TEST_BR2_OP_TAKEN( 4, bltu, 0x00000000, 0xffffffff );

  TEST_BR2_OP_NOTTAKEN( 5, bltu, 0x00000001, 0x00000000 );
  TEST_BR2_OP_NOTTAKEN( 6, bltu, 0xffffffff, 0xfffffffe );
  TEST_BR2_OP_NOTTAKEN( 7, bltu, 0xffffffff, 0x00000000 );
  TEST_BR2_OP_NOTTAKEN( 8, bltu, 0x80000000, 0x7fffffff );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 9,  0, 0, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 10, 0, 1, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 11, 0, 2, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 12, 1, 0, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 13, 1, 1, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 14, 2, 0, bltu, 0xf0000000, 0xefffffff );

  TEST_BR2_SRC12_BYPASS( 15, 0, 0, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 16, 0, 1, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 17, 0, 2, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 18, 1, 0, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 19, 1, 1, bltu, 0xf0000000, 0xefffffff );
  TEST_BR2_SRC12_BYPASS( 20, 2, 0, bltu, 0xf0000000, 0xefffffff );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 21, x1, 3, \
    li  x1, 1; \
    bltu x0, x1, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bge.S
#-----------------------------------------------------------------------------
#
# Test bge instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, bge,  0,  0 );
  TEST_BR2_OP_TAKEN( 3, bge,  1,  1 );
  TEST_BR2_OP_TAKEN( 4, bge, -1, -1 );
  TEST_BR2_OP_TAKEN( 5, bge,  1,  0 );
  TEST_BR2_OP_TAKEN( 6, bge,  1, -1 );
  TEST_BR2_OP_TAKEN( 7, bge, -1, -2 );

  TEST_BR2_OP_NOTTAKEN(  8, bge,  0,  1 );
  TEST_BR2_OP_NOTTAKEN(  9, bge, -1,  1 );
  TEST_BR2_OP_NOTTAKEN( 10, bge, -2, -1 );
  TEST_BR2_OP_NOTTAKEN( 11, bge, -2,  1 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 12, 0, 0, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 13, 0, 1, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 14, 0, 2, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 15, 1, 0, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 16, 1, 1, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 17, 2, 0, bge, -1, 0 );

  TEST_BR2_SRC12_BYPASS( 18, 0, 0, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 19, 0, 1, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 20, 0, 2, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 21, 1, 0, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 22, 1, 1, bge, -1, 0 );
  TEST_BR2_SRC12_BYPASS( 23, 2, 0, bge, -1, 0 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 24, x1, 3, \
    li  x1, 1; \
    bge x1, x0, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sltiu.S
#-----------------------------------------------------------------------------
#
# Test sltiu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  sltiu, 0, 0x0000000000000000, 0x000 );
  TEST_IMM_OP( 3,  sltiu, 0, 0x0000000000000001, 0x001 );
  TEST_IMM_OP( 4,  sltiu, 1, 0x0000000000000003, 0x007 );
  TEST_IMM_OP( 5,  sltiu, 0, 0x0000000000000007, 0x003 );

  TEST_IMM_OP( 6,  sltiu, 1, 0x0000000000000000, 0x800 );
  TEST_IMM_OP( 7,  sltiu, 0, 0xffffffff80000000, 0x000 );
  TEST_IMM_OP( 8,  sltiu, 1, 0xffffffff80000000, 0x800 );

  TEST_IMM_OP( 9,  sltiu, 1, 0x0000000000000000, 0x7ff );
  TEST_IMM_OP( 10, sltiu, 0, 0x000000007fffffff, 0x000 );
  TEST_IMM_OP( 11, sltiu, 0, 0x000000007fffffff, 0x7ff );

  TEST_IMM_OP( 12, sltiu, 0, 0xffffffff80000000, 0x7ff );
  TEST_IMM_OP( 13, sltiu, 1, 0x000000007fffffff, 0x800 );

  TEST_IMM_OP( 14, sltiu, 1, 0x0000000000000000, 0xfff );
  TEST_IMM_OP( 15, sltiu, 0, 0xffffffffffffffff, 0x001 );
  TEST_IMM_OP( 16, sltiu, 0, 0xffffffffffffffff, 0xfff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, sltiu, 1, 11, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, sltiu, 0, 15, 10 );
  TEST_IMM_DEST_BYPASS( 19, 1, sltiu, 1, 10, 16 );
  TEST_IMM_DEST_BYPASS( 20, 2, sltiu, 0, 16,  9 );

  TEST_IMM_SRC1_BYPASS( 21, 0, sltiu, 1, 11, 15 );
  TEST_IMM_SRC1_BYPASS( 22, 1, sltiu, 0, 17,  8 );
  TEST_IMM_SRC1_BYPASS( 23, 2, sltiu, 1, 12, 14 );

  TEST_IMM_ZEROSRC1( 24, sltiu, 1, 0xfff );
  TEST_IMM_ZERODEST( 25, sltiu, 0x00ff00ff, 0xfff );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# blt.S
#-----------------------------------------------------------------------------
#
# Test blt instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, blt,  0,  1 );
  TEST_BR2_OP_TAKEN( 3, blt, -1,  1 );
  TEST_BR2_OP_TAKEN( 4, blt, -2, -1 );

  TEST_BR2_OP_NOTTAKEN( 5, blt,  1,  0 );
  TEST_BR2_OP_NOTTAKEN( 6, blt,  1, -1 );
  TEST_BR2_OP_NOTTAKEN( 7, blt, -1, -2 );
  TEST_BR2_OP_NOTTAKEN( 8, blt,  1, -2 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 9,  0, 0, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 10, 0, 1, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 11, 0, 2, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 12, 1, 0, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 13, 1, 1, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 14, 2, 0, blt, 0, -1 );

  TEST_BR2_SRC12_BYPASS( 15, 0, 0, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 16, 0, 1, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 17, 0, 2, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 18, 1, 0, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 19, 1, 1, blt, 0, -1 );
  TEST_BR2_SRC12_BYPASS( 20, 2, 0, blt, 0, -1 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 21, x1, 3, \
    li  x1, 1; \
    blt x0, x1, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# jalr.S
#-----------------------------------------------------------------------------
#
# Test jalr instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Test 2: Basic test
  #-------------------------------------------------------------

test_2:
  li  TESTNUM, 2
  li  t0, 0
  la  t1, target_2

  jalr t0, t1, 0
linkaddr_2:
  j fail

target_2:
  la  t1, linkaddr_2
  bne t0, t1, fail

  #-------------------------------------------------------------
  # Test 3: Basic test2, rs = rd
  #-------------------------------------------------------------

test_3:
  li  TESTNUM, 3
  la  t0, target_3

  jalr t0, t0, 0
linkaddr_3:
  j fail

target_3:
  la  t1, linkaddr_3
  bne t0, t1, fail

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_JALR_SRC1_BYPASS( 4, 0, jalr );
  TEST_JALR_SRC1_BYPASS( 5, 1, jalr );
  TEST_JALR_SRC1_BYPASS( 6, 2, jalr );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  .option push
  .align 2
  .option norvc
  TEST_CASE( 7, t0, 4, \
    li  t0, 1; \
    la  t1, 1f; \
    jr  t1, -4; \
    addi t0, t0, 1; \
    addi t0, t0, 1; \
    addi t0, t0, 1; \
    addi t0, t0, 1; \
1:  addi t0, t0, 1; \
    addi t0, t0, 1; \
  )
  .option pop

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# addw.S
#-----------------------------------------------------------------------------
#
# Test addw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  addw, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  addw, 0x00000002, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  addw, 0x0000000a, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  addw, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  addw, 0xffffffff80000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  addw, 0x000000007fff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  addw, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  addw, 0x000000007fffffff, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, addw, 0xffffffff80007ffe, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, addw, 0xffffffff80007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, addw, 0x000000007fff7fff, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, addw, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, addw, 0x0000000000000000, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, addw, 0xfffffffffffffffe, 0xffffffffffffffff, 0xffffffffffffffff );

  TEST_RR_OP( 16, addw, 0xffffffff80000000, 0x0000000000000001, 0x000000007fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, addw, 24, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, addw, 25, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, addw, 26, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, addw, 24, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, addw, 25, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, addw, 26, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, addw, 24, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, addw, 25, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, addw, 26, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, addw, 24, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, addw, 25, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, addw, 26, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, addw, 24, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, addw, 25, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, addw, 26, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, addw, 24, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, addw, 25, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, addw, 26, 15, 11 );

  TEST_RR_ZEROSRC1( 35, addw, 15, 15 );
  TEST_RR_ZEROSRC2( 36, addw, 32, 32 );
  TEST_RR_ZEROSRC12( 37, addw, 0 );
  TEST_RR_ZERODEST( 38, addw, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sll.S
#-----------------------------------------------------------------------------
#
# Test sll instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sll, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_RR_OP( 3,  sll, 0x0000000000000002, 0x0000000000000001, 1  );
  TEST_RR_OP( 4,  sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_OP( 5,  sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_OP( 6,  sll, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_OP( 7,  sll, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  sll, 0xfffffffffffffffe, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  sll, 0xffffffffffffff80, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, sll, 0xffffffffffffc000, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, sll, 0xffffffff80000000, 0xffffffffffffffff, 31 );

  TEST_RR_OP( 12, sll, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_RR_OP( 13, sll, 0x0000000042424242, 0x0000000021212121, 1  );
  TEST_RR_OP( 14, sll, 0x0000001090909080, 0x0000000021212121, 7  );
  TEST_RR_OP( 15, sll, 0x0000084848484000, 0x0000000021212121, 14 );
  TEST_RR_OP( 16, sll, 0x1090909080000000, 0x0000000021212121, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, sll, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, sll, 0x0000000042424242, 0x0000000021212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, sll, 0x0000001090909080, 0x0000000021212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, sll, 0x0000084848484000, 0x0000000021212121, 0xffffffffffffffce );

#if __riscv_xlen == 64
  TEST_RR_OP( 21, sll, 0x8000000000000000, 0x0000000021212121, 0xffffffffffffffff );
  TEST_RR_OP( 50, sll, 0x8000000000000000, 0x0000000000000001, 63 );
  TEST_RR_OP( 51, sll, 0xffffff8000000000, 0xffffffffffffffff, 39 );
  TEST_RR_OP( 52, sll, 0x0909080000000000, 0x0000000021212121, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, sll, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, sll, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, sll, 24, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, sll, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, sll, 0x0000000080000000, 0x0000000000000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, sll, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, sll, 0x0000000080000000, 0x0000000000000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, sll, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, sll, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, sll, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_ZEROSRC1( 40, sll, 0, 15 );
  TEST_RR_ZEROSRC2( 41, sll, 32, 32 );
  TEST_RR_ZEROSRC12( 42, sll, 0 );
  TEST_RR_ZERODEST( 43, sll, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# srliw.S
#-----------------------------------------------------------------------------
#
# Test srliw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  srliw, 0xffffffff80000000, 0xffffffff80000000, 0  );
  TEST_IMM_OP( 3,  srliw, 0x0000000040000000, 0xffffffff80000000, 1  );
  TEST_IMM_OP( 4,  srliw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_IMM_OP( 5,  srliw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_IMM_OP( 6,  srliw, 0x0000000000000001, 0xffffffff80000001, 31 );

  TEST_IMM_OP( 7,  srliw, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  srliw, 0x000000007fffffff, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  srliw, 0x0000000001ffffff, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, srliw, 0x000000000003ffff, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, srliw, 0x0000000000000001, 0xffffffffffffffff, 31 );

  TEST_IMM_OP( 12, srliw, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_IMM_OP( 13, srliw, 0x0000000010909090, 0x0000000021212121, 1  );
  TEST_IMM_OP( 14, srliw, 0x0000000000424242, 0x0000000021212121, 7  );
  TEST_IMM_OP( 15, srliw, 0x0000000000008484, 0x0000000021212121, 14 );
  TEST_IMM_OP( 16, srliw, 0x0000000000000000, 0x0000000021212121, 31 );

  # Verify that shifts ignore top 32 (using true 64-bit values)

  TEST_IMM_OP( 44, srliw, 0x0000000012345678, 0xffffffff12345678, 0 );
  TEST_IMM_OP( 45, srliw, 0x0000000001234567, 0xffffffff12345678, 4 );
  TEST_IMM_OP( 46, srliw, 0xffffffff92345678, 0x0000000092345678, 0 );
  TEST_IMM_OP( 47, srliw, 0x0000000009234567, 0x0000000092345678, 4 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, srliw, 0x0000000001000000, 0xffffffff80000000, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, srliw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, srliw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, srliw, 0x0000000000000001, 0xffffffff80000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, srliw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_IMM_SRC1_BYPASS( 22, 1, srliw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, srliw, 0x0000000000000001, 0xffffffff80000001, 31 );

  TEST_IMM_ZEROSRC1( 24, srliw, 0, 31 );
  TEST_IMM_ZERODEST( 25, srliw, 31, 28 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sraiw.S
#-----------------------------------------------------------------------------
#
# Test sraiw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  sraiw, 0xffffffff80000000, 0xffffffff80000000, 0  );
  TEST_IMM_OP( 3,  sraiw, 0xffffffffc0000000, 0xffffffff80000000, 1  );
  TEST_IMM_OP( 4,  sraiw, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_IMM_OP( 5,  sraiw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_IMM_OP( 6,  sraiw, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_IMM_OP( 7,  sraiw, 0x000000007fffffff, 0x000000007fffffff, 0  );
  TEST_IMM_OP( 8,  sraiw, 0x000000003fffffff, 0x000000007fffffff, 1  );
  TEST_IMM_OP( 9,  sraiw, 0x0000000000ffffff, 0x000000007fffffff, 7  );
  TEST_IMM_OP( 10, sraiw, 0x000000000001ffff, 0x000000007fffffff, 14 );
  TEST_IMM_OP( 11, sraiw, 0x0000000000000000, 0x000000007fffffff, 31 );

  TEST_IMM_OP( 12, sraiw, 0xffffffff81818181, 0xffffffff81818181, 0  );
  TEST_IMM_OP( 13, sraiw, 0xffffffffc0c0c0c0, 0xffffffff81818181, 1  );
  TEST_IMM_OP( 14, sraiw, 0xffffffffff030303, 0xffffffff81818181, 7  );
  TEST_IMM_OP( 15, sraiw, 0xfffffffffffe0606, 0xffffffff81818181, 14 );
  TEST_IMM_OP( 16, sraiw, 0xffffffffffffffff, 0xffffffff81818181, 31 );

  # Verify that shifts ignore top 32 (using true 64-bit values)

  TEST_IMM_OP( 44, sraiw, 0x0000000012345678, 0xffffffff12345678, 0 );
  TEST_IMM_OP( 45, sraiw, 0x0000000001234567, 0xffffffff12345678, 4 );
  TEST_IMM_OP( 46, sraiw, 0xffffffff92345678, 0x0000000092345678, 0 );
  TEST_IMM_OP( 47, sraiw, 0xfffffffff9234567, 0x0000000092345678, 4 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, sraiw, 0xffffffffff000000, 0xffffffff80000000, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, sraiw, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, sraiw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, sraiw, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, sraiw, 0xffffffffff000000, 0xffffffff80000000, 7 );
  TEST_IMM_SRC1_BYPASS( 22, 1, sraiw, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, sraiw, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_IMM_ZEROSRC1( 24, sraiw, 0, 31 );
  TEST_IMM_ZERODEST( 25, sraiw, 31, 28 );

  TEST_IMM_OP( 26, sraiw, 0x0000000000000000, 0x00e0000000000000, 28)
  TEST_IMM_OP( 27, sraiw, 0xffffffffff000000, 0x00000000f0000000, 4)

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# st_ld.S
#-----------------------------------------------------------------------------
#
# Test store and load instructions
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Bypassing Tests
  #-------------------------------------------------------------

  # Test sb and lb (signed byte)
  TEST_ST_LD_BYPASS(2,  lb,  sb, 0xffffffffffffffdd, 0, tdat );
  TEST_ST_LD_BYPASS(3,  lb,  sb, 0xffffffffffffffcd, 1, tdat );
  TEST_ST_LD_BYPASS(4,  lb,  sb, 0xffffffffffffffcc, 2, tdat );
  TEST_ST_LD_BYPASS(5,  lb,  sb, 0xffffffffffffffbc, 3, tdat );
  TEST_ST_LD_BYPASS(6,  lb,  sb, 0xffffffffffffffbb, 4, tdat );
  TEST_ST_LD_BYPASS(7,  lb,  sb, 0xffffffffffffffab, 5, tdat );

  TEST_ST_LD_BYPASS(8,  lb, sb, 0x33, 0, tdat );
  TEST_ST_LD_BYPASS(9,  lb, sb, 0x23, 1, tdat );
  TEST_ST_LD_BYPASS(10, lb, sb, 0x22, 2, tdat );
  TEST_ST_LD_BYPASS(11, lb, sb, 0x12, 3, tdat );
  TEST_ST_LD_BYPASS(12, lb, sb, 0x11, 4, tdat );
  TEST_ST_LD_BYPASS(13, lb, sb, 0x01, 5, tdat );

  # Test sb and lbu (unsigned byte)
  TEST_ST_LD_BYPASS(14, lbu, sb, 0x33, 0, tdat );
  TEST_ST_LD_BYPASS(15, lbu, sb, 0x23, 1, tdat );
  TEST_ST_LD_BYPASS(16, lbu, sb, 0x22, 2, tdat );
  TEST_ST_LD_BYPASS(17, lbu, sb, 0x12, 3, tdat );
  TEST_ST_LD_BYPASS(18, lbu, sb, 0x11, 4, tdat );
  TEST_ST_LD_BYPASS(19, lbu, sb, 0x01, 5, tdat );

  # Test sw and lw (signed word)
  TEST_ST_LD_BYPASS(20, lw, sw, 0xffffffffaabbccdd, 0,  tdat );
  TEST_ST_LD_BYPASS(21, lw, sw, 0xffffffffdaabbccd, 4,  tdat );
  TEST_ST_LD_BYPASS(22, lw, sw, 0xffffffffddaabbcc, 8,  tdat );
  TEST_ST_LD_BYPASS(23, lw, sw, 0xffffffffcddaabbc, 12, tdat );
  TEST_ST_LD_BYPASS(24, lw, sw, 0xffffffffccddaabb, 16, tdat );
  TEST_ST_LD_BYPASS(25, lw, sw, 0xffffffffbccddaab, 20, tdat );

  TEST_ST_LD_BYPASS(26, lw, sw, 0x00112233, 0,  tdat );
  TEST_ST_LD_BYPASS(27, lw, sw, 0x30011223, 4,  tdat );
  TEST_ST_LD_BYPASS(28, lw, sw, 0x33001122, 8,  tdat );
  TEST_ST_LD_BYPASS(29, lw, sw, 0x23300112, 12, tdat );
  TEST_ST_LD_BYPASS(30, lw, sw, 0x22330011, 16, tdat );
  TEST_ST_LD_BYPASS(31, lw, sw, 0x12233001, 20, tdat );

  # Test sh and lh (signed halfword)
  TEST_ST_LD_BYPASS(32, lh, sh, 0xffffffffffffccdd, 0, tdat );
  TEST_ST_LD_BYPASS(33, lh, sh, 0xffffffffffffbccd, 2, tdat );
  TEST_ST_LD_BYPASS(34, lh, sh, 0xffffffffffffbbcc, 4, tdat );
  TEST_ST_LD_BYPASS(35, lh, sh, 0xffffffffffffabbc, 6, tdat );
  TEST_ST_LD_BYPASS(36, lh, sh, 0xffffffffffffaabb, 8, tdat );
  TEST_ST_LD_BYPASS(37, lh, sh, 0xffffffffffffdaab, 10, tdat );

  TEST_ST_LD_BYPASS(38, lh, sh, 0x2233, 0, tdat );
  TEST_ST_LD_BYPASS(39, lh, sh, 0x1223, 2, tdat );
  TEST_ST_LD_BYPASS(40, lh, sh, 0x1122, 4, tdat );
  TEST_ST_LD_BYPASS(41, lh, sh, 0x0112, 6, tdat );
  TEST_ST_LD_BYPASS(42, lh, sh, 0x0011, 8, tdat );
  TEST_ST_LD_BYPASS(43, lh, sh, 0x3001, 10, tdat );

  # Test sh and lhu (unsigned halfword)
  TEST_ST_LD_BYPASS(44, lhu, sh, 0x2233, 0, tdat );
  TEST_ST_LD_BYPASS(45, lhu, sh, 0x1223, 2, tdat );
  TEST_ST_LD_BYPASS(46, lhu, sh, 0x1122, 4, tdat );
  TEST_ST_LD_BYPASS(47, lhu, sh, 0x0112, 6, tdat );
  TEST_ST_LD_BYPASS(48, lhu, sh, 0x0011, 8, tdat );
  TEST_ST_LD_BYPASS(49, lhu, sh, 0x3001, 10, tdat );

  # RV64-specific tests for ld, sd, and lwu
#if __riscv_xlen == 64
  # Test sd and ld (doubleword)
  TEST_ST_LD_BYPASS(50, ld, sd, 0x0011223344556677, 0,  tdat );
  TEST_ST_LD_BYPASS(51, ld, sd, 0x1122334455667788, 8,  tdat );
  TEST_ST_LD_BYPASS(52, ld, sd, 0x2233445566778899, 16, tdat );
  TEST_ST_LD_BYPASS(53, ld, sd, 0xabbccdd, 0,  tdat );
  TEST_ST_LD_BYPASS(54, ld, sd, 0xaabbccd, 8,  tdat );
  TEST_ST_LD_BYPASS(55, ld, sd, 0xdaabbcc, 16, tdat );
  TEST_ST_LD_BYPASS(56, ld, sd, 0xddaabbc, 24, tdat );
  TEST_ST_LD_BYPASS(57, ld, sd, 0xcddaabb, 32, tdat );
  TEST_ST_LD_BYPASS(58, ld, sd, 0xccddaab, 40, tdat );

  TEST_ST_LD_BYPASS(59, ld, sd, 0x00112233, 0,  tdat );
  TEST_ST_LD_BYPASS(60, ld, sd, 0x30011223, 8,  tdat );
  TEST_ST_LD_BYPASS(61, ld, sd, 0x33001122, 16, tdat );
  TEST_ST_LD_BYPASS(62, ld, sd, 0x23300112, 24, tdat );
  TEST_ST_LD_BYPASS(63, ld, sd, 0x22330011, 32, tdat );
  TEST_ST_LD_BYPASS(64, ld, sd, 0x12233001, 40, tdat );

  # Test sw and lwu (unsigned word)
  TEST_ST_LD_BYPASS(65, lwu, sw, 0x00112233, 0,  tdat );
  TEST_ST_LD_BYPASS(66, lwu, sw, 0x33001122, 8,  tdat );
  TEST_ST_LD_BYPASS(67, lwu, sw, 0x30011223, 4,  tdat );
  TEST_ST_LD_BYPASS(68, lwu, sw, 0x23300112, 12, tdat );
  TEST_ST_LD_BYPASS(69, lwu, sw, 0x22330011, 16, tdat );
  TEST_ST_LD_BYPASS(70, lwu, sw, 0x12233001, 20, tdat );
#endif

  li a0, 0xef         # Immediate load for manual store test
  la a1, tdat         # Load address of tdat
  sb a0, 3(a1)        # Store byte at offset 3 of tdat
  lb a2, 3(a1)        # Load byte back for verification

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
    .rept 20
    .word 0xdeadbeef
    .endr


RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# srai.S
#-----------------------------------------------------------------------------
#
# Test srai instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  srai, 0xffffff8000000000, 0xffffff8000000000, 0  );
  TEST_IMM_OP( 3,  srai, 0xffffffffc0000000, 0xffffffff80000000, 1  );
  TEST_IMM_OP( 4,  srai, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_IMM_OP( 5,  srai, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_IMM_OP( 6,  srai, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_IMM_OP( 7,  srai, 0x000000007fffffff, 0x000000007fffffff, 0  );
  TEST_IMM_OP( 8,  srai, 0x000000003fffffff, 0x000000007fffffff, 1  );
  TEST_IMM_OP( 9,  srai, 0x0000000000ffffff, 0x000000007fffffff, 7  );
  TEST_IMM_OP( 10, srai, 0x000000000001ffff, 0x000000007fffffff, 14 );
  TEST_IMM_OP( 11, srai, 0x0000000000000000, 0x000000007fffffff, 31 );

  TEST_IMM_OP( 12, srai, 0xffffffff81818181, 0xffffffff81818181, 0  );
  TEST_IMM_OP( 13, srai, 0xffffffffc0c0c0c0, 0xffffffff81818181, 1  );
  TEST_IMM_OP( 14, srai, 0xffffffffff030303, 0xffffffff81818181, 7  );
  TEST_IMM_OP( 15, srai, 0xfffffffffffe0606, 0xffffffff81818181, 14 );
  TEST_IMM_OP( 16, srai, 0xffffffffffffffff, 0xffffffff81818181, 31 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, srai, 0xffffffffff000000, 0xffffffff80000000, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, srai, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, srai, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, srai, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, srai, 0xffffffffff000000, 0xffffffff80000000, 7 );
  TEST_IMM_SRC1_BYPASS( 22, 1, srai, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, srai, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_IMM_ZEROSRC1( 24, srai, 0, 4 );
  TEST_IMM_ZERODEST( 25, srai, 33, 10 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# srlw.S
#-----------------------------------------------------------------------------
#
# Test srlw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  srlw, 0xffffffff80000000, 0xffffffff80000000, 0  );
  TEST_RR_OP( 3,  srlw, 0x0000000040000000, 0xffffffff80000000, 1  );
  TEST_RR_OP( 4,  srlw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_RR_OP( 5,  srlw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_RR_OP( 6,  srlw, 0x0000000000000001, 0xffffffff80000001, 31 );

  TEST_RR_OP( 7,  srlw, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  srlw, 0x000000007fffffff, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  srlw, 0x0000000001ffffff, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, srlw, 0x000000000003ffff, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, srlw, 0x0000000000000001, 0xffffffffffffffff, 31 );

  TEST_RR_OP( 12, srlw, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_RR_OP( 13, srlw, 0x0000000010909090, 0x0000000021212121, 1  );
  TEST_RR_OP( 14, srlw, 0x0000000000424242, 0x0000000021212121, 7  );
  TEST_RR_OP( 15, srlw, 0x0000000000008484, 0x0000000021212121, 14 );
  TEST_RR_OP( 16, srlw, 0x0000000000000000, 0x0000000021212121, 31 );

  # Verify that shifts only use bottom five bits

  TEST_RR_OP( 17, srlw, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffe0 );
  TEST_RR_OP( 18, srlw, 0x0000000010909090, 0x0000000021212121, 0xffffffffffffffe1 );
  TEST_RR_OP( 19, srlw, 0x0000000000424242, 0x0000000021212121, 0xffffffffffffffe7 );
  TEST_RR_OP( 20, srlw, 0x0000000000008484, 0x0000000021212121, 0xffffffffffffffee );
  TEST_RR_OP( 21, srlw, 0x0000000000000000, 0x0000000021212121, 0xffffffffffffffff );

  # Verify that shifts ignore top 32 (using true 64-bit values)

  TEST_RR_OP( 44, srlw, 0x0000000012345678, 0xffffffff12345678, 0 );
  TEST_RR_OP( 45, srlw, 0x0000000001234567, 0xffffffff12345678, 4 );
  TEST_RR_OP( 46, srlw, 0xffffffff92345678, 0x0000000092345678, 0 );
  TEST_RR_OP( 47, srlw, 0x0000000009234567, 0x0000000092345678, 4 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, srlw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, srlw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, srlw, 0, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, srlw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, srlw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, srlw, 0x0000000000000001, 0xffffffff80000000, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, srlw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, srlw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, srlw, 0x0000000000000001, 0xffffffff80000000, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, srlw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, srlw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, srlw, 0x0000000000000001, 0xffffffff80000000, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, srlw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, srlw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, srlw, 0x0000000000000001, 0xffffffff80000000, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, srlw, 0x0000000001000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, srlw, 0x0000000000020000, 0xffffffff80000000, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, srlw, 0x0000000000000001, 0xffffffff80000000, 31 );

  TEST_RR_ZEROSRC1( 40, srlw, 0, 15 );
  TEST_RR_ZEROSRC2( 41, srlw, 32, 32 );
  TEST_RR_ZEROSRC12( 42, srlw, 0 );
  TEST_RR_ZERODEST( 43, srlw, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# or.S
#-----------------------------------------------------------------------------
#
# Test or instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_OP( 3, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_OP( 4, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_OP( 5, or, 0xf0fff0ff, 0xf00ff00f, 0xf0f0f0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 6, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC2_EQ_DEST( 7, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_EQ_DEST( 8, or, 0xff00ff00, 0xff00ff00 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 9,  0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_DEST_BYPASS( 10, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_DEST_BYPASS( 11, 2, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC12_BYPASS( 12, 0, 0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 13, 0, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 14, 0, 2, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 15, 1, 0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 16, 1, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 17, 2, 0, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC21_BYPASS( 18, 0, 0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 19, 0, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 20, 0, 2, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 21, 1, 0, or, 0xff0fff0f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 22, 1, 1, or, 0xfff0fff0, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 23, 2, 0, or, 0x0fff0fff, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_ZEROSRC1( 24, or, 0xff00ff00, 0xff00ff00 );
  TEST_RR_ZEROSRC2( 25, or, 0x00ff00ff, 0x00ff00ff );
  TEST_RR_ZEROSRC12( 26, or, 0 );
  TEST_RR_ZERODEST( 27, or, 0x11111111, 0x22222222 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# lw.S
#-----------------------------------------------------------------------------
#
# Test lw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lw, 0x0000000000ff00ff, 0,  tdat );
  TEST_LD_OP( 3, lw, 0xffffffffff00ff00, 4,  tdat );
  TEST_LD_OP( 4, lw, 0x000000000ff00ff0, 8,  tdat );
  TEST_LD_OP( 5, lw, 0xfffffffff00ff00f, 12, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lw, 0x0000000000ff00ff, -12, tdat4 );
  TEST_LD_OP( 7, lw, 0xffffffffff00ff00, -8,  tdat4 );
  TEST_LD_OP( 8, lw, 0x000000000ff00ff0, -4,  tdat4 );
  TEST_LD_OP( 9, lw, 0xfffffffff00ff00f, 0,   tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x0000000000ff00ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lw x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0xffffffffff00ff00, \
    la  x1, tdat; \
    addi x1, x1, -3; \
    lw x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lw, 0x000000000ff00ff0, 4, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lw, 0xfffffffff00ff00f, 4, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lw, 0xffffffffff00ff00, 4, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lw, 0x000000000ff00ff0, 4, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lw, 0xfffffffff00ff00f, 4, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lw, 0xffffffffff00ff00, 4, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lw  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lw  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .word 0x00ff00ff
tdat2:  .word 0xff00ff00
tdat3:  .word 0x0ff00ff0
tdat4:  .word 0xf00ff00f

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# lwu.S
#-----------------------------------------------------------------------------
#
# Test lwu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lwu, 0x0000000000ff00ff, 0,  tdat );
  TEST_LD_OP( 3, lwu, 0x00000000ff00ff00, 4,  tdat );
  TEST_LD_OP( 4, lwu, 0x000000000ff00ff0, 8,  tdat );
  TEST_LD_OP( 5, lwu, 0x00000000f00ff00f, 12, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lwu, 0x0000000000ff00ff, -12, tdat4 );
  TEST_LD_OP( 7, lwu, 0x00000000ff00ff00, -8,  tdat4 );
  TEST_LD_OP( 8, lwu, 0x000000000ff00ff0, -4,  tdat4 );
  TEST_LD_OP( 9, lwu, 0x00000000f00ff00f, 0,   tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x0000000000ff00ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lwu x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x00000000ff00ff00, \
    la  x1, tdat; \
    addi x1, x1, -3; \
    lwu x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lwu, 0x000000000ff00ff0, 4, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lwu, 0x00000000f00ff00f, 4, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lwu, 0x00000000ff00ff00, 4, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lwu, 0x000000000ff00ff0, 4, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lwu, 0x00000000f00ff00f, 4, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lwu, 0x00000000ff00ff00, 4, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lwu x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lwu x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .word 0x00ff00ff
tdat2:  .word 0xff00ff00
tdat3:  .word 0x0ff00ff0
tdat4:  .word 0xf00ff00f

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ori.S
#-----------------------------------------------------------------------------
#
# Test ori instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2, ori, 0xffffffffffffff0f, 0xffffffffff00ff00, 0xf0f );
  TEST_IMM_OP( 3, ori, 0x000000000ff00ff0, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_OP( 4, ori, 0x0000000000ff07ff, 0x0000000000ff00ff, 0x70f );
  TEST_IMM_OP( 5, ori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 6, ori, 0xff00fff0, 0xff00ff00, 0x0f0 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 7,  0, ori, 0x000000000ff00ff0, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_DEST_BYPASS( 8,  1, ori, 0x0000000000ff07ff, 0x0000000000ff00ff, 0x70f );
  TEST_IMM_DEST_BYPASS( 9,  2, ori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  TEST_IMM_SRC1_BYPASS( 10, 0, ori, 0x000000000ff00ff0, 0x000000000ff00ff0, 0x0f0 );
  TEST_IMM_SRC1_BYPASS( 11, 1, ori, 0xffffffffffffffff, 0x0000000000ff00ff, 0xf0f );
  TEST_IMM_SRC1_BYPASS( 12, 2, ori, 0xfffffffff00ff0ff, 0xfffffffff00ff00f, 0x0f0 );

  TEST_IMM_ZEROSRC1( 13, ori, 0x0f0, 0x0f0 );
  TEST_IMM_ZERODEST( 14, ori, 0x00ff00ff, 0x70f );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sd.S
#-----------------------------------------------------------------------------
#
# Test sd instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_ST_OP( 2, ld, sd, 0x00aa00aa00aa00aa, 0,  tdat );
  TEST_ST_OP( 3, ld, sd, 0xaa00aa00aa00aa00, 8,  tdat );
  TEST_ST_OP( 4, ld, sd, 0x0aa00aa00aa00aa0, 16,  tdat );
  TEST_ST_OP( 5, ld, sd, 0xa00aa00aa00aa00a, 24, tdat );

  # Test with negative offset

  TEST_ST_OP( 6, ld, sd, 0x00aa00aa00aa00aa, -24, tdat8 );
  TEST_ST_OP( 7, ld, sd, 0xaa00aa00aa00aa00, -16, tdat8 );
  TEST_ST_OP( 8, ld, sd, 0x0aa00aa00aa00aa0, -8,  tdat8 );
  TEST_ST_OP( 9, ld, sd, 0xa00aa00aa00aa00a, 0,   tdat8 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x1234567812345678, \
    la  x1, tdat9; \
    li  x2, 0x1234567812345678; \
    addi x4, x1, -32; \
    sd x2, 32(x4); \
    ld x5, 0(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x5821309858213098, \
    la  x1, tdat9; \
    li  x2, 0x5821309858213098; \
    addi x1, x1, -3; \
    sd x2, 11(x1); \
    la  x4, tdat10; \
    ld x5, 0(x4); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_ST_SRC12_BYPASS( 12, 0, 0, ld, sd, 0xabbccdd, 0,  tdat );
  TEST_ST_SRC12_BYPASS( 13, 0, 1, ld, sd, 0xaabbccd, 8,  tdat );
  TEST_ST_SRC12_BYPASS( 14, 0, 2, ld, sd, 0xdaabbcc, 16, tdat );
  TEST_ST_SRC12_BYPASS( 15, 1, 0, ld, sd, 0xddaabbc, 24, tdat );
  TEST_ST_SRC12_BYPASS( 16, 1, 1, ld, sd, 0xcddaabb, 32, tdat );
  TEST_ST_SRC12_BYPASS( 17, 2, 0, ld, sd, 0xccddaab, 40, tdat );

  TEST_ST_SRC21_BYPASS( 18, 0, 0, ld, sd, 0x00112233, 0,  tdat );
  TEST_ST_SRC21_BYPASS( 19, 0, 1, ld, sd, 0x30011223, 8,  tdat );
  TEST_ST_SRC21_BYPASS( 20, 0, 2, ld, sd, 0x33001122, 16, tdat );
  TEST_ST_SRC21_BYPASS( 21, 1, 0, ld, sd, 0x23300112, 24, tdat );
  TEST_ST_SRC21_BYPASS( 22, 1, 1, ld, sd, 0x22330011, 32, tdat );
  TEST_ST_SRC21_BYPASS( 23, 2, 0, ld, sd, 0x12233001, 40, tdat );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .dword 0xdeadbeefdeadbeef
tdat2:  .dword 0xdeadbeefdeadbeef
tdat3:  .dword 0xdeadbeefdeadbeef
tdat4:  .dword 0xdeadbeefdeadbeef
tdat5:  .dword 0xdeadbeefdeadbeef
tdat6:  .dword 0xdeadbeefdeadbeef
tdat7:  .dword 0xdeadbeefdeadbeef
tdat8:  .dword 0xdeadbeefdeadbeef
tdat9:  .dword 0xdeadbeefdeadbeef
tdat10: .dword 0xdeadbeefdeadbeef

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# srl.S
#-----------------------------------------------------------------------------
#
# Test srl instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

#define TEST_SRL(n, v, a) \
  TEST_RR_OP(n, srl, ((v) & ((1 << (__riscv_xlen-1) << 1) - 1)) >> (a), v, a)

  TEST_SRL( 2,  0xffffffff80000000, 0  );
  TEST_SRL( 3,  0xffffffff80000000, 1  );
  TEST_SRL( 4,  0xffffffff80000000, 7  );
  TEST_SRL( 5,  0xffffffff80000000, 14 );
  TEST_SRL( 6,  0xffffffff80000001, 31 );

  TEST_SRL( 7,  0xffffffffffffffff, 0  );
  TEST_SRL( 8,  0xffffffffffffffff, 1  );
  TEST_SRL( 9,  0xffffffffffffffff, 7  );
  TEST_SRL( 10, 0xffffffffffffffff, 14 );
  TEST_SRL( 11, 0xffffffffffffffff, 31 );

  TEST_SRL( 12, 0x0000000021212121, 0  );
  TEST_SRL( 13, 0x0000000021212121, 1  );
  TEST_SRL( 14, 0x0000000021212121, 7  );
  TEST_SRL( 15, 0x0000000021212121, 14 );
  TEST_SRL( 16, 0x0000000021212121, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, srl, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, srl, 0x0000000010909090, 0x0000000021212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, srl, 0x0000000000424242, 0x0000000021212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, srl, 0x0000000000008484, 0x0000000021212121, 0xffffffffffffffce );
  TEST_RR_OP( 21, srl, 0x0000000000000000, 0x0000000021212121, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, srl, 0, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, srl, 0x00000001, 0x80000000, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, srl, 0x00000001, 0x80000000, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, srl, 0x00000001, 0x80000000, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, srl, 0x00000001, 0x80000000, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, srl, 0x01000000, 0x80000000, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, srl, 0x00020000, 0x80000000, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, srl, 0x00000001, 0x80000000, 31 );

  TEST_RR_ZEROSRC1( 40, srl, 0, 15 );
  TEST_RR_ZEROSRC2( 41, srl, 32, 32 );
  TEST_RR_ZEROSRC12( 42, srl, 0 );
  TEST_RR_ZERODEST( 43, srl, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# bne.S
#-----------------------------------------------------------------------------
#
# Test bne instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Branch tests
  #-------------------------------------------------------------

  # Each test checks both forward and backward branches

  TEST_BR2_OP_TAKEN( 2, bne,  0,  1 );
  TEST_BR2_OP_TAKEN( 3, bne,  1,  0 );
  TEST_BR2_OP_TAKEN( 4, bne, -1,  1 );
  TEST_BR2_OP_TAKEN( 5, bne,  1, -1 );

  TEST_BR2_OP_NOTTAKEN( 6, bne,  0,  0 );
  TEST_BR2_OP_NOTTAKEN( 7, bne,  1,  1 );
  TEST_BR2_OP_NOTTAKEN( 8, bne, -1, -1 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_BR2_SRC12_BYPASS( 9,  0, 0, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 10, 0, 1, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 11, 0, 2, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 12, 1, 0, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 13, 1, 1, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 14, 2, 0, bne, 0, 0 );

  TEST_BR2_SRC12_BYPASS( 15, 0, 0, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 16, 0, 1, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 17, 0, 2, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 18, 1, 0, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 19, 1, 1, bne, 0, 0 );
  TEST_BR2_SRC12_BYPASS( 20, 2, 0, bne, 0, 0 );

  #-------------------------------------------------------------
  # Test delay slot instructions not executed nor bypassed
  #-------------------------------------------------------------

  TEST_CASE( 21, x1, 3, \
    li  x1, 1; \
    bne x1, x0, 1f; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
    addi x1, x1, 1; \
1:  addi x1, x1, 1; \
    addi x1, x1, 1; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# addi.S
#-----------------------------------------------------------------------------
#
# Test addi instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  addi, 0x00000000, 0x00000000, 0x000 );
  TEST_IMM_OP( 3,  addi, 0x00000002, 0x00000001, 0x001 );
  TEST_IMM_OP( 4,  addi, 0x0000000a, 0x00000003, 0x007 );

  TEST_IMM_OP( 5,  addi, 0xfffffffffffff800, 0x0000000000000000, 0x800 );
  TEST_IMM_OP( 6,  addi, 0xffffffff80000000, 0xffffffff80000000, 0x000 );
  TEST_IMM_OP( 7,  addi, 0xffffffff7ffff800, 0xffffffff80000000, 0x800 );

  TEST_IMM_OP( 8,  addi, 0x00000000000007ff, 0x00000000, 0x7ff );
  TEST_IMM_OP( 9,  addi, 0x000000007fffffff, 0x7fffffff, 0x000 );
  TEST_IMM_OP( 10, addi, 0x00000000800007fe, 0x7fffffff, 0x7ff );

  TEST_IMM_OP( 11, addi, 0xffffffff800007ff, 0xffffffff80000000, 0x7ff );
  TEST_IMM_OP( 12, addi, 0x000000007ffff7ff, 0x000000007fffffff, 0x800 );

  TEST_IMM_OP( 13, addi, 0xffffffffffffffff, 0x0000000000000000, 0xfff );
  TEST_IMM_OP( 14, addi, 0x0000000000000000, 0xffffffffffffffff, 0x001 );
  TEST_IMM_OP( 15, addi, 0xfffffffffffffffe, 0xffffffffffffffff, 0xfff );

  TEST_IMM_OP( 16, addi, 0x0000000080000000, 0x7fffffff, 0x001 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, addi, 24, 13, 11 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, addi, 24, 13, 11 );
  TEST_IMM_DEST_BYPASS( 19, 1, addi, 23, 13, 10 );
  TEST_IMM_DEST_BYPASS( 20, 2, addi, 22, 13,  9 );

  TEST_IMM_SRC1_BYPASS( 21, 0, addi, 24, 13, 11 );
  TEST_IMM_SRC1_BYPASS( 22, 1, addi, 23, 13, 10 );
  TEST_IMM_SRC1_BYPASS( 23, 2, addi, 22, 13,  9 );

  TEST_IMM_ZEROSRC1( 24, addi, 32, 32 );
  TEST_IMM_ZERODEST( 25, addi, 33, 50 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sltu.S
#-----------------------------------------------------------------------------
#
# Test sltu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sltu, 0, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sltu, 0, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sltu, 1, 0x00000003, 0x00000007 );
  TEST_RR_OP( 5,  sltu, 0, 0x00000007, 0x00000003 );

  TEST_RR_OP( 6,  sltu, 1, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 7,  sltu, 0, 0x80000000, 0x00000000 );
  TEST_RR_OP( 8,  sltu, 1, 0x80000000, 0xffff8000 );

  TEST_RR_OP( 9,  sltu, 1, 0x00000000, 0x00007fff );
  TEST_RR_OP( 10, sltu, 0, 0x7fffffff, 0x00000000 );
  TEST_RR_OP( 11, sltu, 0, 0x7fffffff, 0x00007fff );

  TEST_RR_OP( 12, sltu, 0, 0x80000000, 0x00007fff );
  TEST_RR_OP( 13, sltu, 1, 0x7fffffff, 0xffff8000 );

  TEST_RR_OP( 14, sltu, 1, 0x00000000, 0xffffffff );
  TEST_RR_OP( 15, sltu, 0, 0xffffffff, 0x00000001 );
  TEST_RR_OP( 16, sltu, 0, 0xffffffff, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sltu, 0, 14, 13 );
  TEST_RR_SRC2_EQ_DEST( 18, sltu, 1, 11, 13 );
  TEST_RR_SRC12_EQ_DEST( 19, sltu, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sltu, 1, 11, 13 );
  TEST_RR_DEST_BYPASS( 21, 1, sltu, 0, 14, 13 );
  TEST_RR_DEST_BYPASS( 22, 2, sltu, 1, 12, 13 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sltu, 0, 14, 13 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sltu, 1, 11, 13 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sltu, 0, 15, 13 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sltu, 1, 10, 13 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sltu, 0, 16, 13 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sltu, 1,  9, 13 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sltu, 0, 17, 13 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sltu, 1,  8, 13 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sltu, 0, 18, 13 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sltu, 1,  7, 13 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sltu, 0, 19, 13 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sltu, 1,  6, 13 );

  TEST_RR_ZEROSRC1( 35, sltu, 1, -1 );
  TEST_RR_ZEROSRC2( 36, sltu, 0, -1 );
  TEST_RR_ZEROSRC12( 37, sltu, 0 );
  TEST_RR_ZERODEST( 38, sltu, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# lb.S
#-----------------------------------------------------------------------------
#
# Test lb instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lb, 0xffffffffffffffff, 0,  tdat );
  TEST_LD_OP( 3, lb, 0x0000000000000000, 1,  tdat );
  TEST_LD_OP( 4, lb, 0xfffffffffffffff0, 2,  tdat );
  TEST_LD_OP( 5, lb, 0x000000000000000f, 3, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lb, 0xffffffffffffffff, -3, tdat4 );
  TEST_LD_OP( 7, lb, 0x0000000000000000, -2,  tdat4 );
  TEST_LD_OP( 8, lb, 0xfffffffffffffff0, -1,  tdat4 );
  TEST_LD_OP( 9, lb, 0x000000000000000f, 0,   tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0xffffffffffffffff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lb x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0x0000000000000000, \
    la  x1, tdat; \
    addi x1, x1, -6; \
    lb x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lb, 0xfffffffffffffff0, 1, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lb, 0x000000000000000f, 1, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lb, 0x0000000000000000, 1, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lb, 0xfffffffffffffff0, 1, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lb, 0x000000000000000f, 1, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lb, 0x0000000000000000, 1, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lb  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lb  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .byte 0xff
tdat2:  .byte 0x00
tdat3:  .byte 0xf0
tdat4:  .byte 0x0f

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# lh.S
#-----------------------------------------------------------------------------
#
# Test lh instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Basic tests
  #-------------------------------------------------------------

  TEST_LD_OP( 2, lh, 0x00000000000000ff, 0,  tdat );
  TEST_LD_OP( 3, lh, 0xffffffffffffff00, 2,  tdat );
  TEST_LD_OP( 4, lh, 0x0000000000000ff0, 4,  tdat );
  TEST_LD_OP( 5, lh, 0xfffffffffffff00f, 6, tdat );

  # Test with negative offset

  TEST_LD_OP( 6, lh, 0x00000000000000ff, -6,  tdat4 );
  TEST_LD_OP( 7, lh, 0xffffffffffffff00, -4,  tdat4 );
  TEST_LD_OP( 8, lh, 0x0000000000000ff0, -2,  tdat4 );
  TEST_LD_OP( 9, lh, 0xfffffffffffff00f,  0, tdat4 );

  # Test with a negative base

  TEST_CASE( 10, x5, 0x00000000000000ff, \
    la  x1, tdat; \
    addi x1, x1, -32; \
    lh x5, 32(x1); \
  )

  # Test with unaligned base

  TEST_CASE( 11, x5, 0xffffffffffffff00, \
    la  x1, tdat; \
    addi x1, x1, -5; \
    lh x5, 7(x1); \
  )

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_LD_DEST_BYPASS( 12, 0, lh, 0x0000000000000ff0, 2, tdat2 );
  TEST_LD_DEST_BYPASS( 13, 1, lh, 0xfffffffffffff00f, 2, tdat3 );
  TEST_LD_DEST_BYPASS( 14, 2, lh, 0xffffffffffffff00, 2, tdat1 );

  TEST_LD_SRC1_BYPASS( 15, 0, lh, 0x0000000000000ff0, 2, tdat2 );
  TEST_LD_SRC1_BYPASS( 16, 1, lh, 0xfffffffffffff00f, 2, tdat3 );
  TEST_LD_SRC1_BYPASS( 17, 2, lh, 0xffffffffffffff00, 2, tdat1 );

  #-------------------------------------------------------------
  # Test write-after-write hazard
  #-------------------------------------------------------------

  TEST_CASE( 18, x2, 2, \
    la  x5, tdat; \
    lh  x2, 0(x5); \
    li  x2, 2; \
  )

  TEST_CASE( 19, x2, 2, \
    la  x5, tdat; \
    lh  x2, 0(x5); \
    nop; \
    li  x2, 2; \
  )

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
tdat1:  .half 0x00ff
tdat2:  .half 0xff00
tdat3:  .half 0x0ff0
tdat4:  .half 0xf00f

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# addiw.S
#-----------------------------------------------------------------------------
#
# Test addiw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  addiw, 0x00000000, 0x00000000, 0x000 );
  TEST_IMM_OP( 3,  addiw, 0x00000002, 0x00000001, 0x001 );
  TEST_IMM_OP( 4,  addiw, 0x0000000a, 0x00000003, 0x007 );

  TEST_IMM_OP( 5,  addiw, 0xfffffffffffff800, 0x0000000000000000, 0x800 );
  TEST_IMM_OP( 6,  addiw, 0xffffffff80000000, 0xffffffff80000000, 0x000 );
  TEST_IMM_OP( 7,  addiw, 0x000000007ffff800, 0xffffffff80000000, 0x800 );

  TEST_IMM_OP( 8,  addiw, 0x00000000000007ff, 0x00000000, 0x7ff );
  TEST_IMM_OP( 9,  addiw, 0x000000007fffffff, 0x7fffffff, 0x000 );
  TEST_IMM_OP( 10, addiw, 0xffffffff800007fe, 0x7fffffff, 0x7ff );

  TEST_IMM_OP( 11, addiw, 0xffffffff800007ff, 0xffffffff80000000, 0x7ff );
  TEST_IMM_OP( 12, addiw, 0x000000007ffff7ff, 0x000000007fffffff, 0x800 );

  TEST_IMM_OP( 13, addiw, 0xffffffffffffffff, 0x0000000000000000, 0xfff );
  TEST_IMM_OP( 14, addiw, 0x0000000000000000, 0xffffffffffffffff, 0x001 );
  TEST_IMM_OP( 15, addiw, 0xfffffffffffffffe, 0xffffffffffffffff, 0xfff );

  TEST_IMM_OP( 16, addiw, 0xffffffff80000000, 0x7fffffff, 0x001 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, addiw, 24, 13, 11 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, addiw, 24, 13, 11 );
  TEST_IMM_DEST_BYPASS( 19, 1, addiw, 23, 13, 10 );
  TEST_IMM_DEST_BYPASS( 20, 2, addiw, 22, 13,  9 );

  TEST_IMM_SRC1_BYPASS( 21, 0, addiw, 24, 13, 11 );
  TEST_IMM_SRC1_BYPASS( 22, 1, addiw, 23, 13, 10 );
  TEST_IMM_SRC1_BYPASS( 23, 2, addiw, 22, 13,  9 );

  TEST_IMM_ZEROSRC1( 24, addiw, 32, 32 );
  TEST_IMM_ZERODEST( 25, addiw, 33, 50 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sra.S
#-----------------------------------------------------------------------------
#
# Test sra instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sra, 0xffffffff80000000, 0xffffffff80000000, 0  );
  TEST_RR_OP( 3,  sra, 0xffffffffc0000000, 0xffffffff80000000, 1  );
  TEST_RR_OP( 4,  sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_OP( 5,  sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_OP( 6,  sra, 0xffffffffffffffff, 0xffffffff80000001, 31 );

  TEST_RR_OP( 7,  sra, 0x000000007fffffff, 0x000000007fffffff, 0  );
  TEST_RR_OP( 8,  sra, 0x000000003fffffff, 0x000000007fffffff, 1  );
  TEST_RR_OP( 9,  sra, 0x0000000000ffffff, 0x000000007fffffff, 7  );
  TEST_RR_OP( 10, sra, 0x000000000001ffff, 0x000000007fffffff, 14 );
  TEST_RR_OP( 11, sra, 0x0000000000000000, 0x000000007fffffff, 31 );

  TEST_RR_OP( 12, sra, 0xffffffff81818181, 0xffffffff81818181, 0  );
  TEST_RR_OP( 13, sra, 0xffffffffc0c0c0c0, 0xffffffff81818181, 1  );
  TEST_RR_OP( 14, sra, 0xffffffffff030303, 0xffffffff81818181, 7  );
  TEST_RR_OP( 15, sra, 0xfffffffffffe0606, 0xffffffff81818181, 14 );
  TEST_RR_OP( 16, sra, 0xffffffffffffffff, 0xffffffff81818181, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, sra, 0xffffffff81818181, 0xffffffff81818181, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, sra, 0xffffffffc0c0c0c0, 0xffffffff81818181, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, sra, 0xffffffffff030303, 0xffffffff81818181, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, sra, 0xfffffffffffe0606, 0xffffffff81818181, 0xffffffffffffffce );
  TEST_RR_OP( 21, sra, 0xffffffffffffffff, 0xffffffff81818181, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, sra, 0, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, sra, 0xffffffffff000000, 0xffffffff80000000, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, sra, 0xfffffffffffe0000, 0xffffffff80000000, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, sra, 0xffffffffffffffff, 0xffffffff80000000, 31 );

  TEST_RR_ZEROSRC1( 40, sra, 0, 15 );
  TEST_RR_ZEROSRC2( 41, sra, 32, 32 );
  TEST_RR_ZEROSRC12( 42, sra, 0 );
  TEST_RR_ZERODEST( 43, sra, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# slli.S
#-----------------------------------------------------------------------------
#
# Test slli instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  slli, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_IMM_OP( 3,  slli, 0x0000000000000002, 0x0000000000000001, 1  );
  TEST_IMM_OP( 4,  slli, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_OP( 5,  slli, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_OP( 6,  slli, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_IMM_OP( 7,  slli, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  slli, 0xfffffffffffffffe, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  slli, 0xffffffffffffff80, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, slli, 0xffffffffffffc000, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, slli, 0xffffffff80000000, 0xffffffffffffffff, 31 );

  TEST_IMM_OP( 12, slli, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_IMM_OP( 13, slli, 0x0000000042424242, 0x0000000021212121, 1  );
  TEST_IMM_OP( 14, slli, 0x0000001090909080, 0x0000000021212121, 7  );
  TEST_IMM_OP( 15, slli, 0x0000084848484000, 0x0000000021212121, 14 );
  TEST_IMM_OP( 16, slli, 0x1090909080000000, 0x0000000021212121, 31 );

#if __riscv_xlen == 64
  TEST_IMM_OP( 50, slli, 0x8000000000000000, 0x0000000000000001, 63 );
  TEST_IMM_OP( 51, slli, 0xffffff8000000000, 0xffffffffffffffff, 39 );
  TEST_IMM_OP( 52, slli, 0x0909080000000000, 0x0000000021212121, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, slli, 0x00000080, 0x00000001, 7 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, slli, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_DEST_BYPASS( 19, 1, slli, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_DEST_BYPASS( 20, 2, slli, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_IMM_SRC1_BYPASS( 21, 0, slli, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_IMM_SRC1_BYPASS( 22, 1, slli, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_IMM_SRC1_BYPASS( 23, 2, slli, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_IMM_ZEROSRC1( 24, slli, 0, 31 );
  TEST_IMM_ZERODEST( 25, slli, 33, 20 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# subw.S
#-----------------------------------------------------------------------------
#
# Test subw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  subw, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 );
  TEST_RR_OP( 3,  subw, 0x0000000000000000, 0x0000000000000001, 0x0000000000000001 );
  TEST_RR_OP( 4,  subw, 0xfffffffffffffffc, 0x0000000000000003, 0x0000000000000007 );

  TEST_RR_OP( 5,  subw, 0x0000000000008000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  subw, 0xffffffff80000000, 0xffffffff80000000, 0x0000000000000000 );
  TEST_RR_OP( 7,  subw, 0xffffffff80008000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 8,  subw, 0xffffffffffff8001, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 9,  subw, 0x000000007fffffff, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 10, subw, 0x000000007fff8000, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 11, subw, 0x000000007fff8001, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 12, subw, 0xffffffff80007fff, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 13, subw, 0x0000000000000001, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 14, subw, 0xfffffffffffffffe, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 15, subw, 0x0000000000000000, 0xffffffffffffffff, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 16, subw, 2, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 17, subw, 3, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 18, subw, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 19, 0, subw, 2, 13, 11 );
  TEST_RR_DEST_BYPASS( 20, 1, subw, 3, 14, 11 );
  TEST_RR_DEST_BYPASS( 21, 2, subw, 4, 15, 11 );

  TEST_RR_SRC12_BYPASS( 22, 0, 0, subw, 2, 13, 11 );
  TEST_RR_SRC12_BYPASS( 23, 0, 1, subw, 3, 14, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 2, subw, 4, 15, 11 );
  TEST_RR_SRC12_BYPASS( 25, 1, 0, subw, 2, 13, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 1, subw, 3, 14, 11 );
  TEST_RR_SRC12_BYPASS( 27, 2, 0, subw, 4, 15, 11 );

  TEST_RR_SRC21_BYPASS( 28, 0, 0, subw, 2, 13, 11 );
  TEST_RR_SRC21_BYPASS( 29, 0, 1, subw, 3, 14, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 2, subw, 4, 15, 11 );
  TEST_RR_SRC21_BYPASS( 31, 1, 0, subw, 2, 13, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 1, subw, 3, 14, 11 );
  TEST_RR_SRC21_BYPASS( 33, 2, 0, subw, 4, 15, 11 );

  TEST_RR_ZEROSRC1( 34, subw, 15, -15 );
  TEST_RR_ZEROSRC2( 35, subw, 32, 32 );
  TEST_RR_ZEROSRC12( 36, subw, 0 );
  TEST_RR_ZERODEST( 37, subw, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# xor.S
#-----------------------------------------------------------------------------
#
# Test xor instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_OP( 3, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_OP( 4, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_OP( 5, xor, 0x00ff00ff, 0xf00ff00f, 0xf0f0f0f0 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 6, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC2_EQ_DEST( 7, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_EQ_DEST( 8, xor, 0x00000000, 0xff00ff00 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 9,  0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_DEST_BYPASS( 10, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_DEST_BYPASS( 11, 2, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC12_BYPASS( 12, 0, 0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 13, 0, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 14, 0, 2, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 15, 1, 0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC12_BYPASS( 16, 1, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 17, 2, 0, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_SRC21_BYPASS( 18, 0, 0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 19, 0, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 20, 0, 2, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 21, 1, 0, xor, 0xf00ff00f, 0xff00ff00, 0x0f0f0f0f );
  TEST_RR_SRC21_BYPASS( 22, 1, 1, xor, 0xff00ff00, 0x0ff00ff0, 0xf0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 23, 2, 0, xor, 0x0ff00ff0, 0x00ff00ff, 0x0f0f0f0f );

  TEST_RR_ZEROSRC1( 24, xor, 0xff00ff00, 0xff00ff00 );
  TEST_RR_ZEROSRC2( 25, xor, 0x00ff00ff, 0x00ff00ff );
  TEST_RR_ZEROSRC12( 26, xor, 0 );
  TEST_RR_ZERODEST( 27, xor, 0x11111111, 0x22222222 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# slti.S
#-----------------------------------------------------------------------------
#
# Test slti instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  slti, 0, 0x0000000000000000, 0x000 );
  TEST_IMM_OP( 3,  slti, 0, 0x0000000000000001, 0x001 );
  TEST_IMM_OP( 4,  slti, 1, 0x0000000000000003, 0x007 );
  TEST_IMM_OP( 5,  slti, 0, 0x0000000000000007, 0x003 );

  TEST_IMM_OP( 6,  slti, 0, 0x0000000000000000, 0x800 );
  TEST_IMM_OP( 7,  slti, 1, 0xffffffff80000000, 0x000 );
  TEST_IMM_OP( 8,  slti, 1, 0xffffffff80000000, 0x800 );

  TEST_IMM_OP( 9,  slti, 1, 0x0000000000000000, 0x7ff );
  TEST_IMM_OP( 10, slti, 0, 0x000000007fffffff, 0x000 );
  TEST_IMM_OP( 11, slti, 0, 0x000000007fffffff, 0x7ff );

  TEST_IMM_OP( 12, slti, 1, 0xffffffff80000000, 0x7ff );
  TEST_IMM_OP( 13, slti, 0, 0x000000007fffffff, 0x800 );

  TEST_IMM_OP( 14, slti, 0, 0x0000000000000000, 0xfff );
  TEST_IMM_OP( 15, slti, 1, 0xffffffffffffffff, 0x001 );
  TEST_IMM_OP( 16, slti, 0, 0xffffffffffffffff, 0xfff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 17, slti, 1, 11, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 18, 0, slti, 0, 15, 10 );
  TEST_IMM_DEST_BYPASS( 19, 1, slti, 1, 10, 16 );
  TEST_IMM_DEST_BYPASS( 20, 2, slti, 0, 16,  9 );

  TEST_IMM_SRC1_BYPASS( 21, 0, slti, 1, 11, 15 );
  TEST_IMM_SRC1_BYPASS( 22, 1, slti, 0, 17,  8 );
  TEST_IMM_SRC1_BYPASS( 23, 2, slti, 1, 12, 14 );

  TEST_IMM_ZEROSRC1( 24, slti, 0, 0xfff );
  TEST_IMM_ZERODEST( 25, slti, 0x00ff00ff, 0xfff );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64ud/fcvt.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64ud/fdiv.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64ud/fmadd.S"
# See LICENSE for license details.

#*****************************************************************************
# ldst.S
#-----------------------------------------------------------------------------
#
# This test verifies that flw, fld, fsw, and fsd work properly.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32UF
RVTEST_CODE_BEGIN

  la s0, tdat
  TEST_CASE_D32(2, a0, a1, 0x40000000bf800000, fld f2, 0(s0); fsd f2, 16(s0); lw a0, 16(s0); lw a1, 20(s0))
  TEST_CASE_D32(3, a0, a1, 0x40000000bf800000, fld f2, 0(s0); fsw f2, 16(s0); lw a0, 16(s0); lw a1, 20(s0))
  TEST_CASE_D32(4, a0, a1, 0x40000000bf800000, flw f2, 0(s0); fsw f2, 16(s0); lw a0, 16(s0); lw a1, 20(s0))
  TEST_CASE_D32(5, a0, a1, 0xc080000040400000, fld f2, 8(s0); fsd f2, 16(s0); lw a0, 16(s0); lw a1, 20(s0))
  TEST_CASE_D32(6, a0, a1, 0xffffffff40400000, flw f2, 8(s0); fsd f2, 16(s0); lw a0, 16(s0); lw a1, 20(s0))

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
.word 0xbf800000
.word 0x40000000
.word 0x40400000
.word 0xc0800000
.word 0xdeadbeef
.word 0xcafebabe
.word 0xabad1dea
.word 0x1337d00d

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64ud/fmin.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64ud/recoding.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64ud/fclass.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64ud/fcmp.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64ud/fadd.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "../rv64ud/move.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64UF
#define RVTEST_RV64UF RVTEST_RV32UF

#include "test_macros.h"
#undef TEST_FP_INT_OP_D
#define TEST_FP_INT_OP_D TEST_FP_INT_OP_D32

#include "../rv64ud/fcvt_w.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uc/rvc.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbs/binvi.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbs/bclri.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbs/bseti.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbs/bext.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbs/bexti.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbs/bclr.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbs/binv.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64U
#define RVTEST_RV64U RVTEST_RV32U

#include "../rv64uzbs/bset.S"
# See LICENSE for license details.

#*****************************************************************************
# remu.S
#-----------------------------------------------------------------------------
#
# Test remu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, remu,   2,  20,   6 );
  TEST_RR_OP( 3, remu,   2, -20,   6 );
  TEST_RR_OP( 4, remu,  20,  20,  -6 );
  TEST_RR_OP( 5, remu, -20, -20,  -6 );

  TEST_RR_OP( 6, remu,      0, -1<<31,  1 );
  TEST_RR_OP( 7, remu, -1<<31, -1<<31, -1 );

  TEST_RR_OP( 8, remu, -1<<31, -1<<31, 0 );
  TEST_RR_OP( 9, remu,      1,      1, 0 );
  TEST_RR_OP(10, remu,      0,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rem.S
#-----------------------------------------------------------------------------
#
# Test rem instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, rem,  2,  20,   6 );
  TEST_RR_OP( 3, rem, -2, -20,   6 );
  TEST_RR_OP( 4, rem,  2,  20,  -6 );
  TEST_RR_OP( 5, rem, -2, -20,  -6 );

  TEST_RR_OP( 6, rem,  0, -1<<31,  1 );
  TEST_RR_OP( 7, rem,  0, -1<<31, -1 );

  TEST_RR_OP( 8, rem, -1<<31, -1<<31, 0 );
  TEST_RR_OP( 9, rem,      1,      1, 0 );
  TEST_RR_OP(10, rem,      0,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mul.S
#-----------------------------------------------------------------------------
#
# Test mul instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP(32,  mul, 0x00001200, 0x00007e00, 0xb6db6db7 );
  TEST_RR_OP(33,  mul, 0x00001240, 0x00007fc0, 0xb6db6db7 );

  TEST_RR_OP( 2,  mul, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  mul, 0x00000001, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  mul, 0x00000015, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  mul, 0x00000000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  mul, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  mul, 0x00000000, 0x80000000, 0xffff8000 );

  TEST_RR_OP(30,  mul, 0x0000ff7f, 0xaaaaaaab, 0x0002fe7d );
  TEST_RR_OP(31,  mul, 0x0000ff7f, 0x0002fe7d, 0xaaaaaaab );

  TEST_RR_OP(34,  mul, 0x00000000, 0xff000000, 0xff000000 );

  TEST_RR_OP(35,  mul, 0x00000001, 0xffffffff, 0xffffffff );
  TEST_RR_OP(36,  mul, 0xffffffff, 0xffffffff, 0x00000001 );
  TEST_RR_OP(37,  mul, 0xffffffff, 0x00000001, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, mul, 143, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 9, mul, 154, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 10, mul, 169, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, mul, 143, 13, 11 );
  TEST_RR_DEST_BYPASS( 12, 1, mul, 154, 14, 11 );
  TEST_RR_DEST_BYPASS( 13, 2, mul, 165, 15, 11 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, mul, 143, 13, 11 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, mul, 154, 14, 11 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, mul, 165, 15, 11 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, mul, 143, 13, 11 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, mul, 154, 14, 11 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, mul, 165, 15, 11 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, mul, 143, 13, 11 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, mul, 154, 14, 11 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, mul, 165, 15, 11 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, mul, 143, 13, 11 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, mul, 154, 14, 11 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, mul, 165, 15, 11 );

  TEST_RR_ZEROSRC1( 26, mul, 0, 31 );
  TEST_RR_ZEROSRC2( 27, mul, 0, 32 );
  TEST_RR_ZEROSRC12( 28, mul, 0 );
  TEST_RR_ZERODEST( 29, mul, 33, 34 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mulhsu.S
#-----------------------------------------------------------------------------
#
# Test mulhsu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  mulhsu, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  mulhsu, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  mulhsu, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  mulhsu, 0x00000000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  mulhsu, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  mulhsu, 0x80004000, 0x80000000, 0xffff8000 );

  TEST_RR_OP(30,  mulhsu, 0xffff0081, 0xaaaaaaab, 0x0002fe7d );
  TEST_RR_OP(31,  mulhsu, 0x0001fefe, 0x0002fe7d, 0xaaaaaaab );

  TEST_RR_OP(32,  mulhsu, 0xff010000, 0xff000000, 0xff000000 );

  TEST_RR_OP(33,  mulhsu, 0xffffffff, 0xffffffff, 0xffffffff );
  TEST_RR_OP(34,  mulhsu, 0xffffffff, 0xffffffff, 0x00000001 );
  TEST_RR_OP(35,  mulhsu, 0x00000000, 0x00000001, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, mulhsu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC2_EQ_DEST( 9, mulhsu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC12_EQ_DEST( 10, mulhsu, 43264, 13<<20 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, mulhsu, 36608, 13<<20, 11<<20 );
  TEST_RR_DEST_BYPASS( 12, 1, mulhsu, 39424, 14<<20, 11<<20 );
  TEST_RR_DEST_BYPASS( 13, 2, mulhsu, 42240, 15<<20, 11<<20 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, mulhsu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, mulhsu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, mulhsu, 42240, 15<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, mulhsu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, mulhsu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, mulhsu, 42240, 15<<20, 11<<20 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, mulhsu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, mulhsu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, mulhsu, 42240, 15<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, mulhsu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, mulhsu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, mulhsu, 42240, 15<<20, 11<<20 );

  TEST_RR_ZEROSRC1( 26, mulhsu, 0, 31<<26 );
  TEST_RR_ZEROSRC2( 27, mulhsu, 0, 32<<26 );
  TEST_RR_ZEROSRC12( 28, mulhsu, 0 );
  TEST_RR_ZERODEST( 29, mulhsu, 33<<20, 34<<20 );



  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mulh.S
#-----------------------------------------------------------------------------
#
# Test mulh instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  mulh, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  mulh, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  mulh, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  mulh, 0x00000000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  mulh, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  mulh, 0x00000000, 0x80000000, 0x00000000 );

  TEST_RR_OP(30,  mulh, 0xffff0081, 0xaaaaaaab, 0x0002fe7d );
  TEST_RR_OP(31,  mulh, 0xffff0081, 0x0002fe7d, 0xaaaaaaab );

  TEST_RR_OP(32,  mulh, 0x00010000, 0xff000000, 0xff000000 );

  TEST_RR_OP(33,  mulh, 0x00000000, 0xffffffff, 0xffffffff );
  TEST_RR_OP(34,  mulh, 0xffffffff, 0xffffffff, 0x00000001 );
  TEST_RR_OP(35,  mulh, 0xffffffff, 0x00000001, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, mulh, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC2_EQ_DEST( 9, mulh, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC12_EQ_DEST( 10, mulh, 43264, 13<<20 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, mulh, 36608, 13<<20, 11<<20 );
  TEST_RR_DEST_BYPASS( 12, 1, mulh, 39424, 14<<20, 11<<20 );
  TEST_RR_DEST_BYPASS( 13, 2, mulh, 42240, 15<<20, 11<<20 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, mulh, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, mulh, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, mulh, 42240, 15<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, mulh, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, mulh, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, mulh, 42240, 15<<20, 11<<20 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, mulh, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, mulh, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, mulh, 42240, 15<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, mulh, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, mulh, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, mulh, 42240, 15<<20, 11<<20 );

  TEST_RR_ZEROSRC1( 26, mulh, 0, 31<<26 );
  TEST_RR_ZEROSRC2( 27, mulh, 0, 32<<26 );
  TEST_RR_ZEROSRC12( 28, mulh, 0 );
  TEST_RR_ZERODEST( 29, mulh, 33<<20, 34<<20 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mulhu.S
#-----------------------------------------------------------------------------
#
# Test mulhu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  mulhu, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  mulhu, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  mulhu, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  mulhu, 0x00000000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  mulhu, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  mulhu, 0x7fffc000, 0x80000000, 0xffff8000 );

  TEST_RR_OP(30,  mulhu, 0x0001fefe, 0xaaaaaaab, 0x0002fe7d );
  TEST_RR_OP(31,  mulhu, 0x0001fefe, 0x0002fe7d, 0xaaaaaaab );

  TEST_RR_OP(32,  mulhu, 0xfe010000, 0xff000000, 0xff000000 );

  TEST_RR_OP(33,  mulhu, 0xfffffffe, 0xffffffff, 0xffffffff );
  TEST_RR_OP(34,  mulhu, 0x00000000, 0xffffffff, 0x00000001 );
  TEST_RR_OP(35,  mulhu, 0x00000000, 0x00000001, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, mulhu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC2_EQ_DEST( 9, mulhu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC12_EQ_DEST( 10, mulhu, 43264, 13<<20 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, mulhu, 36608, 13<<20, 11<<20 );
  TEST_RR_DEST_BYPASS( 12, 1, mulhu, 39424, 14<<20, 11<<20 );
  TEST_RR_DEST_BYPASS( 13, 2, mulhu, 42240, 15<<20, 11<<20 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, mulhu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, mulhu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, mulhu, 42240, 15<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, mulhu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, mulhu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, mulhu, 42240, 15<<20, 11<<20 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, mulhu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, mulhu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, mulhu, 42240, 15<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, mulhu, 36608, 13<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, mulhu, 39424, 14<<20, 11<<20 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, mulhu, 42240, 15<<20, 11<<20 );

  TEST_RR_ZEROSRC1( 26, mulhu, 0, 31<<26 );
  TEST_RR_ZEROSRC2( 27, mulhu, 0, 32<<26 );
  TEST_RR_ZEROSRC12( 28, mulhu, 0 );
  TEST_RR_ZERODEST( 29, mulhu, 33<<20, 34<<20 );


  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# divu.S
#-----------------------------------------------------------------------------
#
# Test divu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, divu,                   3,  20,   6 );
  TEST_RR_OP( 3, divu,           715827879, -20,   6 );
  TEST_RR_OP( 4, divu,                   0,  20,  -6 );
  TEST_RR_OP( 5, divu,                   0, -20,  -6 );

  TEST_RR_OP( 6, divu, -1<<31, -1<<31,  1 );
  TEST_RR_OP( 7, divu,     0,  -1<<31, -1 );

  TEST_RR_OP( 8, divu, -1, -1<<31, 0 );
  TEST_RR_OP( 9, divu, -1,      1, 0 );
  TEST_RR_OP(10, divu, -1,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# div.S
#-----------------------------------------------------------------------------
#
# Test div instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, div,  3,  20,   6 );
  TEST_RR_OP( 3, div, -3, -20,   6 );
  TEST_RR_OP( 4, div, -3,  20,  -6 );
  TEST_RR_OP( 5, div,  3, -20,  -6 );

  TEST_RR_OP( 6, div, -1<<31, -1<<31,  1 );
  TEST_RR_OP( 7, div, -1<<31, -1<<31, -1 );

  TEST_RR_OP( 8, div, -1, -1<<31, 0 );
  TEST_RR_OP( 9, div, -1,      1, 0 );
  TEST_RR_OP(10, div, -1,      0, 0 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sext_h.S
#-----------------------------------------------------------------------------
#
# Test zext.h instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  zext.h, 0x0000000000000000, 0x0000000000000000);
  TEST_R_OP( 3,  zext.h, 0x0000000000000001, 0x0000000000000001);
  TEST_R_OP( 4,  zext.h, 0x0000000000000003, 0x0000000000000003);

  TEST_R_OP( 5,  zext.h, 0x0000000000008000, 0xffffffffffff8000 );
  TEST_R_OP( 6,  zext.h, 0x0000000000000000, 0x0000000000800000 );
  TEST_R_OP( 7,  zext.h, 0x0000000000008000, 0x0004ffffffff8000 );

  TEST_R_OP( 8,  zext.h, 0x0000000000007fff, 0x0000000000007fff);
  TEST_R_OP( 9,  zext.h, 0x000000000000ffff, 0x000000007fffffff);
  TEST_R_OP( 10, zext.h, 0x000000000000ffff, 0x000000000007ffff );

  TEST_R_OP( 11, zext.h, 0x0000000000000000, 0xffffffff80000000);
  TEST_R_OP( 12, zext.h, 0x0000000000005000, 0x00ff578f121f5000);

  TEST_R_OP( 13, zext.h, 0x0000000000000000, 0x8000000000000000);
  TEST_R_OP( 14, zext.h, 0x000000000000000e, 0x000000000000000e);
  TEST_R_OP( 15, zext.h, 0x0000000000001341, 0xa000000320401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, zext.h, 0x000000000000000d, 13);
  TEST_R_SRC1_EQ_DEST( 17, zext.h, 0x000000000000000b, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, zext.h, 0x000000000000000d, 13);
  TEST_R_DEST_BYPASS( 29, 1, zext.h, 0x0000000000000013, 19);
  TEST_R_DEST_BYPASS( 20, 2, zext.h, 0x0000000000000022, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  zext.h, 0x0000000000008000, 0x00000000007f8000 );
  TEST_R_OP( 22,  zext.h, 0x0000000000008000, 0x0000000000808000 );
  TEST_R_OP( 23,  zext.h, 0x0000000000008000, 0x0000000001808000 );

  TEST_R_OP( 24,  zext.h, 0x0000000000007fff, 0x0000000300007fff);
  TEST_R_OP( 25,  zext.h, 0x000000000000ffff, 0x000000077fffffff);
  TEST_R_OP( 26,  zext.h, 0x000000000000ffff, 0x0000000f0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rori.S
#-----------------------------------------------------------------------------
#
# Test rori instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  rori, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_IMM_OP( 3,  rori, 0x8000000000000000, 0x0000000000000001, 1  );
  TEST_IMM_OP( 4,  rori, 0x0200000000000000, 0x0000000000000001, 7  );
  TEST_IMM_OP( 5,  rori, 0x0004000000000000, 0x0000000000000001, 14 );
  TEST_IMM_OP( 6,  rori, 0x0000000200000000, 0x0000000000000001, 31 );

  TEST_IMM_OP( 7,  rori, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  rori, 0xffffffffffffffff, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  rori, 0xffffffffffffffff, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, rori, 0xffffffffffffffff, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, rori, 0xffffffffffffffff, 0xffffffffffffffff, 31 );

  TEST_IMM_OP( 12, rori, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_IMM_OP( 13, rori, 0x8000000010909090, 0x0000000021212121, 1  );
  TEST_IMM_OP( 14, rori, 0x4200000000424242, 0x0000000021212121, 7  );
  TEST_IMM_OP( 15, rori, 0x8484000000008484, 0x0000000021212121, 14 );
  TEST_IMM_OP( 16, rori, 0x4242424200000000, 0x0000000021212121, 31 );

  TEST_IMM_OP( 17, rori, 0x0000000000000002, 0x0000000000000001, 63 );
  TEST_IMM_OP( 18, rori, 0xffffffffffffffff, 0xffffffffffffffff, 39 );
  TEST_IMM_OP( 19, rori, 0x0004242424200000, 0x0000000021212121, 43 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 20, rori, 0x0200000000000000, 0x00000001, 7  );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 21, 0, rori, 0x0200000000000000, 0x0000000000000001, 7  );
  TEST_IMM_DEST_BYPASS( 22, 1, rori, 0x0004000000000000, 0x0000000000000001, 14 );
  TEST_IMM_DEST_BYPASS( 23, 2, rori, 0x0000000200000000, 0x0000000000000001, 31 );

  TEST_IMM_SRC1_BYPASS( 24, 0, rori, 0x0200000000000000, 0x0000000000000001, 7  );
  TEST_IMM_SRC1_BYPASS( 25, 1, rori, 0x0004000000000000, 0x0000000000000001, 14 );
  TEST_IMM_SRC1_BYPASS( 26, 2, rori, 0x0000000200000000, 0x0000000000000001, 31 );

  TEST_IMM_ZEROSRC1( 27, rori, 0, 31 );
  TEST_IMM_ZERODEST( 28, rori, 33, 20 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# cpopw.S
#-----------------------------------------------------------------------------
#
# Test cpopw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  cpopw, 0, 0x00000000);
  TEST_R_OP( 3,  cpopw, 1, 0x00000001);
  TEST_R_OP( 4,  cpopw, 2, 0x00000003);

  TEST_R_OP( 5,  cpopw, 17, 0xffff8000 );
  TEST_R_OP( 6,  cpopw, 1, 0x00800000 );
  TEST_R_OP( 7,  cpopw, 18, 0xffff6000 );

  TEST_R_OP( 8,  cpopw, 15, 0x00007fff);
  TEST_R_OP( 9,  cpopw, 31, 0x7fffffff);
  TEST_R_OP( 10, cpopw, 19, 0x0007ffff );

  TEST_R_OP( 11, cpopw, 1, 0x80000000);
  TEST_R_OP( 12, cpopw, 9, 0x121f5000);

  TEST_R_OP( 13, cpopw, 0, 0x00000000);
  TEST_R_OP( 14, cpopw, 3, 0x0000000e);
  TEST_R_OP( 15, cpopw, 7, 0x20401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, cpopw, 3, 13);
  TEST_R_SRC1_EQ_DEST( 17, cpopw, 3, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, cpopw, 3, 13);
  TEST_R_DEST_BYPASS( 29, 1, cpopw, 3, 19);
  TEST_R_DEST_BYPASS( 20, 2, cpopw, 2, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  cpopw, 8, 0x007f8000 );
  TEST_R_OP( 22,  cpopw, 2, 0x00808000 );
  TEST_R_OP( 23,  cpopw, 3, 0x01808000 );

  TEST_R_OP( 24,  cpopw, 17, 0x30007fff);
  TEST_R_OP( 25,  cpopw, 30, 0x77ffffff);
  TEST_R_OP( 26,  cpopw, 19, 0x0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# xnor.S
#-----------------------------------------------------------------------------
#
# Test xnor instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, xnor, 0x000000000ff00ff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_OP( 3, xnor, 0x0000000000ff00ff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_OP( 4, xnor, 0xfffffffff00ff00f, 0x0000000000ff00ff, 0x000000000f0f0f0f );
  TEST_RR_OP( 5, xnor, 0xffffffffff00ff00, 0xfffffffff00ff00f, 0xfffffffff0f0f0f0 );

#if __riscv_xlen == 64
  TEST_RR_OP( 50, xnor, 0x00ff00ff00ff00ff, 0x0ff00ff00ff00ff0, 0xf0f0f0f0f0f0f0f0 );
  TEST_RR_OP( 51, xnor, 0xf00ff00ff00ff00f, 0x00ff00ff00ff00ff, 0x0f0f0f0f0f0f0f0f );
  TEST_RR_OP( 52, xnor, 0xff00ff00ff00ff00, 0xf00ff00ff00ff00f, 0xf0f0f0f0f0f0f0f0 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 6, xnor, 0x000000000ff00ff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC2_EQ_DEST( 7, xnor, 0x000000000ff00ff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC12_EQ_DEST( 8, xnor, 0xffffffffffffffff, 0xffffffffff00ff00 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 9,  0, xnor, 0x000000000ff00ff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_DEST_BYPASS( 10, 1, xnor, 0x0000000000ff00ff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_DEST_BYPASS( 11, 2, xnor, 0xfffffffff00ff00f, 0x0000000000ff00ff, 0x000000000f0f0f0f );

  TEST_RR_SRC12_BYPASS( 12, 0, 0, xnor, 0x000000000ff00ff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC12_BYPASS( 13, 0, 1, xnor, 0x0000000000ff00ff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 14, 0, 2, xnor, 0xfffffffff00ff00f, 0x0000000000ff00ff, 0x000000000f0f0f0f );
  TEST_RR_SRC12_BYPASS( 15, 1, 0, xnor, 0x000000000ff00ff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC12_BYPASS( 16, 1, 1, xnor, 0x0000000000ff00ff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 17, 2, 0, xnor, 0xfffffffff00ff00f, 0x0000000000ff00ff, 0x000000000f0f0f0f );

  TEST_RR_SRC21_BYPASS( 18, 0, 0, xnor, 0x000000000ff00ff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC21_BYPASS( 19, 0, 1, xnor, 0x0000000000ff00ff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 20, 0, 2, xnor, 0xfffffffff00ff00f, 0x0000000000ff00ff, 0x000000000f0f0f0f );
  TEST_RR_SRC21_BYPASS( 21, 1, 0, xnor, 0x000000000ff00ff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC21_BYPASS( 22, 1, 1, xnor, 0x0000000000ff00ff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 23, 2, 0, xnor, 0xfffffffff00ff00f, 0x0000000000ff00ff, 0x000000000f0f0f0f );

  TEST_RR_ZEROSRC1( 24, xnor, 0x0000000000ff00ff, 0xffffffffff00ff00 );
  TEST_RR_ZEROSRC2( 25, xnor, 0xffffffffff00ff00, 0x0000000000ff00ff );
  TEST_RR_ZEROSRC12( 26, xnor, -1 );
  TEST_RR_ZERODEST( 27, xnor, 0x0000000011111111, 0x0000000022222222 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# min.S
#-----------------------------------------------------------------------------
#
# Test min instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  min, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 );
  TEST_RR_OP( 3,  min, 0x0000000000000001, 0x0000000000000001, 0x0000000000000001 );
  TEST_RR_OP( 4,  min, 0x0000000000000003, 0x0000000000000003, 0x0000000000000007 );
  TEST_RR_OP( 5,  min, 0x0000000000000003, 0x0000000000000007, 0x0000000000000003 );

  TEST_RR_OP( 6,  min, 0xffffffffffff8000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 7,  min, 0xffffffff80000000, 0xffffffff80000000, 0x0000000000000000 );
  TEST_RR_OP( 8,  min, 0xffffffff80000000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 9,  min, 0x0000000000000000, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 10, min, 0x0000000000000000, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 11, min, 0x0000000000007fff, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 12, min, 0xffffffff80000000, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 13, min, 0xffffffffffff8000, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 14, min, 0xffffffffffffffff, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 15, min, 0xffffffffffffffff, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 16, min, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, min, 13, 14, 13 );
  TEST_RR_SRC2_EQ_DEST( 18, min, 11, 11, 13 );
  TEST_RR_SRC12_EQ_DEST( 19, min, 13, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, min, 11, 11, 13 );
  TEST_RR_DEST_BYPASS( 21, 1, min, 13, 14, 13 );
  TEST_RR_DEST_BYPASS( 22, 2, min, 12, 12, 13 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, min, 13, 14, 13 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, min, 11, 11, 13 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, min, 13, 15, 13 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, min, 10, 10, 13 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, min, 13, 16, 13 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, min, 9,  9, 13 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, min, 13, 17, 13 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, min, 8,  8, 13 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, min, 13, 18, 13 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, min, 7,  7, 13 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, min, 13, 19, 13 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, min, 6,  6, 13 );

  TEST_RR_ZEROSRC1( 35, min, -1, -1 );
  TEST_RR_ZEROSRC2( 36, min, -1, -1 );
  TEST_RR_ZEROSRC12( 37, min, 0 );
  TEST_RR_ZERODEST( 38, min, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ror.S
#-----------------------------------------------------------------------------
#
# Test ror instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  ror, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_RR_OP( 3,  ror, 0x8000000000000000, 0x0000000000000001, 1  );
  TEST_RR_OP( 4,  ror, 0x0200000000000000, 0x0000000000000001, 7  );
  TEST_RR_OP( 5,  ror, 0x0004000000000000, 0x0000000000000001, 14 );
  TEST_RR_OP( 6,  ror, 0x0000000200000000, 0x0000000000000001, 31 );

  TEST_RR_OP( 7,  ror, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  ror, 0xffffffffffffffff, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  ror, 0xffffffffffffffff, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, ror, 0xffffffffffffffff, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, ror, 0xffffffffffffffff, 0xffffffffffffffff, 31 );

  TEST_RR_OP( 12, ror, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_RR_OP( 13, ror, 0x8000000010909090, 0x0000000021212121, 1  );
  TEST_RR_OP( 14, ror, 0x4200000000424242, 0x0000000021212121, 7  );
  TEST_RR_OP( 15, ror, 0x8484000000008484, 0x0000000021212121, 14 );
  TEST_RR_OP( 16, ror, 0x4242424200000000, 0x0000000021212121, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, ror, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, ror, 0x8000000010909090, 0x0000000021212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, ror, 0x4200000000424242, 0x0000000021212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, ror, 0x8484000000008484, 0x0000000021212121, 0xffffffffffffffce );

  TEST_RR_OP( 21, ror, 0x0000000042424242, 0x0000000021212121, 0xffffffffffffffff );
  TEST_RR_OP( 50, ror, 0x0000000000000002, 0x0000000000000001, 63 );
  TEST_RR_OP( 51, ror, 0xffffffffffffffff, 0xffffffffffffffff, 39 );
  TEST_RR_OP( 52, ror, 0x0004242424200000, 0x0000000021212121, 43 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, ror, 0x0200000000000000, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, ror, 0x0004000000000000, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, ror, 0x6000000000000000, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, ror, 0x0200000000000000, 0x0000000000000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, ror, 0x0004000000000000, 0x0000000000000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, ror, 0x0000000200000000, 0x0000000000000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, ror, 0x0200000000000000, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, ror, 0x0004000000000000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, ror, 0x0000000200000000, 0x0000000000000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, ror, 0x0200000000000000, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, ror, 0x0004000000000000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, ror, 0x0000000200000000, 0x0000000000000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, ror, 0x0200000000000000, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, ror, 0x0004000000000000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, ror, 0x0000000200000000, 0x0000000000000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, ror, 0x0200000000000000, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, ror, 0x0004000000000000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, ror, 0x0000000200000000, 0x0000000000000001, 31 );

  TEST_RR_ZEROSRC1( 40, ror, 0, 15 );
  TEST_RR_ZEROSRC2( 41, ror, 32, 32 );
  TEST_RR_ZEROSRC12( 42, ror, 0 );
  TEST_RR_ZERODEST( 43, ror, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rev8.S
#-----------------------------------------------------------------------------
#
# Test rev8 instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  rev8, 0x0000000000000000, 0x0000000000000000);
  TEST_R_OP( 3,  rev8, 0x0100000000000000, 0x0000000000000001);
  TEST_R_OP( 4,  rev8, 0x0300000000000000, 0x0000000000000003);

  TEST_R_OP( 5,  rev8, 0x0080ffffffffffff, 0xffffffffffff8000 );
  TEST_R_OP( 6,  rev8, 0x0000800000000000, 0x0000000000800000 );
  TEST_R_OP( 7,  rev8, 0x0080ffffffff0400, 0x0004ffffffff8000 );

  TEST_R_OP( 8,  rev8, 0xff7f000000000000, 0x0000000000007fff);
  TEST_R_OP( 9,  rev8, 0xffffff7f00000000, 0x000000007fffffff);
  TEST_R_OP( 10, rev8, 0xffff070000000000, 0x000000000007ffff );

  TEST_R_OP( 11, rev8, 0x00000080ffffffff, 0xffffffff80000000);
  TEST_R_OP( 12, rev8, 0x00501f128f57ff00, 0x00ff578f121f5000);

  TEST_R_OP( 13, rev8, 0x0000000000000080, 0x8000000000000000);
  TEST_R_OP( 14, rev8, 0x0e00000000000000, 0x000000000000000e);
  TEST_R_OP( 15, rev8, 0x41134020030000a0, 0xa000000320401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, rev8, 0x0d00000000000000, 13);
  TEST_R_SRC1_EQ_DEST( 17, rev8, 0x0b00000000000000, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, rev8, 0x0d00000000000000, 13);
  TEST_R_DEST_BYPASS( 29, 1, rev8, 0x1300000000000000, 19);
  TEST_R_DEST_BYPASS( 20, 2, rev8, 0x2200000000000000, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  rev8, 0x00807f0000000000, 0x00000000007f8000 );
  TEST_R_OP( 22,  rev8, 0x0080800000000000, 0x0000000000808000 );
  TEST_R_OP( 23,  rev8, 0x0080800100000000, 0x0000000001808000 );

  TEST_R_OP( 24,  rev8, 0xff7f000003000000, 0x0000000300007fff);
  TEST_R_OP( 25,  rev8, 0xffffff7f07000000, 0x000000077fffffff);
  TEST_R_OP( 26,  rev8, 0xffff07000f000000, 0x0000000f0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# andn.S
#-----------------------------------------------------------------------------
#
# Test and instruction.
# This test is forked from and.S
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, andn, 0xfffffffff000f000, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_OP( 3, andn, 0x000000000f000f00, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_OP( 4, andn, 0x0000000000f000f0, 0x0000000000ff00ff, 0x000000000f0f0f0f );
  TEST_RR_OP( 5, andn, 0x00000000000f000f, 0xfffffffff00ff00f, 0xfffffffff0f0f0f0 );

#if __riscv_xlen == 64
  TEST_RR_OP( 50, andn, 0x0f000f000f000f00, 0x0ff00ff00ff00ff0, 0xf0f0f0f0f0f0f0f0 );
  TEST_RR_OP( 51, andn, 0x00f000f000f000f0, 0x00ff00ff00ff00ff, 0x0f0f0f0f0f0f0f0f );
  TEST_RR_OP( 52, andn, 0x000f000f000f000f, 0xf00ff00ff00ff00f, 0xf0f0f0f0f0f0f0f0 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 6, andn, 0xfffffffff000f000, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC2_EQ_DEST( 7, andn, 0x000000000f000f00, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC12_EQ_DEST( 8, andn, 0x0000000000000000, 0xffffffffff00ff00 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 9,  0, andn, 0xfffffffff000f000, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_DEST_BYPASS( 10, 1, andn, 0x000000000f000f00, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_DEST_BYPASS( 11, 2, andn, 0x0000000000f000f0, 0x0000000000ff00ff, 0x000000000f0f0f0f );

  TEST_RR_SRC12_BYPASS( 12, 0, 0, andn, 0xfffffffff000f000, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC12_BYPASS( 13, 0, 1, andn, 0x000000000f000f00, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 14, 0, 2, andn, 0x0000000000f000f0, 0x0000000000ff00ff, 0x000000000f0f0f0f );
  TEST_RR_SRC12_BYPASS( 15, 1, 0, andn, 0xfffffffff000f000, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC12_BYPASS( 16, 1, 1, andn, 0x000000000f000f00, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 17, 2, 0, andn, 0x0000000000f000f0, 0x0000000000ff00ff, 0x000000000f0f0f0f );

  TEST_RR_SRC21_BYPASS( 18, 0, 0, andn, 0xfffffffff000f000, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC21_BYPASS( 19, 0, 1, andn, 0x000000000f000f00, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 20, 0, 2, andn, 0x0000000000f000f0, 0x0000000000ff00ff, 0x000000000f0f0f0f );
  TEST_RR_SRC21_BYPASS( 21, 1, 0, andn, 0xfffffffff000f000, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC21_BYPASS( 22, 1, 1, andn, 0x000000000f000f00, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 23, 2, 0, andn, 0x0000000000f000f0, 0x0000000000ff00ff, 0x000000000f0f0f0f );

  TEST_RR_ZEROSRC1( 24, andn, 0, 0xffffffffff00ff00 );
  TEST_RR_ZEROSRC2( 25, andn, 0x0000000000ff00ff, 0x0000000000ff00ff );
  TEST_RR_ZEROSRC12( 26, andn, 0 );
  TEST_RR_ZERODEST( 27, andn, 0x0000000011111111, 0x0000000022222222 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# minu.S
#-----------------------------------------------------------------------------
#
# Test minu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  minu, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  minu, 0x00000001, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  minu, 0x00000003, 0x00000003, 0x00000007 );
  TEST_RR_OP( 5,  minu, 0x00000003, 0x00000007, 0x00000003 );

  TEST_RR_OP( 6,  minu, 0x00000000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 7,  minu, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 8,  minu, 0x80000000, 0x80000000, 0xffff8000 );

  TEST_RR_OP( 9,  minu, 0x00000000, 0x00000000, 0x00007fff );
  TEST_RR_OP( 10, minu, 0x00000000, 0x7fffffff, 0x00000000 );
  TEST_RR_OP( 11, minu, 0x00007fff, 0x7fffffff, 0x00007fff );

  TEST_RR_OP( 12, minu, 0x00007fff, 0x80000000, 0x00007fff );
  TEST_RR_OP( 13, minu, 0x7fffffff, 0x7fffffff, 0xffff8000 );

  TEST_RR_OP( 14, minu, 0x00000000, 0x00000000, 0xffffffff );
  TEST_RR_OP( 15, minu, 0x00000001, 0xffffffff, 0x00000001 );
  TEST_RR_OP( 16, minu, 0xffffffff, 0xffffffff, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, minu, 13, 14, 13 );
  TEST_RR_SRC2_EQ_DEST( 18, minu, 11, 11, 13 );
  TEST_RR_SRC12_EQ_DEST( 19, minu, 13, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, minu, 11, 11, 13 );
  TEST_RR_DEST_BYPASS( 21, 1, minu, 13, 14, 13 );
  TEST_RR_DEST_BYPASS( 22, 2, minu, 12, 12, 13 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, minu, 13, 14, 13 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, minu, 11, 11, 13 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, minu, 13, 15, 13 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, minu, 10, 10, 13 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, minu, 13, 16, 13 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, minu, 9,  9, 13 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, minu, 13, 17, 13 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, minu, 8,  8, 13 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, minu, 13, 18, 13 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, minu, 7,  7, 13 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, minu, 13, 19, 13 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, minu, 6,  6, 13 );

  TEST_RR_ZEROSRC1( 35, minu, 0, -1 );
  TEST_RR_ZEROSRC2( 36, minu, 0, -1 );
  TEST_RR_ZEROSRC12( 37, minu, 0 );
  TEST_RR_ZERODEST( 38, minu, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ctzw.S
#-----------------------------------------------------------------------------
#
# Test ctzw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  ctzw, 32, 0x00000000);
  TEST_R_OP( 3,  ctzw, 0, 0x00000001);
  TEST_R_OP( 4,  ctzw, 0, 0x00000003);

  TEST_R_OP( 5,  ctzw, 15, 0xffff8000 );
  TEST_R_OP( 6,  ctzw, 23, 0x00800000 );
  TEST_R_OP( 7,  ctzw, 15, 0xffff8000 );

  TEST_R_OP( 8,  ctzw, 0, 0x00007fff);
  TEST_R_OP( 9,  ctzw, 0, 0x7fffffff);
  TEST_R_OP( 10, ctzw, 0, 0x0007ffff );

  TEST_R_OP( 11, ctzw, 31, 0x80000000);
  TEST_R_OP( 12, ctzw, 12, 0x121f5000);

  TEST_R_OP( 13, ctzw, 30, 0xc0000000);
  TEST_R_OP( 14, ctzw, 1, 0x0000000e);
  TEST_R_OP( 15, ctzw, 0, 0x20401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, ctzw, 0, 13);
  TEST_R_SRC1_EQ_DEST( 17, ctzw, 0, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, ctzw, 0, 13);
  TEST_R_DEST_BYPASS( 29, 1, ctzw, 0, 19);
  TEST_R_DEST_BYPASS( 20, 2, ctzw, 1, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  ctzw, 15, 0x007f8000 );
  TEST_R_OP( 22,  ctzw, 15, 0x00808000 );
  TEST_R_OP( 23,  ctzw, 12, 0x01809000 );

  TEST_R_OP( 24,  ctzw, 0, 0x00007fff);
  TEST_R_OP( 25,  ctzw, 0, 0x7fffffff);
  TEST_R_OP( 26,  ctzw, 0, 0x0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rolw.S
#-----------------------------------------------------------------------------
#
# Test rolw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  rolw, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_RR_OP( 3,  rolw, 0x0000000000000002, 0x0000000000000001, 1  );
  TEST_RR_OP( 4,  rolw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_OP( 5,  rolw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_OP( 6,  rolw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_RR_OP( 7,  rolw, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  rolw, 0xffffffffffffffff, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  rolw, 0xffffffffffffffff, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, rolw, 0xffffffffffffffff, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, rolw, 0xffffffffffffffff, 0xffffffffffffffff, 31 );

  TEST_RR_OP( 12, rolw, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_RR_OP( 13, rolw, 0x0000000042424242, 0x0000000021212121, 1  );
  TEST_RR_OP( 14, rolw, 0xffffffff90909090, 0x0000000021212121, 7  );
  TEST_RR_OP( 15, rolw, 0x0000000048484848, 0x0000000021212121, 14 );
  TEST_RR_OP( 16, rolw, 0xffffffff90909090, 0x0000000021212121, 31 );

  # Verify that rotates only use bottom five bits

  TEST_RR_OP( 17, rolw, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffe0 );
  TEST_RR_OP( 18, rolw, 0x0000000042424242, 0x0000000021212121, 0xffffffffffffffe1 );
  TEST_RR_OP( 19, rolw, 0xffffffff90909090, 0x0000000021212121, 0xffffffffffffffe7 );
  TEST_RR_OP( 20, rolw, 0x0000000048484848, 0x0000000021212121, 0xffffffffffffffee );
  TEST_RR_OP( 21, rolw, 0xffffffff90909090, 0x0000000021212121, 0xffffffffffffffff );

  # Verify that rotates ignore top 32 (using true 64-bit values)

  TEST_RR_OP( 44, rolw, 0x0000000012345678, 0xffffffff12345678, 0 );
  TEST_RR_OP( 45, rolw, 0x0000000023456781, 0xffffffff12345678, 4 );
  TEST_RR_OP( 46, rolw, 0xffffffff92345678, 0x0000000092345678, 0 );
  TEST_RR_OP( 47, rolw, 0xffffffff93456789, 0x0000000099345678, 4 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, rolw, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, rolw, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, rolw, 24, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, rolw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, rolw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, rolw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, rolw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, rolw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, rolw, 0xffffffff80000000, 0x0000000000000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, rolw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, rolw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, rolw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, rolw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, rolw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, rolw, 0xffffffff80000000, 0x0000000000000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, rolw, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, rolw, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, rolw, 0xffffffff80000000, 0x0000000000000001, 31 );

  TEST_RR_ZEROSRC1( 40, rolw, 0, 15 );
  TEST_RR_ZEROSRC2( 41, rolw, 32, 32 );
  TEST_RR_ZEROSRC12( 42, rolw, 0 );
  TEST_RR_ZERODEST( 43, rolw, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# clz.S
#-----------------------------------------------------------------------------
#
# Test clz instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  clz, 64, 0x0000000000000000);
  TEST_R_OP( 3,  clz, 63, 0x0000000000000001);
  TEST_R_OP( 4,  clz, 62, 0x0000000000000003);

  TEST_R_OP( 5,  clz, 0, 0xffffffffffff8000 );
  TEST_R_OP( 6,  clz, 40, 0x0000000000800000 );
  TEST_R_OP( 7,  clz, 13, 0x0004ffffffff8000 );

  TEST_R_OP( 8,  clz, 49, 0x0000000000007fff);
  TEST_R_OP( 9,  clz, 33, 0x000000007fffffff);
  TEST_R_OP( 10, clz, 45, 0x000000000007ffff );

  TEST_R_OP( 11, clz, 0, 0xffffffff80000000);
  TEST_R_OP( 12, clz, 8, 0x00ff578f121f5000);

  TEST_R_OP( 13, clz, 0, 0x8000000000000000);
  TEST_R_OP( 14, clz, 60, 0x000000000000000e);
  TEST_R_OP( 15, clz, 0, 0xa000000320401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, clz, 60, 13);
  TEST_R_SRC1_EQ_DEST( 17, clz, 60, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, clz, 60, 13);
  TEST_R_DEST_BYPASS( 29, 1, clz, 59, 19);
  TEST_R_DEST_BYPASS( 20, 2, clz, 58, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21, clz, 37, 0x00000000070f8000 );
  TEST_R_OP( 22, clz, 36, 0x0000000008008000 );
  TEST_R_OP( 23, clz, 35, 0x0000000018008000 );

  TEST_R_OP( 24, clz, 30, 0x0000000300007fff);
  TEST_R_OP( 25, clz, 29, 0x000000077fffffff);
  TEST_R_OP( 26, clz, 28, 0x0000000f0007ffff);
  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rori.S
#-----------------------------------------------------------------------------
#
# Test rori instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_IMM_OP( 2,  roriw, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_IMM_OP( 3,  roriw, 0xffffffff80000000, 0x0000000000000001, 1  );
  TEST_IMM_OP( 4,  roriw, 0x0000000002000000, 0x0000000000000001, 7  );
  TEST_IMM_OP( 5,  roriw, 0x0000000000040000, 0x0000000000000001, 14 );
  TEST_IMM_OP( 6,  roriw, 0x0000000000000002, 0x0000000000000001, 31 );

  TEST_IMM_OP( 7,  roriw, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_IMM_OP( 8,  roriw, 0xffffffffffffffff, 0xffffffffffffffff, 1  );
  TEST_IMM_OP( 9,  roriw, 0xffffffffffffffff, 0xffffffffffffffff, 7  );
  TEST_IMM_OP( 10, roriw, 0xffffffffffffffff, 0xffffffffffffffff, 14 );
  TEST_IMM_OP( 11, roriw, 0xffffffffffffffff, 0xffffffffffffffff, 31 );

  TEST_IMM_OP( 12, roriw, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_IMM_OP( 13, roriw, 0xffffffff90909090, 0x0000000021212121, 1  );
  TEST_IMM_OP( 14, roriw, 0x0000000042424242, 0x0000000021212121, 7  );
  TEST_IMM_OP( 15, roriw, 0xffffffff84848484, 0x0000000021212121, 14 );
  TEST_IMM_OP( 16, roriw, 0x0000000042424242, 0x0000000021212121, 31 );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_IMM_SRC1_EQ_DEST( 20, roriw, 0x0000000002000000, 0x00000001, 7  );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_IMM_DEST_BYPASS( 21, 0, roriw, 0x0000000002000000, 0x0000000000000001, 7  );
  TEST_IMM_DEST_BYPASS( 22, 1, roriw, 0x0000000000040000, 0x0000000000000001, 14 );
  TEST_IMM_DEST_BYPASS( 23, 2, roriw, 0x0000000000000002, 0x0000000000000001, 31 );

  TEST_IMM_SRC1_BYPASS( 24, 0, roriw, 0x0000000002000000, 0x0000000000000001, 7  );
  TEST_IMM_SRC1_BYPASS( 25, 1, roriw, 0x0000000000040000, 0x0000000000000001, 14 );
  TEST_IMM_SRC1_BYPASS( 26, 2, roriw, 0x0000000000000002, 0x0000000000000001, 31 );

  TEST_IMM_ZEROSRC1( 27, roriw, 0, 31 );
  TEST_IMM_ZERODEST( 28, roriw, 33, 20 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ctz.S
#-----------------------------------------------------------------------------
#
# Test ctz instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  ctz, 64, 0x0000000000000000);
  TEST_R_OP( 3,  ctz, 0, 0x0000000000000001);
  TEST_R_OP( 4,  ctz, 0, 0x0000000000000003);

  TEST_R_OP( 5,  ctz, 15, 0xffffffffffff8000 );
  TEST_R_OP( 6,  ctz, 23, 0x0000000000800000 );
  TEST_R_OP( 7,  ctz, 15, 0x0004ffffffff8000 );

  TEST_R_OP( 8,  ctz, 0, 0x0000000000007fff);
  TEST_R_OP( 9,  ctz, 0, 0x000000007fffffff);
  TEST_R_OP( 10, ctz, 0, 0x000000000007ffff );

  TEST_R_OP( 11, ctz, 31, 0xffffffff80000000);
  TEST_R_OP( 12, ctz, 12, 0x00ff578f121f5000);

  TEST_R_OP( 13, ctz, 63, 0x8000000000000000);
  TEST_R_OP( 14, ctz, 1, 0x000000000000000e);
  TEST_R_OP( 15, ctz, 0, 0xa000000320401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, ctz, 0, 13);
  TEST_R_SRC1_EQ_DEST( 17, ctz, 0, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, ctz, 0, 13);
  TEST_R_DEST_BYPASS( 29, 1, ctz, 0, 19);
  TEST_R_DEST_BYPASS( 20, 2, ctz, 1, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  ctz, 15, 0x00000000007f8000 );
  TEST_R_OP( 22,  ctz, 15, 0x0000000000808000 );
  TEST_R_OP( 23,  ctz, 12, 0x0000000001809000 );

  TEST_R_OP( 24,  ctz, 0, 0x0000000300007fff);
  TEST_R_OP( 25,  ctz, 0, 0x000000077fffffff);
  TEST_R_OP( 26,  ctz, 0, 0x0000000f0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# cpop.S
#-----------------------------------------------------------------------------
#
# Test cpop instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  cpop, 0, 0x0000000000000000);
  TEST_R_OP( 3,  cpop, 1, 0x0000000000000001);
  TEST_R_OP( 4,  cpop, 2, 0x0000000000000003);

  TEST_R_OP( 5,  cpop, 49, 0xffffffffffff8000 );
  TEST_R_OP( 6,  cpop, 1, 0x0000000000800000 );
  TEST_R_OP( 7,  cpop, 34, 0x0004ffffffff8000 );

  TEST_R_OP( 8,  cpop, 15, 0x0000000000007fff);
  TEST_R_OP( 9,  cpop, 31, 0x000000007fffffff);
  TEST_R_OP( 10, cpop, 19, 0x000000000007ffff );

  TEST_R_OP( 11, cpop, 33, 0xffffffff80000000);
  TEST_R_OP( 12, cpop, 27, 0x00ff578f121f5000);

  TEST_R_OP( 13, cpop, 1, 0x8000000000000000);
  TEST_R_OP( 14, cpop, 3, 0x000000000000000e);
  TEST_R_OP( 15, cpop, 11, 0xa000000320401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, cpop, 3, 13);
  TEST_R_SRC1_EQ_DEST( 17, cpop, 3, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, cpop, 3, 13);
  TEST_R_DEST_BYPASS( 29, 1, cpop, 3, 19);
  TEST_R_DEST_BYPASS( 20, 2, cpop, 2, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21, cpop, 8, 0x00000000007f8000 );
  TEST_R_OP( 22, cpop, 2, 0x0000000000808000 );
  TEST_R_OP( 23, cpop, 3, 0x0000000001808000 );

  TEST_R_OP( 24, cpop, 17, 0x0000000300007fff);
  TEST_R_OP( 25, cpop, 34, 0x000000077fffffff);
  TEST_R_OP( 26, cpop, 23, 0x0000000f0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rol.S
#-----------------------------------------------------------------------------
#
# Test rol instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  rol, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_RR_OP( 3,  rol, 0x0000000000000002, 0x0000000000000001, 1  );
  TEST_RR_OP( 4,  rol, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_OP( 5,  rol, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_OP( 6,  rol, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_OP( 7,  rol, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  rol, 0xffffffffffffffff, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  rol, 0xffffffffffffffff, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, rol, 0xffffffffffffffff, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, rol, 0xffffffffffffffff, 0xffffffffffffffff, 31 );

  TEST_RR_OP( 12, rol, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_RR_OP( 13, rol, 0x0000000042424242, 0x0000000021212121, 1  );
  TEST_RR_OP( 14, rol, 0x0000001090909080, 0x0000000021212121, 7  );
  TEST_RR_OP( 15, rol, 0x0000084848484000, 0x0000000021212121, 14 );
  TEST_RR_OP( 16, rol, 0x1090909080000000, 0x0000000021212121, 31 );

  # Verify that rotates only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, rol, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, rol, 0x0000000042424242, 0x0000000021212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, rol, 0x0000001090909080, 0x0000000021212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, rol, 0x0000084848484000, 0x0000000021212121, 0xffffffffffffffce );

#if __riscv_xlen == 64
  TEST_RR_OP( 21, rol, 0x8000000010909090, 0x0000000021212121, 0xffffffffffffffff );
  TEST_RR_OP( 50, rol, 0x8000000000000000, 0x0000000000000001, 63 );
  TEST_RR_OP( 51, rol, 0xffffffffffffffff, 0xffffffffffffffff, 39 );
  TEST_RR_OP( 52, rol, 0x0909080000000109, 0x0000000021212121, 43 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, rol, 0x00000080, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, rol, 0x00004000, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, rol, 24, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, rol, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, rol, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, rol, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, rol, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, rol, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, rol, 0x0000000080000000, 0x0000000000000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, rol, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, rol, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, rol, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, rol, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, rol, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, rol, 0x0000000080000000, 0x0000000000000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, rol, 0x0000000000000080, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, rol, 0x0000000000004000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, rol, 0x0000000080000000, 0x0000000000000001, 31 );

  TEST_RR_ZEROSRC1( 40, rol, 0, 15 );
  TEST_RR_ZEROSRC2( 41, rol, 32, 32 );
  TEST_RR_ZEROSRC12( 42, rol, 0 );
  TEST_RR_ZERODEST( 43, rol, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# rorw.S
#-----------------------------------------------------------------------------
#
# Test rorw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  rorw, 0x0000000000000001, 0x0000000000000001, 0  );
  TEST_RR_OP( 3,  rorw, 0xffffffff80000000, 0x0000000000000001, 1  );
  TEST_RR_OP( 4,  rorw, 0x0000000002000000, 0x0000000000000001, 7  );
  TEST_RR_OP( 5,  rorw, 0x0000000000040000, 0x0000000000000001, 14 );
  TEST_RR_OP( 6,  rorw, 0x0000000000000002, 0x0000000000000001, 31 );

  TEST_RR_OP( 7,  rorw, 0xffffffffffffffff, 0xffffffffffffffff, 0  );
  TEST_RR_OP( 8,  rorw, 0xffffffffffffffff, 0xffffffffffffffff, 1  );
  TEST_RR_OP( 9,  rorw, 0xffffffffffffffff, 0xffffffffffffffff, 7  );
  TEST_RR_OP( 10, rorw, 0xffffffffffffffff, 0xffffffffffffffff, 14 );
  TEST_RR_OP( 11, rorw, 0xffffffffffffffff, 0xffffffffffffffff, 31 );

  TEST_RR_OP( 12, rorw, 0x0000000021212121, 0x0000000021212121, 0  );
  TEST_RR_OP( 13, rorw, 0xffffffff90909090, 0x0000000021212121, 1  );
  TEST_RR_OP( 14, rorw, 0x0000000042424242, 0x0000000021212121, 7  );
  TEST_RR_OP( 15, rorw, 0xffffffff84848484, 0x0000000021212121, 14 );
  TEST_RR_OP( 16, rorw, 0x0000000042424242, 0x0000000021212121, 31 );

  # Verify that shifts only use bottom six(rv64) or five(rv32) bits

  TEST_RR_OP( 17, rorw, 0x0000000021212121, 0x0000000021212121, 0xffffffffffffffc0 );
  TEST_RR_OP( 18, rorw, 0xffffffff90909090, 0x0000000021212121, 0xffffffffffffffc1 );
  TEST_RR_OP( 19, rorw, 0x0000000042424242, 0x0000000021212121, 0xffffffffffffffc7 );
  TEST_RR_OP( 20, rorw, 0xffffffff84848484, 0x0000000021212121, 0xffffffffffffffce );

  TEST_RR_OP( 21, rorw, 0x0000000042424242, 0x0000000021212121, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 22, rorw, 0x0000000002000000, 0x00000001, 7  );
  TEST_RR_SRC2_EQ_DEST( 23, rorw, 0x0000000000040000, 0x00000001, 14 );
  TEST_RR_SRC12_EQ_DEST( 24, rorw, 0x0000000060000000, 3 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 25, 0, rorw, 0x0000000002000000, 0x0000000000000001, 7  );
  TEST_RR_DEST_BYPASS( 26, 1, rorw, 0x0000000000040000, 0x0000000000000001, 14 );
  TEST_RR_DEST_BYPASS( 27, 2, rorw, 0x0000000000000002, 0x0000000000000001, 31 );

  TEST_RR_SRC12_BYPASS( 28, 0, 0, rorw, 0x0000000002000000, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 29, 0, 1, rorw, 0x0000000000040000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 30, 0, 2, rorw, 0x0000000000000002, 0x0000000000000001, 31 );
  TEST_RR_SRC12_BYPASS( 31, 1, 0, rorw, 0x0000000002000000, 0x0000000000000001, 7  );
  TEST_RR_SRC12_BYPASS( 32, 1, 1, rorw, 0x0000000000040000, 0x0000000000000001, 14 );
  TEST_RR_SRC12_BYPASS( 33, 2, 0, rorw, 0x0000000000000002, 0x0000000000000001, 31 );

  TEST_RR_SRC21_BYPASS( 34, 0, 0, rorw, 0x0000000002000000, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 35, 0, 1, rorw, 0x0000000000040000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 36, 0, 2, rorw, 0x0000000000000002, 0x0000000000000001, 31 );
  TEST_RR_SRC21_BYPASS( 37, 1, 0, rorw, 0x0000000002000000, 0x0000000000000001, 7  );
  TEST_RR_SRC21_BYPASS( 38, 1, 1, rorw, 0x0000000000040000, 0x0000000000000001, 14 );
  TEST_RR_SRC21_BYPASS( 39, 2, 0, rorw, 0x0000000000000002, 0x0000000000000001, 31 );

  TEST_RR_ZEROSRC1( 40, rorw, 0, 15 );
  TEST_RR_ZEROSRC2( 41, rorw, 32, 32 );
  TEST_RR_ZEROSRC12( 42, rorw, 0 );
  TEST_RR_ZERODEST( 43, rorw, 1024, 2048 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# max.S
#-----------------------------------------------------------------------------
#
# Test max instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  max, 0x0000000000000000, 0x0000000000000000, 0x0000000000000000 );
  TEST_RR_OP( 3,  max, 0x0000000000000001, 0x0000000000000001, 0x0000000000000001 );
  TEST_RR_OP( 4,  max, 0x0000000000000007, 0x0000000000000003, 0x0000000000000007 );
  TEST_RR_OP( 5,  max, 0x0000000000000007, 0x0000000000000007, 0x0000000000000003 );

  TEST_RR_OP( 6,  max, 0x0000000000000000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 7,  max, 0x0000000000000000, 0xffffffff80000000, 0x0000000000000000 );
  TEST_RR_OP( 8,  max, 0xffffffffffff8000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP( 9,  max, 0x0000000000007fff, 0x0000000000000000, 0x0000000000007fff );
  TEST_RR_OP( 10, max, 0x000000007fffffff, 0x000000007fffffff, 0x0000000000000000 );
  TEST_RR_OP( 11, max, 0x000000007fffffff, 0x000000007fffffff, 0x0000000000007fff );

  TEST_RR_OP( 12, max, 0x0000000000007fff, 0xffffffff80000000, 0x0000000000007fff );
  TEST_RR_OP( 13, max, 0x000000007fffffff, 0x000000007fffffff, 0xffffffffffff8000 );

  TEST_RR_OP( 14, max, 0x0000000000000000, 0x0000000000000000, 0xffffffffffffffff );
  TEST_RR_OP( 15, max, 0x0000000000000001, 0xffffffffffffffff, 0x0000000000000001 );
  TEST_RR_OP( 16, max, 0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, max, 14, 14, 13 );
  TEST_RR_SRC2_EQ_DEST( 18, max, 13, 11, 13 );
  TEST_RR_SRC12_EQ_DEST( 19, max, 13, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, max, 13, 11, 13 );
  TEST_RR_DEST_BYPASS( 21, 1, max, 14, 14, 13 );
  TEST_RR_DEST_BYPASS( 22, 2, max, 13, 12, 13 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, max, 14, 14, 13 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, max, 13, 11, 13 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, max, 15, 15, 13 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, max, 13, 10, 13 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, max, 16, 16, 13 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, max, 13,  9, 13 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, max, 17, 17, 13 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, max, 13,  8, 13 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, max, 18, 18, 13 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, max, 13,  7, 13 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, max, 19, 19, 13 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, max, 13,  6, 13 );

  TEST_RR_ZEROSRC1( 35, max, 0, -1 );
  TEST_RR_ZEROSRC2( 36, max, 0, -1 );
  TEST_RR_ZEROSRC12( 37, max, 0 );
  TEST_RR_ZERODEST( 38, max, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# clzw.S
#-----------------------------------------------------------------------------
#
# Test clzw instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  clzw, 32, 0x00000000);
  TEST_R_OP( 3,  clzw, 31, 0x00000001);
  TEST_R_OP( 4,  clzw, 30, 0x00000003);

  TEST_R_OP( 5,  clzw, 0, 0xffff8000 );
  TEST_R_OP( 6,  clzw, 8, 0x00800000 );
  TEST_R_OP( 7,  clzw, 0, 0xffff8000 );

  TEST_R_OP( 8,  clzw, 17, 0x00007fff);
  TEST_R_OP( 9,  clzw, 1, 0x7fffffff);
  TEST_R_OP( 10, clzw, 13, 0x0007ffff );

  TEST_R_OP( 11, clzw, 0, 0x80000000);
  TEST_R_OP( 12, clzw, 3, 0x121f5000);

  TEST_R_OP( 13, clzw, 5, 0x04000000);
  TEST_R_OP( 14, clzw, 28, 0x0000000e);
  TEST_R_OP( 15, clzw, 2, 0x20401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, clzw, 28, 13);
  TEST_R_SRC1_EQ_DEST( 17, clzw, 28, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, clzw, 28, 13);
  TEST_R_DEST_BYPASS( 29, 1, clzw, 27, 19);
  TEST_R_DEST_BYPASS( 20, 2, clzw, 26, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------


  TEST_R_OP( 21, clzw, 5, 0x070f8000 );
  TEST_R_OP( 22, clzw, 4, 0x08008000 );
  TEST_R_OP( 23, clzw, 3, 0x18008000 );

  TEST_R_OP( 24, clzw, 17, 0x00007fff);
  TEST_R_OP( 25, clzw, 1, 0x7fffffff);
  TEST_R_OP( 26, clzw, 13, 0x0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# maxu.S
#-----------------------------------------------------------------------------
#
# Test maxu instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  maxu, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  maxu, 0x00000001, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  maxu, 0x00000007, 0x00000003, 0x00000007 );
  TEST_RR_OP( 5,  maxu, 0x00000007, 0x00000007, 0x00000003 );

  TEST_RR_OP( 6,  maxu, 0xffff8000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 7,  maxu, 0x80000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 8,  maxu, 0xffff8000, 0x80000000, 0xffff8000 );

  TEST_RR_OP( 9,  maxu, 0x00007fff, 0x00000000, 0x00007fff );
  TEST_RR_OP( 10, maxu, 0x7fffffff, 0x7fffffff, 0x00000000 );
  TEST_RR_OP( 11, maxu, 0x7fffffff, 0x7fffffff, 0x00007fff );

  TEST_RR_OP( 12, maxu, 0x80000000, 0x80000000, 0x00007fff );
  TEST_RR_OP( 13, maxu, 0xffff8000, 0x7fffffff, 0xffff8000 );

  TEST_RR_OP( 14, maxu, 0xffffffff, 0x00000000, 0xffffffff );
  TEST_RR_OP( 15, maxu, 0xffffffff, 0xffffffff, 0x00000001 );
  TEST_RR_OP( 16, maxu, 0xffffffff, 0xffffffff, 0xffffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, maxu, 14, 14, 13 );
  TEST_RR_SRC2_EQ_DEST( 18, maxu, 13, 11, 13 );
  TEST_RR_SRC12_EQ_DEST( 19, maxu, 13, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, maxu, 13, 11, 13 );
  TEST_RR_DEST_BYPASS( 21, 1, maxu, 14, 14, 13 );
  TEST_RR_DEST_BYPASS( 22, 2, maxu, 13, 12, 13 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, maxu, 14, 14, 13 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, maxu, 13, 11, 13 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, maxu, 15, 15, 13 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, maxu, 13, 10, 13 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, maxu, 16, 16, 13 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, maxu, 13,  9, 13 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, maxu, 17, 17, 13 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, maxu, 13,  8, 13 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, maxu, 18, 18, 13 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, maxu, 13,  7, 13 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, maxu, 19, 19, 13 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, maxu, 13,  6, 13 );

  TEST_RR_ZEROSRC1( 35, maxu, -1, -1 );
  TEST_RR_ZEROSRC2( 36, maxu, -1, -1 );
  TEST_RR_ZEROSRC12( 37, maxu, 0 );
  TEST_RR_ZERODEST( 38, maxu, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# orn.S
#-----------------------------------------------------------------------------
#
# Test orn instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Logical tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2, orn, 0xfffffffffff0fff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_OP( 3, orn, 0x000000000fff0fff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_OP( 4, orn, 0xfffffffff0fff0ff, 0x0000000000ff00ff, 0x000000000f0f0f0f );
  TEST_RR_OP( 5, orn, 0xffffffffff0fff0f, 0xfffffffff00ff00f, 0xfffffffff0f0f0f0 );

#if __riscv_xlen == 64
  TEST_RR_OP( 50, orn, 0x0fff0fff0fff0fff, 0x0ff00ff00ff00ff0, 0xf0f0f0f0f0f0f0f0 );
  TEST_RR_OP( 51, orn, 0xf0fff0fff0fff0ff, 0x00ff00ff00ff00ff, 0x0f0f0f0f0f0f0f0f );
  TEST_RR_OP( 52, orn, 0xff0fff0fff0fff0f, 0xf00ff00ff00ff00f, 0xf0f0f0f0f0f0f0f0 );
#endif

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 6, orn, 0xfffffffffff0fff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC2_EQ_DEST( 7, orn, 0xfffffffffff0fff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC12_EQ_DEST( 8, orn, 0xffffffffffffffff, 0xffffffffff00ff00 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 9,  0, orn, 0xfffffffffff0fff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_DEST_BYPASS( 10, 1, orn, 0x000000000fff0fff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_DEST_BYPASS( 11, 2, orn, 0xfffffffff0fff0ff, 0x0000000000ff00ff, 0x000000000f0f0f0f );

  TEST_RR_SRC12_BYPASS( 12, 0, 0, orn, 0xfffffffffff0fff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC12_BYPASS( 13, 0, 1, orn, 0x000000000fff0fff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 14, 0, 2, orn, 0xfffffffff0fff0ff, 0x0000000000ff00ff, 0x000000000f0f0f0f );
  TEST_RR_SRC12_BYPASS( 15, 1, 0, orn, 0xfffffffffff0fff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC12_BYPASS( 16, 1, 1, orn, 0x000000000fff0fff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC12_BYPASS( 17, 2, 0, orn, 0xfffffffff0fff0ff, 0x0000000000ff00ff, 0x000000000f0f0f0f );

  TEST_RR_SRC21_BYPASS( 18, 0, 0, orn, 0xfffffffffff0fff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC21_BYPASS( 19, 0, 1, orn, 0x000000000fff0fff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 20, 0, 2, orn, 0xfffffffff0fff0ff, 0x0000000000ff00ff, 0x000000000f0f0f0f );
  TEST_RR_SRC21_BYPASS( 21, 1, 0, orn, 0xfffffffffff0fff0, 0xffffffffff00ff00, 0x000000000f0f0f0f );
  TEST_RR_SRC21_BYPASS( 22, 1, 1, orn, 0x000000000fff0fff, 0x000000000ff00ff0, 0xfffffffff0f0f0f0 );
  TEST_RR_SRC21_BYPASS( 23, 2, 0, orn, 0xfffffffff0fff0ff, 0x0000000000ff00ff, 0x000000000f0f0f0f );

  TEST_RR_ZEROSRC1( 24, orn, 0x0000000000ff00ff, 0xffffffffff00ff00 );
  TEST_RR_ZEROSRC2( 25, orn, -1, 0x0000000000ff00ff );
  TEST_RR_ZEROSRC12( 26, orn, -1 );
  TEST_RR_ZERODEST( 27, orn, 0x0000000011111111, 0x0000000022222222 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# orc.b.S
#-----------------------------------------------------------------------------
#
# Test orc.b instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  orc.b, 0x0000000000000000, 0x0000000000000000);
  TEST_R_OP( 3,  orc.b, 0x00000000000000ff, 0x0000000000000001);
  TEST_R_OP( 4,  orc.b, 0x00000000000000ff, 0x0000000000000003);

  TEST_R_OP( 5,  orc.b, 0xffffffffffffff00, 0xffffffffffff8000 );
  TEST_R_OP( 6,  orc.b, 0x0000000000ff0000, 0x0000000000800000 );
  TEST_R_OP( 7,  orc.b, 0x00ffffffffffff00, 0x0004ffffffff8000 );

  TEST_R_OP( 8,  orc.b, 0x000000000000ffff, 0x0000000000007fff);
  TEST_R_OP( 9,  orc.b, 0x00000000ffffffff, 0x000000007fffffff);
  TEST_R_OP( 10, orc.b, 0x0000000000ffffff, 0x000000000007ffff );

  TEST_R_OP( 11, orc.b, 0xffffffffff000000, 0xffffffff80000000);
  TEST_R_OP( 12, orc.b, 0x00ffffffffffff00, 0x00ff578f121f5000);

  TEST_R_OP( 13, orc.b, 0xff00000000000000, 0x8000000000000000);
  TEST_R_OP( 14, orc.b, 0x00000000000000ff, 0x000000000000000e);
  TEST_R_OP( 15, orc.b, 0xff0000ffffffffff, 0xa000000320401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, orc.b, 0xff, 13);
  TEST_R_SRC1_EQ_DEST( 17, orc.b, 0xff, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, orc.b, 0xff, 13);
  TEST_R_DEST_BYPASS( 29, 1, orc.b, 0xff, 19);
  TEST_R_DEST_BYPASS( 20, 2, orc.b, 0xff, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  orc.b, 0x0000000000ffff00, 0x00000000007f8000 );
  TEST_R_OP( 22,  orc.b, 0x0000000000ffff00, 0x0000000000808000 );
  TEST_R_OP( 23,  orc.b, 0x00000000ffffff00, 0x0000000001808000 );

  TEST_R_OP( 24,  orc.b, 0x000000ff0000ffff, 0x0000000300007fff);
  TEST_R_OP( 25,  orc.b, 0x000000ffffffffff, 0x000000077fffffff);
  TEST_R_OP( 26,  orc.b, 0x000000ff00ffffff, 0x0000000f0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sext_h.S
#-----------------------------------------------------------------------------
#
# Test sext.h instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  sext.h, 0x0000000000000000, 0x0000000000000000);
  TEST_R_OP( 3,  sext.h, 0x0000000000000001, 0x0000000000000001);
  TEST_R_OP( 4,  sext.h, 0x0000000000000003, 0x0000000000000003);

  TEST_R_OP( 5,  sext.h, 0xffffffffffff8000, 0xffffffffffff8000 );
  TEST_R_OP( 6,  sext.h, 0x0000000000000000, 0x0000000000800000 );
  TEST_R_OP( 7,  sext.h, 0xffffffffffff8000, 0x0004ffffffff8000 );

  TEST_R_OP( 8,  sext.h, 0x0000000000007fff, 0x0000000000007fff);
  TEST_R_OP( 9,  sext.h, 0xffffffffffffffff, 0x000000007fffffff);
  TEST_R_OP( 10, sext.h, 0xffffffffffffffff, 0x000000000007ffff );

  TEST_R_OP( 11, sext.h, 0x0000000000000000, 0xffffffff80000000);
  TEST_R_OP( 12, sext.h, 0x0000000000005000, 0x00ff578f121f5000);

  TEST_R_OP( 13, sext.h, 0x0000000000000000, 0x8000000000000000);
  TEST_R_OP( 14, sext.h, 0x000000000000000e, 0x000000000000000e);
  TEST_R_OP( 15, sext.h, 0x0000000000001341, 0xa000000320401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, sext.h, 0x000000000000000d, 13);
  TEST_R_SRC1_EQ_DEST( 17, sext.h, 0x000000000000000b, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, sext.h, 0x000000000000000d, 13);
  TEST_R_DEST_BYPASS( 29, 1, sext.h, 0x0000000000000013, 19);
  TEST_R_DEST_BYPASS( 20, 2, sext.h, 0x0000000000000022, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  sext.h, 0xffffffffffff8000, 0x00000000007f8000 );
  TEST_R_OP( 22,  sext.h, 0xffffffffffff8000, 0x0000000000808000 );
  TEST_R_OP( 23,  sext.h, 0xffffffffffff8000, 0x0000000001808000 );

  TEST_R_OP( 24,  sext.h, 0x0000000000007fff, 0x0000000300007fff);
  TEST_R_OP( 25,  sext.h, 0xffffffffffffffff, 0x000000077fffffff);
  TEST_R_OP( 26,  sext.h, 0xffffffffffffffff, 0x0000000f0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sext_b.S
#-----------------------------------------------------------------------------
#
# Test sext.b instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_R_OP( 2,  sext.b, 0x0000000000000000, 0x0000000000000000);
  TEST_R_OP( 3,  sext.b, 0x0000000000000001, 0x0000000000000001);
  TEST_R_OP( 4,  sext.b, 0x0000000000000003, 0x0000000000000003);

  TEST_R_OP( 5,  sext.b, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_R_OP( 6,  sext.b, 0x0000000000000000, 0x0000000000800000 );
  TEST_R_OP( 7,  sext.b, 0x0000000000000000, 0x0004ffffffff8000 );

  TEST_R_OP( 8,  sext.b, 0xffffffffffffffff, 0x0000000000007fff);
  TEST_R_OP( 9,  sext.b, 0xffffffffffffffff, 0x000000007fffffff);
  TEST_R_OP( 10, sext.b, 0xffffffffffffffff, 0x000000000007ffff );

  TEST_R_OP( 11, sext.b, 0x0000000000000000, 0xffffffff80000000);
  TEST_R_OP( 12, sext.b, 0x0000000000000000, 0x00ff578f121f5000);

  TEST_R_OP( 13, sext.b, 0x0000000000000000, 0x8000000000000000);
  TEST_R_OP( 14, sext.b, 0x000000000000000e, 0x000000000000000e);
  TEST_R_OP( 15, sext.b, 0x0000000000000041, 0xa000000320401341);

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_R_SRC1_EQ_DEST( 16, sext.b, 0x000000000000000d, 13);
  TEST_R_SRC1_EQ_DEST( 17, sext.b, 0x000000000000000b, 11);

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_R_DEST_BYPASS( 18, 0, sext.b, 0x000000000000000d, 13);
  TEST_R_DEST_BYPASS( 29, 1, sext.b, 0x0000000000000013, 19);
  TEST_R_DEST_BYPASS( 20, 2, sext.b, 0x0000000000000022, 34);

  #-------------------------------------------------------------
  # Other tests
  #-------------------------------------------------------------

  TEST_R_OP( 21,  sext.b, 0x0000000000000000, 0x00000000007f8000 );
  TEST_R_OP( 22,  sext.b, 0x0000000000000000, 0x0000000000808000 );
  TEST_R_OP( 23,  sext.b, 0x0000000000000000, 0x0000000001808000 );

  TEST_R_OP( 24,  sext.b, 0xffffffffffffffff, 0x0000000300007fff);
  TEST_R_OP( 25,  sext.b, 0xffffffffffffffff, 0x000000077fffffff);
  TEST_R_OP( 26,  sext.b, 0xffffffffffffffff, 0x0000000f0007ffff);

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# lh-unaligned.S
#-----------------------------------------------------------------------------
#
# Test that misaligned loads work or raise the correct exception
# This test assumes the target is little-endian
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  TEST_LD_OP( 2, lh, 0x0201, 0,  tdat );
  TEST_LD_OP( 3, lh, 0x0302, 1,  tdat );

2:
  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  MISALIGNED_LOAD_HANDLER

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
    .byte 0x01, 0x02, 0x03, 0x04

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV64M
#define __MACHINE_MODE

#include "../rv64si/csr.S"
# See LICENSE for license details.

#*****************************************************************************
# lw-unaligned.S
#-----------------------------------------------------------------------------
#
# Test that misaligned loads work or raise the correct exception
# This test assumes the target is little-endian
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  TEST_LD_OP( 2, lw, 0x04030201, 0,  tdat );
  TEST_LD_OP( 3, lw, 0x05040302, 1,  tdat );
  TEST_LD_OP( 4, lw, 0x06050403, 2,  tdat );
  TEST_LD_OP( 5, lw, 0x07060504, 3, tdat );

2:
  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  MISALIGNED_LOAD_HANDLER

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
    .byte 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# pmpaddr.S
#-----------------------------------------------------------------------------
#
# Test edge cases around the pmpaddr[G-1] bit which sometimes reads as zero
# but is always writable and retains its state. Also test CSRC and CSRS
# modifications to other bits result in a correct read-modify-write.
#
# This test auto-detects G but assumes PMP is available. It supports a
# maximum G of XLEN-1. There's no minimum but if G is 0 then the G-1 bit
# does not exist and this test trivially passes.

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  li TESTNUM, 1

  # Software may determine the PMP granularity by writing zero to pmpcfg0,
  # then writing all ones to pmpaddr0, then reading back pmpaddr0.
  # If G is the index of the least-significant bit set, the PMP granularity
  # is 2^(G+2) bytes.
  csrw pmpcfg0, zero
  li t0, -1
  csrw pmpaddr0, t0
  csrr t0, pmpaddr0

  # Isolate the least significant bit.

  neg t1, t0
  and a7, t0, t1

  # a7 now contains only the lowest 1 that was set in pmpaddr0.

  # If a7 is 0 then G is >=XLEN which this test does not support.
  beqz a7, fail
  # Shift so the G-1 bit is set.
  srl a7, a7, 1
  # If no bits are set now then G is 0, which trivially passes.
  beqz a7, pass

#define PMPADDR_Gm1_MASK a7
#define PMPCFG_A_MASK (0x3 << 3)
  # Ok now we can begin the main test!

# Set pmpaddr0[G-1] to `value` (1 or 0).
.macro set_pmpaddr_bit value
.if \value
  csrs pmpaddr0, PMPADDR_Gm1_MASK
.else
  csrc pmpaddr0, PMPADDR_Gm1_MASK
.endif
.endm

# Switch pmpcfg0 to OFF mode so pmpaddr0[G-1] reads as 0.
.macro set_mode_off
  csrc pmpcfg0, PMPCFG_A_MASK
.endm

# Switch pmpcfg0 to NAPOT mode so pmpaddr0[G-1] reads normally.
.macro set_mode_napot
  csrs pmpcfg0, PMPCFG_A_MASK
.endm

# Check that pmpaddr9[G] is set or unset depending on expected_value.
.macro check_pmpaddr_bit expected_value
  # Note when gas 2.43 is common we can use \+ instead of \@ which
  # gives more sensible numbers. \@ still works but it gives 4, 6,
  # 8, 10, 15... instead of 0, 1, 2, 3.
  li TESTNUM, (2 + \@)
  csrr t6, pmpaddr0
  and t6, t6, PMPADDR_Gm1_MASK
.if \expected_value
  beqz t6, fail
.else
  bnez t6, fail
.endif
.endm

.macro check_pmpaddr_bit_clear
  csrr t6, pmpaddr0
  and t6, t6, PMPADDR_Gm1_MASK
  bnez t6, fail
.endm

  # Initialise pmpaddr and pmpcfg.

  # M bit is writable in NAPOT mode.
  set_mode_napot
  # Clear it, it should read 0.
  set_pmpaddr_bit 0
  check_pmpaddr_bit 0
  # Set it, it shouldn't read 0.
  set_pmpaddr_bit 1
  check_pmpaddr_bit 1
  # M bit is writable but reads as 0 in OFF mode.
  set_mode_off
  # Should read as 0.
  check_pmpaddr_bit 0
  # Switch back to NAPOT. The 1 should be readable again.
  set_mode_napot
  check_pmpaddr_bit 1

  # Test writing the bit while it is read-as-zero.
  set_pmpaddr_bit 0
  set_mode_off
  set_pmpaddr_bit 1
  set_mode_napot
  check_pmpaddr_bit 1

  # Test modifying a *different* bit while its underlying
  # value is 1 but it reads as 0. Since csrs and csrc are
  # read-modify-write they reads-as value will be written
  # to the underlying value.
  set_mode_off
  # A csrs or csrc from the zero register does not have
  # any side effects.
  csrc pmpaddr0, zero
  csrs pmpaddr0, zero
  set_mode_napot
  check_pmpaddr_bit 1

  set_mode_off
  # Set other bits. This should result in M being cleared
  # since it currently reads as 0.
  not t0, PMPADDR_Gm1_MASK
  csrs pmpaddr0, t0
  set_mode_napot
  check_pmpaddr_bit 0

  j pass

  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  # We aren't expecting any exceptions unless PMP is not supported
  # in which case this test is also not supported. There's no
  # way to probe for PMP support so we can't just pass in this case.
  j fail

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sd-unaligned.S
#-----------------------------------------------------------------------------
#
# Test that misaligned stores work or raise the correct exception
# This test assumes the target is little-endian
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  TEST_ST_OP( 2, ld, sd, 0x0102030405060708, 0, tdat );
  TEST_ST_OP( 3, ld, sd, 0x090a0b0c0d0e0f10, 1, tdat );
  TEST_ST_OP( 4, ld, sd, 0x1112131415161718, 2, tdat );
  TEST_ST_OP( 5, ld, sd, 0x191a1b1c1d1e1f20, 3, tdat );
  TEST_ST_OP( 6, ld, sd, 0x2122232425262728, 4, tdat );
  TEST_ST_OP( 7, ld, sd, 0x292a2b2c2d2e2f30, 5, tdat );
  TEST_ST_OP( 8, ld, sd, 0x3132333435363738, 6, tdat );
  TEST_ST_OP( 9, ld, sd, 0x393a3b3c3d3e3f40, 7, tdat );

2:
  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  MISALIGNED_STORE_HANDLER

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
    .zero 16

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# illegal.S
#-----------------------------------------------------------------------------
#
# Test illegal instruction trap.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  .align 2
  .option norvc

  li TESTNUM, 2
bad2:
  .word 0
  j fail

  # Skip the rest of the test if S-mode is not present.
  li t0, MSTATUS_MPP
  csrc mstatus, t0
  li t1, (MSTATUS_MPP & -MSTATUS_MPP) * PRV_S
  csrs mstatus, t1
  csrr t2, mstatus
  and t2, t2, t0
  bne t1, t2, pass

  # Test vectored interrupts if they are supported.
test_vectored_interrupts:
  csrwi mip, MIP_SSIP
  csrwi mie, MIP_SSIP
  la t0, mtvec_handler + 1
  csrrw s0, mtvec, t0
  csrr t0, mtvec
  andi t0, t0, 1
  beqz t0, msip
  csrsi mstatus, MSTATUS_MIE
1:
  j 1b
msip:
  csrw mtvec, s0

  # Delegate supervisor software interrupts so WFI won't stall.
  csrwi mideleg, MIP_SSIP
  # Enter supervisor mode.
  la t0, 1f
  csrw mepc, t0
  li t0, MSTATUS_MPP
  csrc mstatus, t0
  li t1, (MSTATUS_MPP & -MSTATUS_MPP) * PRV_S
  csrs mstatus, t1
  mret

1:
  # Make sure WFI doesn't trap when TW=0.
  wfi

  # Check if paging is supported (Set SUM & MXR and read it back)
  and t0, t0, zero
  li t0, (SSTATUS_SUM | SSTATUS_MXR)
  csrc sstatus, t0
  and t1, t1, zero
  li t1, (SSTATUS_SUM | SSTATUS_MXR) 
  csrs sstatus, t1
  csrr t2, sstatus
  and t2, t2, t0
  beqz t2, bare_s_1
  csrc sstatus, t0

  # Make sure SFENCE.VMA and satp don't trap when TVM=0.
  sfence.vma
  csrr t0, satp
bad5:
  .word 0
  j fail

bad6:
  # Make sure SFENCE.VMA and satp do trap when TVM=1.
  sfence.vma
  j fail
bad7:
  csrr t0, satp
  j fail

test_tsr:
  # Make sure SRET doesn't trap when TSR=0.
  la t0, bad8
  csrw sepc, t0
  li t0, SSTATUS_SPP
  csrs sstatus, t0
  li t0, SSTATUS_SPIE
  csrc sstatus, t0
  sret
bad8:
  .word 0
  j fail

  # Make sure SRET does trap when TSR=1.
  la t0, 1f
  csrw sepc, t0
bad9:
  sret
1:
  j fail
  j skip_bare_s

bare_s_1:
  # Make sure SFENCE.VMA trap when TVM=0.
  sfence.vma
  j fail

bare_s_2:
  # Set TVM=1. TVM should stay 0 and SFENCE.VMA should still trap 
  sfence.vma
  j fail

  # And access to satp should not trap
  csrr t0, satp
bare_s_3:
  .word 0
  j fail
  j test_tsr

skip_bare_s:
  TEST_PASSFAIL

  .align 8
  .global mtvec_handler
mtvec_handler:
  j synchronous_exception
  j msip
  j fail
  j fail
  j fail
  j fail
  j fail
  j fail
  j fail
  j fail
  j fail
  j fail
  j fail
  j fail
  j fail
  j fail

synchronous_exception:
  li t1, CAUSE_ILLEGAL_INSTRUCTION
  csrr t0, mcause
  bne t0, t1, fail
  csrr t0, mepc

  # Make sure mtval contains either 0 or the instruction word.
  csrr t2, mtval
  beqz t2, 1f
  lhu t1, 0(t0)
  xor t2, t2, t1
  lhu t1, 2(t0)
  slli t1, t1, 16
  xor t2, t2, t1
  bnez t2, fail
1:

  la t1, bad2
  beq t0, t1, 2f
  la t1, bad5
  beq t0, t1, 5f
  la t1, bad6
  beq t0, t1, 6f
  la t1, bad7
  beq t0, t1, 7f
  la t1, bad8
  beq t0, t1, 8f
  la t1, bad9
  beq t0, t1, 9f
  la t1, bare_s_1
  beq t0, t1, 5f
  la t1, bare_s_2
  beq t0, t1, 7f
  la t1, bare_s_3
  beq t0, t1, 7f
  j fail
2:
6:
7:
  addi t0, t0, 8
  csrw mepc, t0
  mret

5:
  li t1, MSTATUS_TVM
  csrs mstatus, t1
  j 2b

8:
  li t1, MSTATUS_TSR
  csrs mstatus, t1
  j 2b

9:
  j 2b

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# zicntr.S
#-----------------------------------------------------------------------------
#
# Test if Zicntr is implemented correctly
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  # Make sure reading the cycle counter in four ways doesn't trap.
  TEST_CASE( 2, x0, 0, csrrc  x0, cycle,    x0);
  TEST_CASE( 3, x0, 0, csrrs  x0, cycle,    x0);
  TEST_CASE( 4, x0, 0, csrrci x0, cycle,    0);
  TEST_CASE( 5, x0, 0, csrrsi x0, cycle,    0);
  TEST_CASE( 6, x0, 0, csrrc  x0, instret,  x0);
  TEST_CASE( 7, x0, 0, csrrs  x0, instret,  x0);
  TEST_CASE( 8, x0, 0, csrrci x0, instret,  0);
  TEST_CASE( 9, x0, 0, csrrsi x0, instret,  0);
#if __riscv_xlen == 32
  TEST_CASE(12, x0, 0, csrrc  x0, cycleh,   x0);
  TEST_CASE(13, x0, 0, csrrs  x0, cycleh,   x0);
  TEST_CASE(14, x0, 0, csrrci x0, cycleh,   0);
  TEST_CASE(15, x0, 0, csrrsi x0, cycleh,   0);
  TEST_CASE(16, x0, 0, csrrc  x0, instreth, x0);
  TEST_CASE(17, x0, 0, csrrs  x0, instreth, x0);
  TEST_CASE(18, x0, 0, csrrci x0, instreth, 0);
  TEST_CASE(19, x0, 0, csrrsi x0, instreth, 0);
#endif

2:
  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  j fail

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# breakpoint.S
#-----------------------------------------------------------------------------
#
# Test breakpoints, if they are implemented.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  # Set up breakpoint to trap on M-mode fetches.
  li TESTNUM, 2

  # Set tcontrol.mte, otherwise breakpoints are disabled. This may trap,
  # because tcontrol is an optional register.
  la a0, 1f
  csrrw a0, mtvec, a0
  li a1, 0x8
  csrs tcontrol, a1
.p2align 2
1:
  csrw mtvec, a0

  # Enable interrupts; see https://github.com/riscv/riscv-debug-spec/blob/f510a7dd33317d0eee0f26b4fa082cd43a5ac7ea/Sdtrig.tex#L213-L214
  csrsi mstatus, MSTATUS_MIE

  # Skip tselect if hard-wired.
  csrw tselect, x0
  csrr a1, tselect
  bne x0, a1, pass

  la a2, 1f
  csrw tdata2, a2
  li a0, (2 << (__riscv_xlen - 4)) | MCONTROL_M | MCONTROL_EXECUTE
  csrw tdata1, a0
  # Skip if breakpoint type is unsupported.
  csrr a1, tdata1
  bne a0, a1, 2f
  .align 2
1:
  # Trap handler should skip this instruction.
  beqz x0, fail

  # Make sure reads don't trap.
  li TESTNUM, 3
  lw a0, (a2)

2:
  # Set up breakpoint to trap on M-mode reads.
  li TESTNUM, 4
  li a0, (2 << (__riscv_xlen - 4)) | MCONTROL_M | MCONTROL_LOAD
  csrw tdata1, a0
  # Skip if breakpoint type is unsupported.
  csrr a1, tdata1
  bne a0, a1, 2f
  la a2, data1
  csrw tdata2, a2

  # Trap handler should skip this instruction.
  lw a2, (a2)
  beqz a2, fail

  # Make sure writes don't trap.
  li TESTNUM, 5
  sw x0, (a2)

2:
  # Set up breakpoint to trap on M-mode stores.
  li TESTNUM, 6
  li a0, (2 << (__riscv_xlen - 4)) |  MCONTROL_M | MCONTROL_STORE
  csrw tdata1, a0
  # Skip if breakpoint type is unsupported.
  csrr a1, tdata1
  bne a0, a1, 2f

  # Trap handler should skip this instruction.
  sw a2, (a2)

  # Make sure store didn't succeed.
  li TESTNUM, 7
  lw a2, (a2)
  bnez a2, fail

  # Try to set up a second breakpoint.
  li a0, 1
  csrw tselect, a0
  csrr a1, tselect
  bne a0, a1, pass

  li a0, (2 << (__riscv_xlen - 4)) | MCONTROL_M | MCONTROL_LOAD
  csrw tdata1, a0
  la a3, data2
  csrw tdata2, a3

  # Make sure the second breakpoint triggers.
  li TESTNUM, 8
  lw a3, (a3)
  beqz a3, fail

  # Make sure the first breakpoint still triggers.
  li TESTNUM, 10
  la a2, data1
  sw a2, (a2)
  li TESTNUM, 11
  lw a2, (a2)
  bnez a2, fail

2:
  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  # Only even-numbered tests should trap.
  andi t0, TESTNUM, 1
  bnez t0, fail

  li t0, CAUSE_BREAKPOINT
  csrr t1, mcause
  bne t0, t1, fail

  csrr t0, mepc
  addi t0, t0, 4
  csrw mepc, t0
  mret

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

data1: .word 0
data2: .word 0

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV64M
#define __MACHINE_MODE

#include "../rv64si/scall.S"
# See LICENSE for license details.

#*****************************************************************************
# lw-unaligned.S
#-----------------------------------------------------------------------------
#
# Test that misaligned loads work or raise the correct exception
# This test assumes the target is little-endian
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  TEST_LD_OP( 2, ld, 0x0807060504030201, 0, tdat );
  TEST_LD_OP( 3, ld, 0x0908070605040302, 1, tdat );
  TEST_LD_OP( 4, ld, 0x0a09080706050403, 2, tdat );
  TEST_LD_OP( 5, ld, 0x0b0a090807060504, 3, tdat );
  TEST_LD_OP( 6, ld, 0x0c0b0a0908070605, 4, tdat );
  TEST_LD_OP( 7, ld, 0x0d0c0b0a09080706, 5, tdat );
  TEST_LD_OP( 8, ld, 0x0e0d0c0b0a090807, 6, tdat );
  TEST_LD_OP( 9, ld, 0x0f0e0d0c0b0a0908, 7, tdat );

2:
  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  MISALIGNED_LOAD_HANDLER

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
    .byte 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
    .byte 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV64M
#define __MACHINE_MODE

#include "../rv64si/sbreak.S"
# See LICENSE for license details.

#*****************************************************************************
# sh-unaligned.S
#-----------------------------------------------------------------------------
#
# Test that misaligned stores work or raise the correct exception
# This test assumes the target is little-endian
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  TEST_ST_OP( 2, lh, sh, 0x1234, 0, tdat );
  TEST_ST_OP( 3, lh, sh, 0x5678, 1, tdat );

2:
  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  MISALIGNED_STORE_HANDLER

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
    .zero 4

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV64M
#define __MACHINE_MODE

#include "../rv64si/ma_fetch.S"
# See LICENSE for license details.

#*****************************************************************************
# sw-unaligned.S
#-----------------------------------------------------------------------------
#
# Test that misaligned stores work or raise the correct exception
# This test assumes the target is little-endian
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  TEST_ST_OP( 2, lw, sw, 0x12345678, 0, tdat );
  TEST_ST_OP( 3, lw, sw, 0xffffffff9abcdef0, 1, tdat );
  TEST_ST_OP( 4, lw, sw, 0xffffffffdeadbeef, 2, tdat );
  TEST_ST_OP( 5, lw, sw, 0xfffffffffeed0011, 3, tdat );

2:
  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  MISALIGNED_STORE_HANDLER

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

tdat:
    .zero 8

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# ma_addr.S
#-----------------------------------------------------------------------------
#
# Test misaligned ld/st trap.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  .align 2
  .option norvc

  la s0, data

  # indicate it's a load test
  li s1, CAUSE_MISALIGNED_LOAD
  li s2, CAUSE_LOAD_ACCESS

#define SEXT(x, n) ((-((x) >> ((n)-1)) << (n)) | ((x) & ((1 << (n))-1)))

/* Check that a misaligned load either writes the correct value, or
   takes an exception and performs no writeback.  */
#define MISALIGNED_LOAD_TEST(testnum, insn, base, offset, res) \
  li TESTNUM, testnum; \
  la t2, 1f; \
  addi t1, base, offset; \
  insn t1, offset(base); \
  li t2, res; \
  bne t1, t2, fail; \
1:

  MISALIGNED_LOAD_TEST(2,  lh,  s0, 1, SEXT(0xbbcc, 16))
  MISALIGNED_LOAD_TEST(3,  lhu, s0, 1, 0xbbcc)
  MISALIGNED_LOAD_TEST(4,  lw,  s0, 1, SEXT(0x99aabbcc, 32))
  MISALIGNED_LOAD_TEST(5,  lw,  s0, 2, SEXT(0x8899aabb, 32))
  MISALIGNED_LOAD_TEST(6,  lw,  s0, 3, SEXT(0x778899aa, 32))

#if __riscv_xlen == 64
  MISALIGNED_LOAD_TEST(7,  lwu, s0, 1, 0x99aabbcc)
  MISALIGNED_LOAD_TEST(8,  lwu, s0, 2, 0x8899aabb)
  MISALIGNED_LOAD_TEST(9,  lwu, s0, 3, 0x778899aa)

  MISALIGNED_LOAD_TEST(10, ld, s0, 1, 0x5566778899aabbcc)
  MISALIGNED_LOAD_TEST(11, ld, s0, 2, 0x445566778899aabb)
  MISALIGNED_LOAD_TEST(12, ld, s0, 3, 0x33445566778899aa)
  MISALIGNED_LOAD_TEST(13, ld, s0, 4, 0x2233445566778899)
  MISALIGNED_LOAD_TEST(14, ld, s0, 5, 0x1122334455667788)
  MISALIGNED_LOAD_TEST(15, ld, s0, 6, 0xee11223344556677)
  MISALIGNED_LOAD_TEST(16, ld, s0, 7, 0xffee112233445566)
#endif

  # indicate it's a store test
  li s1, CAUSE_MISALIGNED_STORE
  li s2, CAUSE_STORE_ACCESS

/* Check that a misaligned store has some effect and takes no exception,
   or takes no effect and generates an exception.  This is not very
   thorough.  */
#define MISALIGNED_STORE_TEST(testnum, insn, base, offset, size) \
  li TESTNUM, testnum; \
  la t2, 1f; \
  addi t1, base, offset; \
  insn x0, offset(base); \
  lb t1, (offset - 1)(base); \
  beqz t1, fail; \
  lb t1, (offset + size)(base); \
  beqz t1, fail; \
  lb t1, (offset + 0)(base); \
  bnez t1, fail; \
  lb t1, (offset + size - 1)(base); \
  bnez t1, fail; \
1:

  MISALIGNED_STORE_TEST(22,  sh,  s0, 1, 2)
  MISALIGNED_STORE_TEST(23,  sw,  s0, 5, 4)
  MISALIGNED_STORE_TEST(24,  sw,  s0, 10, 4)
  MISALIGNED_STORE_TEST(25,  sw,  s0, 15, 4)

#if __riscv_xlen == 64
  MISALIGNED_STORE_TEST(26, sd, s0, 25, 8)
  MISALIGNED_STORE_TEST(27, sd, s0, 34, 8)
  MISALIGNED_STORE_TEST(28, sd, s0, 43, 8)
  MISALIGNED_STORE_TEST(29, sd, s0, 52, 8)
  MISALIGNED_STORE_TEST(30, sd, s0, 61, 8)
  MISALIGNED_STORE_TEST(31, sd, s0, 70, 8)
  MISALIGNED_STORE_TEST(32, sd, s0, 79, 8)
#endif

  TEST_PASSFAIL

  .align 3
  .global mtvec_handler
mtvec_handler:
  csrr t0, mcause
  beq t0, s1, 1f
  beq t0, s2, 1f
  j fail
1:

  csrr t0, mtval
  beqz t0, 1f
  bne t0, t1, fail

  lb t0, (t0)
  beqz t0, fail
1:

  csrw mepc, t2
  mret

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

data:
  .align 3
.word 0xaabbccdd
.word 0x66778899
.word 0x22334455
.word 0xeeffee11
.fill 0xff, 1, 80


  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# minstret_overflow.S
#-----------------------------------------------------------------------------
#
# Test if overflow of instret is handled correctly
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  # The value written to instret will be the value read by the following
  # instruction (i.e. the increment is suppressed)
  TEST_CASE(2, a0, 0, csrwi minstret, 0; csrr a0, minstret);

#if __riscv_xlen == 32
  # Writes to instreth are considered writes to instret and so also
  # suppress the increment
  TEST_CASE(3, a0, 0, li t0, 0xffffffff; csrw minstret, t0; csrw minstreth, t0; nop; csrr a0, minstret);
  TEST_CASE(4, a0, 0, csrr a0, minstreth);
#endif

2:
  TEST_PASSFAIL

  .align 2
  .global mtvec_handler
mtvec_handler:
  j fail

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# mcsr.S
#-----------------------------------------------------------------------------
#
# Test various M-mode CSRs.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64M
RVTEST_CODE_BEGIN

  # Check that mcpuid reports the correct XLEN
#if __riscv_xlen == 64
  TEST_CASE(2, a0, 0x2, csrr a0, misa; srl a0, a0, 62)
#else
  TEST_CASE(2, a0, 0x1, csrr a0, misa; srl a0, a0, 30)
#endif

  # Check that mhartid reports 0
  TEST_CASE(3, a0, 0x0, csrr a0, mhartid)

  # Check that reading the following CSRs doesn't cause an exception
  csrr a0, mimpid
  csrr a0, marchid
  csrr a0, mvendorid

  # Check that writing the following CSRs doesn't cause an exception
  li t0, 0
  csrs mtvec, t0
  csrs mepc, t0

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sh1add.S
#-----------------------------------------------------------------------------
#
# Test sh1add instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sh1add, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sh1add, 0x00000003, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sh1add, 0x0000000d, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  sh1add, 0xffff8000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  sh1add, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  sh1add, 0xffff8000, 0x80000000, 0xffff8000 );

  TEST_RR_OP( 8,  sh1add, 0x00007fff, 0x00000000, 0x00007fff );
  TEST_RR_OP( 9,  sh1add, 0xfffffffe, 0x7fffffff, 0x00000000 );
  TEST_RR_OP( 10, sh1add, 0x00007ffd, 0x7fffffff, 0x00007fff );

  TEST_RR_OP( 11, sh1add, 0x00007fff, 0x80000000, 0x00007fff );
  TEST_RR_OP( 12, sh1add, 0xffff7ffe, 0x7fffffff, 0xffff8000 );

  TEST_RR_OP( 13, sh1add, 0xffffffff, 0x00000000, 0xffffffff );
  TEST_RR_OP( 14, sh1add, 0xffffffff, 0xffffffff, 0x00000001 );
  TEST_RR_OP( 15, sh1add, 0xfffffffd, 0xffffffff, 0xffffffff );

  TEST_RR_OP( 16, sh1add, 0x80000001, 0x00000001, 0x7fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sh1add, 37, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, sh1add, 39, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, sh1add, 39, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sh1add, 37, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, sh1add, 39, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, sh1add, 41, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sh1add, 37, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sh1add, 39, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sh1add, 41, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sh1add, 37, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sh1add, 39, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sh1add, 41, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sh1add, 37, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sh1add, 39, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sh1add, 41, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sh1add, 37, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sh1add, 39, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sh1add, 41, 15, 11 );

  TEST_RR_ZEROSRC1( 35, sh1add, 15, 15 );
  TEST_RR_ZEROSRC2( 36, sh1add, 64, 32 );
  TEST_RR_ZEROSRC12( 37, sh1add, 0 );
  TEST_RR_ZERODEST( 38, sh1add, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sh2add.S
#-----------------------------------------------------------------------------
#
# Test sh2add instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sh2add, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sh2add, 0x00000005, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sh2add, 0x00000013, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  sh2add, 0xffff8000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  sh2add, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  sh2add, 0xffff8000, 0x80000000, 0xffff8000 );

  TEST_RR_OP( 8,  sh2add, 0x00007fff, 0x00000000, 0x00007fff );
  TEST_RR_OP( 9,  sh2add, 0xfffffffc, 0x7fffffff, 0x00000000 );
  TEST_RR_OP( 10, sh2add, 0x00007ffb, 0x7fffffff, 0x00007fff );

  TEST_RR_OP( 11, sh2add, 0x00007fff, 0x80000000, 0x00007fff );
  TEST_RR_OP( 12, sh2add, 0xffff7ffc, 0x7fffffff, 0xffff8000 );

  TEST_RR_OP( 13, sh2add, 0xffffffff, 0x00000000, 0xffffffff );
  TEST_RR_OP( 14, sh2add, 0xfffffffd, 0xffffffff, 0x00000001 );
  TEST_RR_OP( 15, sh2add, 0xfffffffb, 0xffffffff, 0xffffffff );

  TEST_RR_OP( 16, sh2add, 0x80000003, 0x00000001, 0x7fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sh2add, 63, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, sh2add, 67, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, sh2add, 65, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sh2add, 63, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, sh2add, 67, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, sh2add, 71, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sh2add, 63, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sh2add, 67, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sh2add, 71, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sh2add, 63, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sh2add, 67, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sh2add, 71, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sh2add, 63, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sh2add, 67, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sh2add, 71, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sh2add, 63, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sh2add, 67, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sh2add, 71, 15, 11 );

  TEST_RR_ZEROSRC1( 35, sh2add, 15, 15 );
  TEST_RR_ZEROSRC2( 36, sh2add, 128, 32 );
  TEST_RR_ZEROSRC12( 37, sh2add, 0 );
  TEST_RR_ZERODEST( 38, sh2add, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# sh3add.S
#-----------------------------------------------------------------------------
#
# Test sh3add instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV32U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP( 2,  sh3add, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  sh3add, 0x00000009, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  sh3add, 0x0000001f, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  sh3add, 0xffff8000, 0x00000000, 0xffff8000 );
  TEST_RR_OP( 6,  sh3add, 0x00000000, 0x80000000, 0x00000000 );
  TEST_RR_OP( 7,  sh3add, 0xffff8000, 0x80000000, 0xffff8000 );

  TEST_RR_OP( 8,  sh3add, 0x00007fff, 0x00000000, 0x00007fff );
  TEST_RR_OP( 9,  sh3add, 0xfffffff8, 0x7fffffff, 0x00000000 );
  TEST_RR_OP( 10, sh3add, 0x00007ff7, 0x7fffffff, 0x00007fff );

  TEST_RR_OP( 11, sh3add, 0x00007fff, 0x80000000, 0x00007fff );
  TEST_RR_OP( 12, sh3add, 0xffff7ff8, 0x7fffffff, 0xffff8000 );

  TEST_RR_OP( 13, sh3add, 0xffffffff, 0x00000000, 0xffffffff );
  TEST_RR_OP( 14, sh3add, 0xfffffff9, 0xffffffff, 0x00000001 );
  TEST_RR_OP( 15, sh3add, 0xfffffff7, 0xffffffff, 0xffffffff );

  TEST_RR_OP( 16, sh3add, 0x80000007, 0x00000001, 0x7fffffff );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 17, sh3add, 115, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 18, sh3add, 123, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 19, sh3add, 117, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 20, 0, sh3add, 115, 13, 11 );
  TEST_RR_DEST_BYPASS( 21, 1, sh3add, 123, 14, 11 );
  TEST_RR_DEST_BYPASS( 22, 2, sh3add, 131, 15, 11 );

  TEST_RR_SRC12_BYPASS( 23, 0, 0, sh3add, 115, 13, 11 );
  TEST_RR_SRC12_BYPASS( 24, 0, 1, sh3add, 123, 14, 11 );
  TEST_RR_SRC12_BYPASS( 25, 0, 2, sh3add, 131, 15, 11 );
  TEST_RR_SRC12_BYPASS( 26, 1, 0, sh3add, 115, 13, 11 );
  TEST_RR_SRC12_BYPASS( 27, 1, 1, sh3add, 123, 14, 11 );
  TEST_RR_SRC12_BYPASS( 28, 2, 0, sh3add, 131, 15, 11 );

  TEST_RR_SRC21_BYPASS( 29, 0, 0, sh3add, 115, 13, 11 );
  TEST_RR_SRC21_BYPASS( 30, 0, 1, sh3add, 123, 14, 11 );
  TEST_RR_SRC21_BYPASS( 31, 0, 2, sh3add, 131, 15, 11 );
  TEST_RR_SRC21_BYPASS( 32, 1, 0, sh3add, 115, 13, 11 );
  TEST_RR_SRC21_BYPASS( 33, 1, 1, sh3add, 123, 14, 11 );
  TEST_RR_SRC21_BYPASS( 34, 2, 0, sh3add, 131, 15, 11 );

  TEST_RR_ZEROSRC1( 35, sh3add, 15, 15 );
  TEST_RR_ZEROSRC2( 36, sh3add, 256, 32 );
  TEST_RR_ZEROSRC12( 37, sh3add, 0 );
  TEST_RR_ZERODEST( 38, sh3add, 16, 30 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# 2-stage_translation.S
#-----------------------------------------------------------------------------
#
# Set 2 stage translation, do a simple load store.
#

#include "riscv_test.h"
#include "test_macros.h"

#define vspt0_gpa 0x0 
#define vspt1_gpa 0x1000 
#define vspt2_gpa 0x2000
#define GPA 0x200000 

RVTEST_RV64M
RVTEST_CODE_BEGIN

  li TESTNUM, 2

# map GVA 0x0~0xfff to GPA 0x200000~0x200fff
vs_pt_init:
  li t0, vspt1_gpa
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V
  sd t0, vspt_0, t1

  li t0, vspt2_gpa
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V
  sd t0, vspt_1, t1

  li t0, GPA
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V | PTE_X | PTE_A | PTE_D | PTE_R | PTE_W
  sd t0, vspt_2, t1
  
init_vsatp:
  li a0, (SATP_MODE & ~(SATP_MODE<<1)) * SATP_MODE_SV39
  la a1, vspt0_gpa
  srl a1, a1, RISCV_PGSHIFT
  or a1, a1, a0
  csrw vsatp, a1
  hfence.vvma


# map GPA 0x200000~0x200fff to data_page
guest_pt_init:
  la t0, gpt_1
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V
  sd t0, gpt_0, t1

  la t0, gpt_2
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V
  sd t0, gpt_1, t1

  la t0, gpt_3
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V
  sd t0, gpt_1 + 8, t1

  la t0, vspt_0
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V | PTE_R | PTE_W | PTE_A | PTE_D | PTE_U
  sd t0, gpt_2, t1

  la t0, vspt_1
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V | PTE_R | PTE_W | PTE_A | PTE_D | PTE_U
  sd t0, gpt_2 + 8, t1

  la t0, vspt_2
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V | PTE_R | PTE_W | PTE_A | PTE_D | PTE_U
  sd t0, gpt_2 + 16, t1

  la t0, data_page
  srl t0, t0, RISCV_PGSHIFT - PTE_PPN_SHIFT
  ori t0, t0, PTE_V | PTE_R | PTE_W | PTE_A | PTE_D | PTE_U
  sd t0, gpt_3, t1
  
init_hgatp:
  li a0, (SATP_MODE & ~(SATP_MODE<<1)) * SATP_MODE_SV39
  la a1, gpt_0
  srl a1, a1, RISCV_PGSHIFT
  or a1, a1, a0
  csrw hgatp, a1
  hfence.gvma

hstatus_init:
  li a0, HSTATUS_SPVP
  csrs hstatus, a0

  la a0, data_page
  li a1, 0x12345678
  sw a1, 0(a0)

  li t0, 0x0
  hlv.w t2, 0(t0) # should be 0x12345678
  hsv.w t2, 0(t0)
  bne t2, a1, fail
  
  RVTEST_PASS

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

.align 12
vspt_0: .dword 0
.align 12
vspt_1: .dword 0
.align 12
vspt_2: .dword 0

.align 14
gpt_0: .dword 0
.align 14
gpt_1: .dword 0
.align 12
gpt_2: .dword 0
.align 12
gpt_3: .dword 0
.align 12
data_page: .dword 0

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# clmulh.S
#-----------------------------------------------------------------------------
#
# Test clmulh instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP(32,  clmulh, 0x0000000000001200, 0x0000000000007e00, 0x6db6db6db6db6db7 );
  TEST_RR_OP(33,  clmulh, 0x0000000000001240, 0x0000000000007fc0, 0x6db6db6db6db6db7 );

  TEST_RR_OP( 2,  clmulh, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  clmulh, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  clmulh, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  clmulh, 0x0000000000000000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  clmulh, 0x0000000000000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  clmulh, 0x555555557fffd555, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP(30,  clmulh, 0x00000000000133cd, 0xaaaaaaaaaaaaaaab, 0x000000000002fe7d );
  TEST_RR_OP(31,  clmulh, 0x00000000000133cd, 0x000000000002fe7d, 0xaaaaaaaaaaaaaaab );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, clmulh, 0, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 9, clmulh, 0, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 10, clmulh, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, clmulh, 0, 13, 11 );
  TEST_RR_DEST_BYPASS( 12, 1, clmulh, 0, 14, 11 );
  TEST_RR_DEST_BYPASS( 13, 2, clmulh, 0, 15, 11 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, clmulh, 0, 13, 11 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, clmulh, 0, 14, 11 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, clmulh, 0, 15, 11 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, clmulh, 0, 13, 11 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, clmulh, 0, 14, 11 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, clmulh, 0, 15, 11 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, clmulh, 0, 13, 11 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, clmulh, 0, 14, 11 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, clmulh, 0, 15, 11 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, clmulh, 0, 13, 11 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, clmulh, 0, 14, 11 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, clmulh, 0, 15, 11 );

  TEST_RR_ZEROSRC1( 26, clmulh, 0, 31 );
  TEST_RR_ZEROSRC2( 27, clmulh, 0, 32 );
  TEST_RR_ZEROSRC12( 28, clmulh, 0 );
  TEST_RR_ZERODEST( 29, clmulh, 33, 34 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# clmulr.S
#-----------------------------------------------------------------------------
#
# Test clmulr instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP(32,  clmulr, 0x0000000000002400, 0x0000000000007e00, 0x6db6db6db6db6db7 );
  TEST_RR_OP(33,  clmulr, 0x0000000000002480, 0x0000000000007fc0, 0x6db6db6db6db6db7 );

  TEST_RR_OP( 2,  clmulr, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  clmulr, 0x00000000, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  clmulr, 0x00000000, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  clmulr, 0x0000000000000000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  clmulr, 0x0000000000000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  clmulr, 0xaaaaaaaaffffaaaa, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP(30,  clmulr, 0x000000000002679b, 0xaaaaaaaaaaaaaaab, 0x000000000002fe7d );
  TEST_RR_OP(31,  clmulr, 0x000000000002679b, 0x000000000002fe7d, 0xaaaaaaaaaaaaaaab );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, clmulr, 0, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 9, clmulr, 0, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 10, clmulr, 0, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, clmulr, 0, 13, 11 );
  TEST_RR_DEST_BYPASS( 12, 1, clmulr, 0, 14, 11 );
  TEST_RR_DEST_BYPASS( 13, 2, clmulr, 0, 15, 11 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, clmulr, 0, 13, 11 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, clmulr, 0, 14, 11 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, clmulr, 0, 15, 11 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, clmulr, 0, 13, 11 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, clmulr, 0, 14, 11 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, clmulr, 0, 15, 11 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, clmulr, 0, 13, 11 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, clmulr, 0, 14, 11 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, clmulr, 0, 15, 11 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, clmulr, 0, 13, 11 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, clmulr, 0, 14, 11 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, clmulr, 0, 15, 11 );

  TEST_RR_ZEROSRC1( 26, clmulr, 0, 31 );
  TEST_RR_ZEROSRC2( 27, clmulr, 0, 32 );
  TEST_RR_ZEROSRC12( 28, clmulr, 0 );
  TEST_RR_ZERODEST( 29, clmulr, 33, 34 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#*****************************************************************************
# clmul.S
#-----------------------------------------------------------------------------
#
# Test clmul instruction.
#

#include "riscv_test.h"
#include "test_macros.h"

RVTEST_RV64U
RVTEST_CODE_BEGIN

  #-------------------------------------------------------------
  # Arithmetic tests
  #-------------------------------------------------------------

  TEST_RR_OP(32,  clmul, 0x0000000000005a00, 0x0000000000007e00, 0x6db6db6db6db6db7 );
  TEST_RR_OP(33,  clmul, 0x0000000000005b40, 0x0000000000007fc0, 0x6db6db6db6db6db7 );

  TEST_RR_OP( 2,  clmul, 0x00000000, 0x00000000, 0x00000000 );
  TEST_RR_OP( 3,  clmul, 0x00000001, 0x00000001, 0x00000001 );
  TEST_RR_OP( 4,  clmul, 0x00000009, 0x00000003, 0x00000007 );

  TEST_RR_OP( 5,  clmul, 0x0000000000000000, 0x0000000000000000, 0xffffffffffff8000 );
  TEST_RR_OP( 6,  clmul, 0x0000000000000000, 0xffffffff80000000, 0x00000000 );
  TEST_RR_OP( 7,  clmul, 0x5555400000000000, 0xffffffff80000000, 0xffffffffffff8000 );

  TEST_RR_OP(30,  clmul, 0xfffffffffffc324f, 0xaaaaaaaaaaaaaaab, 0x000000000002fe7d );
  TEST_RR_OP(31,  clmul, 0xfffffffffffc324f, 0x000000000002fe7d, 0xaaaaaaaaaaaaaaab );

  #-------------------------------------------------------------
  # Source/Destination tests
  #-------------------------------------------------------------

  TEST_RR_SRC1_EQ_DEST( 8, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC2_EQ_DEST( 9, clmul, 0x62, 14, 11 );
  TEST_RR_SRC12_EQ_DEST( 10, clmul, 0x51, 13 );

  #-------------------------------------------------------------
  # Bypassing tests
  #-------------------------------------------------------------

  TEST_RR_DEST_BYPASS( 11, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_DEST_BYPASS( 12, 1, clmul, 0x62, 14, 11 );
  TEST_RR_DEST_BYPASS( 13, 2, clmul, 0x69, 15, 11 );

  TEST_RR_SRC12_BYPASS( 14, 0, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC12_BYPASS( 15, 0, 1, clmul, 0x62, 14, 11 );
  TEST_RR_SRC12_BYPASS( 16, 0, 2, clmul, 0x69, 15, 11 );
  TEST_RR_SRC12_BYPASS( 17, 1, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC12_BYPASS( 18, 1, 1, clmul, 0x62, 14, 11 );
  TEST_RR_SRC12_BYPASS( 19, 2, 0, clmul, 0x69, 15, 11 );

  TEST_RR_SRC21_BYPASS( 20, 0, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC21_BYPASS( 21, 0, 1, clmul, 0x62, 14, 11 );
  TEST_RR_SRC21_BYPASS( 22, 0, 2, clmul, 0x69, 15, 11 );
  TEST_RR_SRC21_BYPASS( 23, 1, 0, clmul, 0x7f, 13, 11 );
  TEST_RR_SRC21_BYPASS( 24, 1, 1, clmul, 0x62, 14, 11 );
  TEST_RR_SRC21_BYPASS( 25, 2, 0, clmul, 0x69, 15, 11 );

  TEST_RR_ZEROSRC1( 26, clmul, 0, 31 );
  TEST_RR_ZEROSRC2( 27, clmul, 0, 32 );
  TEST_RR_ZEROSRC12( 28, clmul, 0 );
  TEST_RR_ZERODEST( 29, clmul, 33, 34 );

  TEST_PASSFAIL

RVTEST_CODE_END

  .data
RVTEST_DATA_BEGIN

  TEST_DATA

RVTEST_DATA_END
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV32S

#include "../rv64si/csr.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV32S

#include "../rv64si/scall.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV32S

#include "../rv64si/sbreak.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV32S

#include "../rv64si/ma_fetch.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64M
#define RVTEST_RV64M RVTEST_RV32M

#undef SATP_MODE_SV39
#define SATP_MODE_SV39 SATP_MODE_SV32

#include "../rv64si/dirty.S"
# See LICENSE for license details.

#include "riscv_test.h"
#undef RVTEST_RV64S
#define RVTEST_RV64S RVTEST_RV32S

#include "../rv64si/wfi.S"
    .text
    .balign 4
    .global vec_sgemm_nn
# RV64IDV system
#
# void
# vec_sgemm_nn(size_t n,
#          size_t m,
#          size_t k,
#          const float*a,   // m * k matrix
#          size_t lda,
#          const float*b,   // k * n matrix
#          size_t ldb,
#          float*c,         // m * n matrix
#          size_t ldc)
#
#  c += a*b (alpha=1, no transpose on input matrices)
#  matrices stored in C row-major order

#define n a0
#define m a1
#define k a2
#define ap a3
#define astride a4
#define bp a5
#define bstride a6
#define cp a7
#define cstride t0
#define kt t1
#define nt t2
#define bnp t3
#define cnp t4
#define akp t5
#define bkp s0
#define nvl s1
#define ccp s2
#define amp s3

# Use args as additional temporaries
#define ft12 fa0
#define ft13 fa1
#define ft14 fa2
#define ft15 fa3

#define FRAMESIZE 32

# This version holds a 16*VLMAX block of C matrix in vector registers
# in inner loop, but otherwise does not cache or TLB tiling.

vec_sgemm_nn:
    ld cstride, 0(sp)   # Get arg from stack frame	
    addi sp, sp, -FRAMESIZE
    sd s0, 0(sp)
    sd s1, 8(sp)
    sd s2, 16(sp)

    # Check for zero size matrices        
    beqz n, exit
    beqz m, exit
    beqz k, exit

    # Convert elements strides to byte strides.
    slli astride, astride, 2
    slli bstride, bstride, 2
    slli cstride, cstride, 2

    slti t6, m, 16
    bnez t6, end_rows

c_row_loop: # Loop across rows of C blocks

    mv nt, n  # Initialize n counter for next row of C blocks

    mv bnp, bp # Initialize B n-loop pointer to start
    mv cnp, cp # Initialize C n-loop pointer

c_col_loop: # Loop across one row of C blocks
    vsetvli nvl, nt, e32, ta, ma  # 32-bit vectors, LMUL=1

    mv akp, ap   # reset pointer into A to beginning
    mv bkp, bnp # step to next column in B matrix

    # Initalize current C submatrix block from memory.
    vle32.v  v0, (cnp); add ccp, cnp, cstride;
    vle32.v  v1, (ccp); add ccp, ccp, cstride;
    vle32.v  v2, (ccp); add ccp, ccp, cstride;
    vle32.v  v3, (ccp); add ccp, ccp, cstride;
    vle32.v  v4, (ccp); add ccp, ccp, cstride;
    vle32.v  v5, (ccp); add ccp, ccp, cstride;
    vle32.v  v6, (ccp); add ccp, ccp, cstride;
    vle32.v  v7, (ccp); add ccp, ccp, cstride;
    vle32.v  v8, (ccp); add ccp, ccp, cstride;
    vle32.v  v9, (ccp); add ccp, ccp, cstride;
    vle32.v v10, (ccp); add ccp, ccp, cstride;
    vle32.v v11, (ccp); add ccp, ccp, cstride;
    vle32.v v12, (ccp); add ccp, ccp, cstride;
    vle32.v v13, (ccp); add ccp, ccp, cstride;
    vle32.v v14, (ccp); add ccp, ccp, cstride;
    vle32.v v15, (ccp)


    mv kt, k # Initialize inner loop counter

    # Inner loop scheduled assuming 4-clock occupancy of vfmacc instruction and single-issue pipeline
    # Software pipeline loads
    flw ft0, (akp); add amp, akp, astride;
    flw ft1, (amp); add amp, amp, astride;
    flw ft2, (amp); add amp, amp, astride;
    flw ft3, (amp); add amp, amp, astride;
    # Get vector from B matrix
    vle32.v v16, (bkp)

    # Loop on inner dimension for current C block
 k_loop:
    vfmacc.vf v0, ft0, v16
    add bkp, bkp, bstride
    flw ft4, (amp)
    add amp, amp, astride
    vfmacc.vf v1, ft1, v16
    addi kt, kt, -1    # Decrement k counter
    flw ft5, (amp)
    add amp, amp, astride
    vfmacc.vf v2, ft2, v16
    flw ft6, (amp)
    add amp, amp, astride
    flw ft7, (amp)
    vfmacc.vf v3, ft3, v16
    add amp, amp, astride
    flw ft8, (amp)
    add amp, amp, astride
    vfmacc.vf v4, ft4, v16
    flw ft9, (amp)
    add amp, amp, astride
    vfmacc.vf v5, ft5, v16
    flw ft10, (amp)
    add amp, amp, astride
    vfmacc.vf v6, ft6, v16
    flw ft11, (amp)
    add amp, amp, astride
    vfmacc.vf v7, ft7, v16
    flw ft12, (amp)
    add amp, amp, astride
    vfmacc.vf v8, ft8, v16
    flw ft13, (amp)
    add amp, amp, astride
    vfmacc.vf v9, ft9, v16
    flw ft14, (amp)
    add amp, amp, astride
    vfmacc.vf v10, ft10, v16
    flw ft15, (amp)
    add amp, amp, astride
    addi akp, akp, 4            # Move to next column of a
    vfmacc.vf v11, ft11, v16
    beqz kt, 1f                 # Don't load past end of matrix
    flw ft0, (akp)
    add amp, akp, astride
1:  vfmacc.vf v12, ft12, v16
    beqz kt, 1f
    flw ft1, (amp)
    add amp, amp, astride
1:  vfmacc.vf v13, ft13, v16
    beqz kt, 1f
    flw ft2, (amp)
    add amp, amp, astride
1:  vfmacc.vf v14, ft14, v16
    beqz kt, 1f                 # Exit out of loop
    flw ft3, (amp)
    add amp, amp, astride
    vfmacc.vf v15, ft15, v16
    vle32.v v16, (bkp)            # Get next vector from B matrix, overlap loads with jump stalls
    j k_loop

1:  vfmacc.vf v15, ft15, v16
    
    # Save C matrix block back to memory
    vse32.v  v0, (cnp); add ccp, cnp, cstride;
    vse32.v  v1, (ccp); add ccp, ccp, cstride;
    vse32.v  v2, (ccp); add ccp, ccp, cstride;
    vse32.v  v3, (ccp); add ccp, ccp, cstride;
    vse32.v  v4, (ccp); add ccp, ccp, cstride;
    vse32.v  v5, (ccp); add ccp, ccp, cstride;
    vse32.v  v6, (ccp); add ccp, ccp, cstride;
    vse32.v  v7, (ccp); add ccp, ccp, cstride;
    vse32.v  v8, (ccp); add ccp, ccp, cstride;
    vse32.v  v9, (ccp); add ccp, ccp, cstride;
    vse32.v v10, (ccp); add ccp, ccp, cstride;
    vse32.v v11, (ccp); add ccp, ccp, cstride;
    vse32.v v12, (ccp); add ccp, ccp, cstride;
    vse32.v v13, (ccp); add ccp, ccp, cstride;
    vse32.v v14, (ccp); add ccp, ccp, cstride;
    vse32.v v15, (ccp)

    # Following tail instructions should be scheduled earlier in free slots during C block save.
    # Leaving here for clarity.

    # Bump pointers for loop across blocks in one row
    slli t6, nvl, 2
    add cnp, cnp, t6                         # Move C block pointer over
    add bnp, bnp, t6                         # Move B block pointer over
    sub nt, nt, nvl                          # Decrement element count in n dimension
    bnez nt, c_col_loop                      # Any more to do?

    # Move to next set of rows
    addi m, m, -16  # Did 16 rows above
    slli t6, astride, 4  # Multiply astride by 16
    add ap, ap, t6         # Move A matrix pointer down 16 rows
    slli t6, cstride, 4  # Multiply cstride by 16
    add cp, cp, t6         # Move C matrix pointer down 16 rows
    
    slti t6, m, 16
    beqz t6, c_row_loop

    # Handle end of matrix with fewer than 16 rows.
    # Can use smaller versions of above decreasing in powers-of-2 depending on code-size concerns.
end_rows:
    # Not done.

exit:
    ld s0, 0(sp)
    ld s1, 8(sp)
    ld s2, 16(sp)
    addi sp, sp, FRAMESIZE
    ret
# See LICENSE for license details.

#include "encoding.h"

#if __riscv_xlen == 64
# define LREG ld
# define SREG sd
# define REGBYTES 8
#else
# define LREG lw
# define SREG sw
# define REGBYTES 4
#endif

  .section ".text.init"
  .globl _start
_start:
  li  x1, 0
  li  x2, 0
  li  x3, 0
  li  x4, 0
  li  x5, 0
  li  x6, 0
  li  x7, 0
  li  x8, 0
  li  x9, 0
  li  x10,0
  li  x11,0
  li  x12,0
  li  x13,0
  li  x14,0
  li  x15,0
  li  x16,0
  li  x17,0
  li  x18,0
  li  x19,0
  li  x20,0
  li  x21,0
  li  x22,0
  li  x23,0
  li  x24,0
  li  x25,0
  li  x26,0
  li  x27,0
  li  x28,0
  li  x29,0
  li  x30,0
  li  x31,0

  # enable FPU, vector, and accelerator if present
  li t0, MSTATUS_FS | MSTATUS_XS | MSTATUS_VS
  csrs mstatus, t0

  # make sure XLEN agrees with compilation choice
  li t0, 1
  slli t0, t0, 31
#if __riscv_xlen == 64
  bgez t0, 1f
#else
  bltz t0, 1f
#endif
2:
  li a0, 1
  sw a0, tohost, t0
  j 2b
1:

#ifdef __riscv_flen
  # initialize FPU if we have one
  la t0, 1f
  csrw mtvec, t0

  fssr    x0
  fmv.s.x f0, x0
  fmv.s.x f1, x0
  fmv.s.x f2, x0
  fmv.s.x f3, x0
  fmv.s.x f4, x0
  fmv.s.x f5, x0
  fmv.s.x f6, x0
  fmv.s.x f7, x0
  fmv.s.x f8, x0
  fmv.s.x f9, x0
  fmv.s.x f10,x0
  fmv.s.x f11,x0
  fmv.s.x f12,x0
  fmv.s.x f13,x0
  fmv.s.x f14,x0
  fmv.s.x f15,x0
  fmv.s.x f16,x0
  fmv.s.x f17,x0
  fmv.s.x f18,x0
  fmv.s.x f19,x0
  fmv.s.x f20,x0
  fmv.s.x f21,x0
  fmv.s.x f22,x0
  fmv.s.x f23,x0
  fmv.s.x f24,x0
  fmv.s.x f25,x0
  fmv.s.x f26,x0
  fmv.s.x f27,x0
  fmv.s.x f28,x0
  fmv.s.x f29,x0
  fmv.s.x f30,x0
  fmv.s.x f31,x0
1:
#endif

  # initialize trap vector
  la t0, trap_entry
  csrw mtvec, t0

  # initialize global pointer
.option push
.option norelax
  la gp, __global_pointer$
.option pop

  la  tp, _end + 63
  and tp, tp, -64

  # get core id
  csrr a0, mhartid
  # for now, assume only 1 core
  li a1, 1
1:bgeu a0, a1, 1b

  # give each core 128KB of stack + TLS
#define STKSHIFT 17
  add sp, a0, 1
  sll sp, sp, STKSHIFT
  add sp, sp, tp
  sll a2, a0, STKSHIFT
  add tp, tp, a2

  j _init

  .align 2
trap_entry:
  addi sp, sp, -272

  SREG x1, 1*REGBYTES(sp)
  SREG x2, 2*REGBYTES(sp)
  SREG x3, 3*REGBYTES(sp)
  SREG x4, 4*REGBYTES(sp)
  SREG x5, 5*REGBYTES(sp)
  SREG x6, 6*REGBYTES(sp)
  SREG x7, 7*REGBYTES(sp)
  SREG x8, 8*REGBYTES(sp)
  SREG x9, 9*REGBYTES(sp)
  SREG x10, 10*REGBYTES(sp)
  SREG x11, 11*REGBYTES(sp)
  SREG x12, 12*REGBYTES(sp)
  SREG x13, 13*REGBYTES(sp)
  SREG x14, 14*REGBYTES(sp)
  SREG x15, 15*REGBYTES(sp)
  SREG x16, 16*REGBYTES(sp)
  SREG x17, 17*REGBYTES(sp)
  SREG x18, 18*REGBYTES(sp)
  SREG x19, 19*REGBYTES(sp)
  SREG x20, 20*REGBYTES(sp)
  SREG x21, 21*REGBYTES(sp)
  SREG x22, 22*REGBYTES(sp)
  SREG x23, 23*REGBYTES(sp)
  SREG x24, 24*REGBYTES(sp)
  SREG x25, 25*REGBYTES(sp)
  SREG x26, 26*REGBYTES(sp)
  SREG x27, 27*REGBYTES(sp)
  SREG x28, 28*REGBYTES(sp)
  SREG x29, 29*REGBYTES(sp)
  SREG x30, 30*REGBYTES(sp)
  SREG x31, 31*REGBYTES(sp)

  csrr a0, mcause
  csrr a1, mepc
  mv a2, sp
  jal handle_trap
  csrw mepc, a0

  # Remain in M-mode after eret
  li t0, MSTATUS_MPP
  csrs mstatus, t0

  LREG x1, 1*REGBYTES(sp)
  LREG x2, 2*REGBYTES(sp)
  LREG x3, 3*REGBYTES(sp)
  LREG x4, 4*REGBYTES(sp)
  LREG x5, 5*REGBYTES(sp)
  LREG x6, 6*REGBYTES(sp)
  LREG x7, 7*REGBYTES(sp)
  LREG x8, 8*REGBYTES(sp)
  LREG x9, 9*REGBYTES(sp)
  LREG x10, 10*REGBYTES(sp)
  LREG x11, 11*REGBYTES(sp)
  LREG x12, 12*REGBYTES(sp)
  LREG x13, 13*REGBYTES(sp)
  LREG x14, 14*REGBYTES(sp)
  LREG x15, 15*REGBYTES(sp)
  LREG x16, 16*REGBYTES(sp)
  LREG x17, 17*REGBYTES(sp)
  LREG x18, 18*REGBYTES(sp)
  LREG x19, 19*REGBYTES(sp)
  LREG x20, 20*REGBYTES(sp)
  LREG x21, 21*REGBYTES(sp)
  LREG x22, 22*REGBYTES(sp)
  LREG x23, 23*REGBYTES(sp)
  LREG x24, 24*REGBYTES(sp)
  LREG x25, 25*REGBYTES(sp)
  LREG x26, 26*REGBYTES(sp)
  LREG x27, 27*REGBYTES(sp)
  LREG x28, 28*REGBYTES(sp)
  LREG x29, 29*REGBYTES(sp)
  LREG x30, 30*REGBYTES(sp)
  LREG x31, 31*REGBYTES(sp)

  addi sp, sp, 272
  mret

.section ".tohost","aw",@progbits
.align 6
.globl tohost
tohost: .dword 0
.align 6
.globl fromhost
fromhost: .dword 0
    .text
    .balign 4
    .global vec_daxpy
# void
# vec_daxpy(size_t n, const double a, const double *x, const double *y, double* z)
# {
#   size_t i;
#   for (i=0; i<n; i++)
#     z[i] = a * x[i] + y[i];
# }
#
# register arguments:
#     a0      n
#     fa0     a
#     a1      x
#     a2      y
#     a3      z
vec_daxpy:
    vsetvli a4, a0, e64, m8, ta, ma
    vle64.v v0, (a1)
    sub a0, a0, a4
    slli a4, a4, 3
    add a1, a1, a4
    vle64.v v8, (a2)
    vfmacc.vf v8, fa0, v0
    vse64.v v8, (a3)
    add a2, a2, a4
    add a3, a3, a4
    bnez a0, vec_daxpy
    ret
   .text
    .balign 4
    .global vec_memcpy
    # void *vec_memcpy(void* dest, const void* src, size_t n)
    # a0=dest, a1=src, a2=n
    #
  vec_memcpy:
      mv a3, a0 # Copy destination
  loop:
    vsetvli t0, a2, e8, m8, ta, ma   # Vectors of 8b
    vle8.v v0, (a1)               # Load bytes
      add a1, a1, t0              # Bump pointer
      sub a2, a2, t0              # Decrement count
    vse8.v v0, (a3)               # Store bytes
      add a3, a3, t0              # Bump pointer
      bnez a2, loop               # Any more?
      ret                         # Return
    .text
    .balign 4
    .global vec_strcmp
  # int vec_strcmp(const char *src1, const char* src2)
vec_strcmp:
    ##  Using LMUL=2, but same register names work for larger LMULs
    li t1, 0                # Initial pointer bump
loop:
    vsetvli t0, x0, e8, m2, ta, ma  # Max length vectors of bytes
    add a0, a0, t1          # Bump src1 pointer
    vle8ff.v v8, (a0)       # Get src1 bytes
    add a1, a1, t1          # Bump src2 pointer
    vle8ff.v v16, (a1)      # Get src2 bytes

    vmseq.vi v0, v8, 0      # Flag zero bytes in src1
    vmsne.vv v1, v8, v16    # Flag if src1 != src2
    vmor.mm v0, v0, v1      # Combine exit conditions
    
    vfirst.m a2, v0         # ==0 or != ?
    csrr t1, vl             # Get number of bytes fetched
    
    bltz a2, loop           # Loop if all same and no zero byte

    add a0, a0, a2          # Get src1 element address
    lbu a3, (a0)            # Get src1 byte from memory

    add a1, a1, a2          # Get src2 element address
    lbu a4, (a1)            # Get src2 byte from memory

    sub a0, a3, a4          # Return value.

    ret
#if XLEN == 64
# define LREG ld
# define SREG sd
# define REGBYTES 8
#else
# define LREG lw
# define SREG sw
# define REGBYTES 4
#endif

#ifdef CLINT
#define MTIME_ADDR      CLINT + 0xbff8
#endif

        .global main
main:
        li      s0, 0
        li      s1, MTIME_ADDR
loop:
        addi    s0, s0, 1
        LREG    s2, 0(s1)
        j       loop
#include "encoding.h"

        .global main
        .global main_end
        .global main_post_csrr

        // Load constants into all registers so we can test no register are
        // clobbered after attaching.
main:
        csrr    x1, CSR_MHARTID
        slli    x1, x1, 8
main_post_csrr:
        addi    x2, x1, 1
        addi    x3, x2, 1
        addi    x4, x3, 1
        addi    x5, x4, 1
        addi    x6, x5, 1
        addi    x7, x6, 1
        addi    x8, x7, 1
        addi    x9, x8, 1
        addi    x10, x9, 1
        addi    x11, x10, 1
        addi    x12, x11, 1
        addi    x13, x12, 1
        addi    x14, x13, 1
        addi    x15, x14, 1
        addi    x16, x15, 1
        addi    x17, x16, 1
        addi    x18, x17, 1
        addi    x19, x18, 1
        addi    x20, x19, 1
        addi    x21, x20, 1
        addi    x22, x21, 1
        addi    x23, x22, 1
        addi    x24, x23, 1
        addi    x25, x24, 1
        addi    x26, x25, 1
        addi    x27, x26, 1
        addi    x28, x27, 1
        addi    x29, x28, 1
        addi    x30, x29, 1
        addi    x31, x30, 1
main_end:
        j       main_end
#include "encoding.h"

#if XLEN == 64
# define LREG ld
# define SREG sd
# define REGBYTES 8
#else
# define LREG lw
# define SREG sw
# define REGBYTES 4
#endif

        .global         main

        .section        .text
main:

        la      a0, data
        li      t0, 0
just_before_read_loop:
        li      t2, 16
read_loop:
        lw      t1, 0(a0)
        addi    t1, t1, 1
        addi    t0, t0, 1
read_again:
        lw      t1, 0(a0)
        addi    a0, a0, 4
        blt     t0, t2, read_loop

        la      a0, data
just_before_write_loop:
        li      t0, 1
write_loop:
        sw      t0, 0(a0)
        addi    t0, t0, 1
        addi    a0, a0, 4
        blt     t0, t2, write_loop

        j       main_exit

write_store_trigger:
        /* 2<<60 is for RV64. 2<<28 is for RV32. That's safe because on RV64 bits 28 and 29 are 0. */
        li      a0, (2<<60) | (2<<28) | (1<<6) | (1<<1)
        li      a1, 0xdeadbee0
        jal     write_triggers
        la      a0, data
        jal     read_triggers

write_load_trigger:
        li      a0, (2<<60) | (2<<28) | (1<<6) | (1<<0)
        li      a1, 0xfeedac00
        jal     write_triggers
        la      a0, data
        jal     read_triggers

// Clear triggers so the next test can use them.
clear_triggers:
        li      a0, 0
        jal     write_triggers

main_exit:
        li      a0, 10
        j       _exit

write_triggers:
        // a0: value to write to each tdata1
        // a1: value to write to each tdata2
        li      t0, 0
2:
        csrw    CSR_TSELECT, t0
        csrr    t1, CSR_TSELECT
        bne     t0, t1, 1f
        addi    t0, t0, 1
        csrw    CSR_TDATA2, a1
        csrw    CSR_TDATA1, a0
        j       2b
1:      ret

read_triggers:
        // a0: address where data should be written
        li      t0, 0
2:
        csrw    CSR_TSELECT, t0
        csrr    t1, CSR_TSELECT
        bne     t0, t1, 1f
        addi    t0, t0, 1
        csrr    t1, CSR_TDATA1
        SREG    t1, 0(a0)
        csrr    t1, CSR_TDATA2
        SREG    t1, REGBYTES(a0)
        addi    a0, a0, 2*REGBYTES
        j       2b
1:      SREG    zero, 0(a0)
        ret

        .section .data
        .align  3
data:   .word   0x40
        .word   0x41
        .word   0x42
        .word   0x43
        .word   0x44
        .word   0x45
        .word   0x46
        .word   0x47
        .word   0x48
        .word   0x49
        .word   0x4a
        .word   0x4b
        .word   0x4c
        .word   0x4d
        .word   0x4e
        .word   0x4f
// Test stepping over a variety of instructions.

        .global main

main:
        la      t0, trap_entry          // 0, 4
        csrw    mtvec, t0               // 0x8

        li      t0, 5                   // 0xc
        beq     zero, zero, one         // 0x10
        nop                             // 0x14
one:
        beq     zero, t0, one           // 0x18
        // Use t0 instead of ra to force a 32-bit opcode in C mode. Otherwise
        // 32-bit and 64-bit binaries end up with different instructions (I
        // didn't pursue this).
        jal     t0, two                 // 0x1c

three:
        .word   0                       // 0x20
        nop                             // 0x24

two:
        jr      t0                      // 0x28

        .align  2
trap_entry:
        j       trap_entry              // 0x2c
#include "encoding.h"

#if XLEN == 64
# define LREG ld
# define SREG sd
# define REGBYTES 8
#else
# define LREG lw
# define SREG sw
# define REGBYTES 4
#endif

#define get_field(reg, mask) (((reg) & (mask)) / ((mask) & ~((mask) << 1)))
#define set_field(reg, mask, val) (((reg) & ~(mask)) | (((val) * ((mask) & ~((mask) << 1))) & (mask)))

        .global main
        .global main_end
        .global main_post_csrr

        // Load constants into all registers so we can test no register are
        // clobbered after attaching.
main:
        SREG    ra, 0(sp)
        addi    sp, sp, REGBYTES

        // Set VS=1
        csrr    t0, CSR_MSTATUS
        li      t1, set_field(0, MSTATUS_VS, 1)
        or      t0, t0, t1
        csrw    CSR_MSTATUS, t0

        // copy a to b
        la      a0, a
        jal     vector_load_v4
        la      a0, b
        jal     shift_store_v4

        // assert a == b
        la      a0, a
        la      a1, b
        jal     check_equal
test0:
        bne     a0, zero, return_from_main

        // copy b to c
        la      a0, b
        jal     shift_load_v4
        la      a0, c
        jal     vector_store_v4

        // assert b == c
        la      a0, b
        la      a1, c
        jal     check_equal
test1:
        bne     a0, zero, return_from_main

return_from_main:
        addi    sp, sp, -REGBYTES
        LREG    ra, 0(sp)
        ret

vector_load_v4:
        // a0: point to memory to load from
        csrr    s0, vlenb
        vsetvli zero, s0, e8, m1  # Vectors of 8b
        vle8.v v4, 0(a0)          # Load bytes
        ret

vector_store_v4:
        // a0: point to memory to store to
        csrr    s0, vlenb
        vsetvli zero, s0, e8, m1  # Vectors of 8b
        vse8.v v4, 0(a0)          # Load bytes
        ret

shift_load_v4:
        // a0: pointer to memory to load from

        // Configure all elements in the chain
        csrr    s0, vlenb
#if XLEN == 32
        vsetvli zero, s0, e32
#else
        vsetvli zero, s0, e64
#endif

        // Figure out how long the chain is.
        csrr    s0, vlenb
        li      s1, XLEN/8
        divu    s0, s0, s1

1:
        LREG    s2, 0(a0)
        vslide1down.vx  v4, v4, s2
        addi    a0, a0, REGBYTES
        addi    s0, s0, -1
        bne     s0, zero, 1b

        ret

shift_store_v4:
        // a0: pointer to memory to store to

        // Configure all elements in the chain
        csrr    s0, vlenb
#if XLEN == 32
        vsetvli zero, s0, e32
#else
        vsetvli zero, s0, e64
#endif

        // Figure out how long the chain is.
        csrr    s0, vlenb
        li      s1, XLEN/8
        divu    s0, s0, s1

1:
        vmv.x.s s2, v4
        SREG    s2, 0(a0)
        vslide1down.vx  v4, v4, s2
        addi    a0, a0, REGBYTES
        addi    s0, s0, -1
        bne     s0, zero, 1b

        ret

check_equal:
        csrr    s0, vlenb
1:
        lb      s1, 0(a0)
        lb      s2, 0(a1)
        bne     s1, s2, 2f
        addi    a0, a0, 1
        addi    a1, a1, 1
        addi    s0, s0, -1
        bne     s0, zero, 1b
        li      a0, 0   // equal
        ret
2:      // unequal
        li      a0, 1
        ret

        .data
        .align  6
a:      .word   0xaa00, 0xaa01, 0xaa02, 0xaa03, 0xaa04, 0xaa05, 0xaa06, 0xaa07
        .word   0xaa08, 0xaa09, 0xaa0a, 0xaa0b, 0xaa0c, 0xaa0d, 0xaa0e, 0xaa0f
        .word   0xaa10, 0xaa11, 0xaa12, 0xaa13, 0xaa14, 0xaa15, 0xaa16, 0xaa17
        .word   0xaa18, 0xaa19, 0xaa1a, 0xaa1b, 0xaa1c, 0xaa1d, 0xaa1e, 0xaa1f

b:      .word   0xbb00, 0xbb01, 0xbb02, 0xbb03, 0xbb04, 0xbb05, 0xbb06, 0xbb07
        .word   0xbb08, 0xbb09, 0xbb0b, 0xbb0b, 0xbb0c, 0xbb0d, 0xbb0e, 0xbb0f
        .word   0xbb10, 0xbb11, 0xbb13, 0xbb13, 0xbb14, 0xbb15, 0xbb16, 0xbb17
        .word   0xbb18, 0xbb19, 0xbb1b, 0xbb1b, 0xbb1c, 0xbb1d, 0xbb1e, 0xbb1f

c:      .word   0xcc00, 0xcc01, 0xcc02, 0xcc03, 0xcc04, 0xcc05, 0xcc06, 0xcc07
        .word   0xcc08, 0xcc09, 0xcc0c, 0xcc0c, 0xcc0c, 0xcc0d, 0xcc0e, 0xcc0f
        .word   0xcc10, 0xcc11, 0xcc13, 0xcc13, 0xcc14, 0xcc15, 0xcc16, 0xcc17
        .word   0xcc18, 0xcc19, 0xcc1c, 0xcc1c, 0xcc1c, 0xcc1d, 0xcc1e, 0xcc1f#include "encoding.h"

#define STACK_SIZE (90 * XLEN / 8)

#if XLEN == 64
# define LREG ld
# define SREG sd
# define REGBYTES 8
#else
# define LREG lw
# define SREG sw
# define REGBYTES 4
#endif

  .section      .text.entry
  .globl _start
_start:
  j handle_reset

nmi_vector:
  j nmi_vector

trap_vector:
  j trap_entry

handle_reset:
  // If misa doesn't exist (or is following an old spec where it has a
  // different number), skip the next block.
  la t0, 3f
  csrw mtvec, t0
  csrwi mstatus, 0

  // make sure these registers exist by seeing if either S or U bits
  // are set before attempting to zero them out.
  csrr   t1, misa
  addi   t2, x0, 1 	
  slli   t2, t2, 20 // U_EXTENSION
  and    t2, t1, t2
  bne    x0, t2, 1f
  addi   t2, x0, 1
  slli   t2, t2, 18 // S_EXTENSION	
  and    t2, t1, t2
  bne    x0, t2, 1f
  j 2f
1:
  csrwi mideleg, 0
  csrwi medeleg, 0
2:
  csrwi mie, 0
3:
  la t0, trap_entry
  csrw mtvec, t0
  csrwi mstatus, 0

  # initialize global pointer
.option push
.option norelax
  la gp, __global_pointer$
.option pop

  # Initialize stack pointer.
  la    sp, stack_bottom
  # Give each hart STACK_SIZE of stack.
  # Assume hart IDs are contiguous and start at 0.
  li    t1, STACK_SIZE
  csrr  t0, CSR_MHARTID
  # Don't use mul instruction because not all harts support it.
  addi  t0, t0, 1
1:
  add   sp, sp, t1
  addi  t0, t0, -1
  bnez  t0, 1b

  # Catch trap in case trigger module is not implemented
  la t2, 2f
  csrrw t2, mtvec, t2
  # Clear all hardware triggers
  li    t0, ~0
1:
  addi  t0, t0, 1
  csrw  CSR_TSELECT, t0
  csrw  CSR_TDATA1, zero
  csrr  t1, CSR_TSELECT
  beq   t0, t1, 1b
.p2align 2
2:
  # Restore mtvec and mstatus
  csrw mtvec, t2
  csrwi mstatus, 0

#ifdef MULTICORE
  csrr  t0, CSR_MHARTID
  bnez  t0, wait_until_initialized
#endif

  la    t0, __bss_start
  la    t1, __bss_end
1:
  bge   t0, t1, 2f
  sb    zero, 0(t0)
  addi  t0, t0, 1
  j     1b
2:
#ifdef MULTICORE
  la    t0, initialized
  li    t1, 1
  sw    t1, 0(t0)

wait_until_initialized:      # Wait for hart 0 to perform initialization.
  la    t0, initialized
1:
  lw    t1, 0(t0)
  beqz  t1, 1b
#endif

  # perform the rest of initialization in C
  j     _init


.align 2
trap_entry:
  addi sp, sp, -32*REGBYTES

  SREG x1, 1*REGBYTES(sp)
  SREG x2, 2*REGBYTES(sp)
  SREG x3, 3*REGBYTES(sp)
  SREG x4, 4*REGBYTES(sp)
  SREG x5, 5*REGBYTES(sp)
  SREG x6, 6*REGBYTES(sp)
  SREG x7, 7*REGBYTES(sp)
  SREG x8, 8*REGBYTES(sp)
  SREG x9, 9*REGBYTES(sp)
  SREG x10, 10*REGBYTES(sp)
  SREG x11, 11*REGBYTES(sp)
  SREG x12, 12*REGBYTES(sp)
  SREG x13, 13*REGBYTES(sp)
  SREG x14, 14*REGBYTES(sp)
  SREG x15, 15*REGBYTES(sp)
#ifndef RV32E
  SREG x16, 16*REGBYTES(sp)
  SREG x17, 17*REGBYTES(sp)
  SREG x18, 18*REGBYTES(sp)
  SREG x19, 19*REGBYTES(sp)
  SREG x20, 20*REGBYTES(sp)
  SREG x21, 21*REGBYTES(sp)
  SREG x22, 22*REGBYTES(sp)
  SREG x23, 23*REGBYTES(sp)
  SREG x24, 24*REGBYTES(sp)
  SREG x25, 25*REGBYTES(sp)
  SREG x26, 26*REGBYTES(sp)
  SREG x27, 27*REGBYTES(sp)
  SREG x28, 28*REGBYTES(sp)
  SREG x29, 29*REGBYTES(sp)
  SREG x30, 30*REGBYTES(sp)
  SREG x31, 31*REGBYTES(sp)
#endif

  csrr a0, mcause
  csrr a1, mepc
  mv a2, sp
  jal handle_trap
  csrw mepc, a0

  # Remain in M-mode after mret
  li t0, MSTATUS_MPP
  csrs mstatus, t0

  LREG x1, 1*REGBYTES(sp)
  LREG x2, 2*REGBYTES(sp)
  LREG x3, 3*REGBYTES(sp)
  LREG x4, 4*REGBYTES(sp)
  LREG x5, 5*REGBYTES(sp)
  LREG x6, 6*REGBYTES(sp)
  LREG x7, 7*REGBYTES(sp)
  LREG x8, 8*REGBYTES(sp)
  LREG x9, 9*REGBYTES(sp)
  LREG x10, 10*REGBYTES(sp)
  LREG x11, 11*REGBYTES(sp)
  LREG x12, 12*REGBYTES(sp)
  LREG x13, 13*REGBYTES(sp)
  LREG x14, 14*REGBYTES(sp)
  LREG x15, 15*REGBYTES(sp)
#ifndef RV32E
  LREG x16, 16*REGBYTES(sp)
  LREG x17, 17*REGBYTES(sp)
  LREG x18, 18*REGBYTES(sp)
  LREG x19, 19*REGBYTES(sp)
  LREG x20, 20*REGBYTES(sp)
  LREG x21, 21*REGBYTES(sp)
  LREG x22, 22*REGBYTES(sp)
  LREG x23, 23*REGBYTES(sp)
  LREG x24, 24*REGBYTES(sp)
  LREG x25, 25*REGBYTES(sp)
  LREG x26, 26*REGBYTES(sp)
  LREG x27, 27*REGBYTES(sp)
  LREG x28, 28*REGBYTES(sp)
  LREG x29, 29*REGBYTES(sp)
  LREG x30, 30*REGBYTES(sp)
  LREG x31, 31*REGBYTES(sp)
#endif

  addi sp, sp, 32*REGBYTES
  mret

loop_forever:
  j loop_forever

  .align 2
precease:
    // Loop a while so that OpenOCD might have confirmed the resume before the
    // hart becomes unavailable.
    li t1, 100000
1:
    addi t1, t1, -1
    bnez t1, 1b
cease:
  .word 0x30500073  // cease
  j loop_forever

  // Fill the stack with data so we can see if it was overrun.
  .section .data
  .align 4
stack_bottom:
  .fill NHARTS * STACK_SIZE/4, 4, 0x22446688
stack_top:
initialized:
  .word 0
#include "encoding.h"

        .global         main

        .section        .text
main:
        # MISA is only readable from machine mode
        csrr    t0, CSR_MISA
        csrr    t0, CSR_MISA
        csrr    t0, CSR_MISA
        csrr    t0, CSR_MISA
#if XLEN == 64
# define LREG ld
# define SREG sd
# define REGBYTES 8
#else
# define LREG lw
# define SREG sw
# define REGBYTES 4
#endif

#include "encoding.h"

        .global main
main:
        nop
        j       main

write_regs:
        SREG    x2, 0(x1)
        SREG    x3, 8(x1)
        SREG    x4, 16(x1)
        SREG    x5, 24(x1)
        SREG    x6, 32(x1)
        SREG    x7, 40(x1)
        SREG    x8, 48(x1)
        SREG    x9, 56(x1)
        SREG    x10, 64(x1)
        SREG    x11, 72(x1)
        SREG    x12, 80(x1)
        SREG    x13, 88(x1)
        SREG    x14, 96(x1)
        SREG    x15, 104(x1)
#ifndef RV32E
        SREG    x16, 112(x1)
        SREG    x17, 120(x1)
        SREG    x18, 128(x1)
        SREG    x19, 136(x1)
        SREG    x20, 144(x1)
        SREG    x21, 152(x1)
        SREG    x22, 160(x1)
        SREG    x23, 168(x1)
        SREG    x24, 176(x1)
        SREG    x25, 184(x1)
        SREG    x26, 192(x1)
        SREG    x27, 200(x1)
        SREG    x28, 208(x1)
        SREG    x29, 216(x1)
        SREG    x30, 224(x1)
        SREG    x31, 232(x1)
#endif

        csrr    x1, CSR_MSCRATCH

all_done:
        j       all_done

        .section .bss
        .balign  16
data:
        .fill   64, 8, 0
#include "encoding.h"
#define PGSHIFT         12

        .global         main

        .section        .text
main:
        # Set up a page table entry that maps 0x0... to 0x8...
        la      t0, page_table
        srli    t0, t0, PGSHIFT
        csrw    CSR_SATP, t0

        # update mstatus
        csrr    t1, CSR_MSTATUS
#if XLEN == 32
        li      t0, (MSTATUS_MPRV | (SATP_MODE_SV32 << 24))
#else
        li      t0, (MSTATUS_MPRV | (SATP_MODE_SV39 << 24))
#endif
        #li      t0, ((VM_SV39 << 24))
        or      t1, t0, t1
        csrw    CSR_MSTATUS, t1

        la      t0, (loop - 0x80000000)
        csrw    CSR_MEPC, t0

        # Exit supervisor mode, entering user mode at loop.
        mret

loop:
        la      t0, data
        lw      t1, 0(t0)
        j       loop

        .section        .data
data:
        .word   0xbead

        .balign 0x1000
page_table:
#if XLEN == 32
        .word   ((0x80000000 >> 2) | PTE_V | PTE_R | PTE_W | PTE_X | PTE_G | PTE_U)
#else
        .word   ((0x80000000 >> 2) | PTE_V | PTE_R | PTE_W | PTE_X | PTE_G | PTE_U)
        .word   0
#endif
